{"version":3,"sources":["../src/Schemata.js"],"names":["runInjectors","SchemaInjectorConfig","stripResolversFromSchema","DefaultFieldMergeResolver","DefaultDirectiveMergeResolver","DefaultEnumMergeResolver","DefaultUnionMergeResolver","DefaultScalarMergeResolver","normalizeSource","debug_log","require","debug_trace","Schemata","String","constructor","typeDefs","resolvers","buildResolvers","flattenResolvers","GRAPHIQL_FLAG","TYPEDEFS_KEY","MAP","WeakMap","set","wmkSchema","wmkResolvers","wmkPreboundResolvers","prevResolverMaps","get","EXE","Symbol","for","buildResolverForEachField","species","iterator","toString","bind","toStringTag","name","ast","parse","sdl","graphiql","value","schema","Class","buildSchema","error","type","typeName","typeDirectives","field","fieldName","fieldArgs","fieldDirectives","context","isRootType","resolve","astNode","delete","schemaResolvers","Object","keys","length","maps","executableSchema","rootValue","schemaResolverFor","valid","_type","getType","_field","getFields","schemaFieldByName","validSchema","astTypeByName","validSDL","definitions","find","f","astFieldByName","fields","hasFlattenedResolvers","asts","query","mutation","subscription","mergeSDL","schemaLanguage","conflictResolvers","DefaultConflictResolvers","source","Error","lAST","rAST","_scalarFns","rType","lType","a","kind","endsWith","substring","push","combineTypeAndSubType","lScalar","lScalarConfig","rScalar","rScalarConfig","resolver","_scalarConfig","scalarMergeResolver","merged","from","gql","print","pareSDL","resolverMap","len","pareTypeAndSubType","index","indexOf","splice","values","types","result","merge","config","DefaultMergeOptions","mergedConfig","left","undefined","right","lResolvers","rResolvers","prevMaps","concat","mergeResolvers","reduce","p","c","i","createMissingResolvers","clearSchema","injectMergedSchema","forEachField","SchemaInjector","mergeSchema","flattenRootResolversOrFirstParam","extendWith","schemata","rootType","item","interim","r","hasAnExecutableSchema","e","clearResolvers","inspect","custom","depth","options","valueOf","forEachOf","fn","suppliedSchema","forEachType","forEachInputObjectType","INPUT_TYPES","forEachUnion","forEachEnum","forEachInterface","forEachScalar","forEachRootType","forEachTypeField","forEachInterfaceField","forEachInputObjectField","run","contextValue","variableValues","operationName","fieldResolver","graphqlSync","runAsync","graphql","showError","schemaOpts","enhance","node","printSchema","ALL","TYPES","INTERFACES","ENUMS","UNIONS","SCALARS","ROOT_TYPES","HIDDEN","t","resolverArgs","args","Array","isArray","resolverInjectors","injector","extraConfig","baseConfig","__schema_injector__","info","_schema","leftType","leftField","rightType","rightField","leftDirective","rightDirective","leftValue","rightValue","leftUnion","rightUnion","leftScalar","leftConfig","rightScalar","rightConfig","fieldMergeResolver","directiveMergeResolver","enumValueMergeResolver","typeValueMergeResolver","subTypeResolverMap","Map","subTypeName","rSubType","lSubType","resultingSubType","wrap","body","trim"],"mappings":"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","file":"Schemata.js","sourceRoot":"src","sourcesContent":["// @flow\n\nconst debug_log = require('debug')('schemata:normal')\nconst debug_trace = require('debug')('schemata:trace')\n\nimport type {\n  ASTNode,\n  BuildSchemaOptions,\n  DirectiveNode,\n  EnumValueNode,\n  ExecutionResult,\n  FieldNode,\n  GraphQLFieldResolver,\n  GraphQLResolveInfo,\n  GraphQLScalarTypeConfig,\n  NamedTypeNode,\n  ObjMap,\n  ParseOptions,\n  ScalarTypeDefinitionNode,\n  Source,\n} from 'graphql'\n\nimport {\n  defaultFieldResolver,\n  GraphQLObjectType,\n  GraphQLSchema,\n  printSchema,\n} from 'graphql'\n\nimport type {\n  ConflictResolvers,\n  DirectiveMergeResolver,\n  EnumMergeResolver,\n  FieldMergeResolver,\n  MergeOptionsConfig,\n  ResolverArgs,\n  ResolverArgsTransformer,\n  ResolverMap,\n  ScalarMergeResolver,\n  SchemaSource,\n  UnionMergeResolver,\n} from './types'\n\nimport { ExtendedResolverMap } from './ExtendedResolverMap'\nimport { ExtendedResolver } from './ExtendedResolver'\nimport { inline } from 'ne-tag-fns'\nimport merge from 'deepmerge'\nimport Util from 'util'\n\nimport {\n  forEachOf,\n  forEachField,\n  ALL,\n  TYPES,\n  INTERFACES,\n  ENUMS,\n  UNIONS,\n  SCALARS,\n  ROOT_TYPES,\n  HIDDEN,\n} from './forEachOf'\n\nimport type { ForEachOfResolver, ForEachFieldResolver } from './forEachOf'\n\n/**\n * A small `String` extension that makes working with SDL/IDL text far easier\n * in both your own libraries as well as in a nodeJS REPL. Built-in to what\n * appears to be a normal String for all intents and purposes, are the ability\n * to transform the string into a set of AST nodes, a built schema or back to\n * the SDL string.\n *\n * @class  Schemata\n */\nexport class Schemata extends String {\n  /**\n   * Creates a new `String`, presumably of SDL or IDL. The getter `.valid`\n   * will provide some indication as to whether or not the code is valid.\n   *\n   * @constructor\n   * @memberOf Schemata\n   *\n   * @param {SchemaSource} typeDefs an instance of Schemata, a string of SDL,\n   * a Source instance of SDL, a GraphQLSchema or ASTNode that can be printed\n   * as an SDL string\n   * @param {ResolverMap} resolvers an object containing field resolvers for\n   * for the schema represented with this string. [Optional]\n   * @param {boolean} buildResolvers if this flag is set to true, build a set\n   * of resolvers after the rest of the instance is initialized and set the\n   * results on the `.resolvers` property of the newly created instance. If\n   * buildResolvers is the string \"all\", then a resolver for each field not\n   * defined will be returned with a `defaultFieldResolver` as its value\n   * @param {boolean} flattenResolvers if true, and if `buildResolvers` is true,\n   * then make an attempt to flatten the root types to the base of the\n   * resolver map object.\n   */\n  constructor(\n    typeDefs: SchemaSource,\n    resolvers: ?ResolverMap = null,\n    buildResolvers: boolean | string = false,\n    flattenResolvers: boolean = false\n  ) {\n    super(normalizeSource(typeDefs))\n\n    resolvers =\n      resolvers ||\n      (typeDefs instanceof Schemata && typeDefs.resolvers) ||\n      (typeDefs instanceof GraphQLSchema &&\n        stripResolversFromSchema(typeDefs)) ||\n      null\n\n    this[GRAPHIQL_FLAG] = true\n    this[TYPEDEFS_KEY] = normalizeSource(typeDefs)\n    this[MAP] = new WeakMap()\n    this[MAP].set(\n      wmkSchema,\n      typeDefs instanceof GraphQLSchema ? typeDefs : null\n    )\n    this[MAP].set(wmkResolvers, resolvers)\n    this[MAP].set(\n      wmkPreboundResolvers,\n      typeDefs instanceof Schemata ? typeDefs.prevResolverMaps : []\n    )\n\n    // Mark a schema passed to use in the constructor as an executable schema\n    // to prevent any replacement of the value by getters that generate a\n    // schema from the SDL\n    if (this[MAP].get(wmkSchema)) {\n      this[MAP].get(wmkSchema)[EXE] = true\n      this[MAP].get(wmkSchema)[Symbol.for('constructor-supplied-schema')] = true\n    }\n\n    // If buildResolvers is true, after the rest is already set and done, go\n    // ahead and build a new set of resolver functions for this instance\n    if (buildResolvers) {\n      if (buildResolvers === 'all') {\n        this[MAP].set(\n          wmkResolvers,\n          this.buildResolverForEachField(flattenResolvers)\n        )\n      }\n      else {\n        this[MAP].set(wmkResolvers, this.buildResolvers(flattenResolvers))\n      }\n    }\n  }\n\n  /**\n   * Symbol.species ensures that any String methods used on this instance will\n   * result in a Schemata instance rather than a String. NOTE: this does not\n   * work as expected in current versions of node. This bit of code here is\n   * basically a bit of future proofing for when Symbol.species starts working\n   * with String extended classes\n   *\n   * @type {Function}\n   */\n  static get [Symbol.species](): Function {\n    return Schemata\n  }\n\n  /**\n   * Redefine the iterator for Schemata instances so that they simply show the\n   * contents of the SDL/typeDefs.\n   *\n   * @type {Function}\n   */\n  get [Symbol.iterator](): Function {\n    return function*() {\n      yield this.toString()\n    }.bind(this)\n  }\n\n  /**\n   * Ensures that instances of Schemata report internally as Schemata object.\n   * Specifically using things like `Object.prototype.toString`.\n   *\n   * @type {string}\n   */\n  get [Symbol.toStringTag](): string {\n    return this.constructor.name\n  }\n\n  /**\n   * Returns the AST nodes for this snippet of SDL. It will throw an error\n   * if the string is not valid SDL/IDL.\n   *\n   * @return {ASTNode} any valid ASTNode supported by GraphQL\n   */\n  get ast(): ASTNode {\n    return this.constructor.parse(this.sdl, false)\n  }\n\n  /**\n   * Retrieves the `graphiql` flag, which defaults to true. This flag can\n   * make setting up an endpoint from a Schemata instance easier with\n   * express-graphql\n   *\n   * @type {boolean}\n   */\n  get graphiql(): boolean {\n    return this[GRAPHIQL_FLAG]\n  }\n\n  /**\n   * Setter to alter the default 'true' flag to make an Schemata instance a\n   * valid single argument to functions like `graphqlHTTP()` from express\n   * GraphQL.\n   *\n   * NOTE: this flag means nothing to the Schemata class but might be useful in\n   * your project.\n   *\n   * @type {boolean} true if graphiql should be started; false otherwise\n   */\n  set graphiql(value: boolean): void {\n    this[GRAPHIQL_FLAG] = value\n  }\n\n  /**\n   * Returns a GraphQLSchema object. Note this will fail and throw an error\n   * if there is not at least one Query, Subscription or Mutation type defined.\n   * If there is no stored schema, and there are resolvers, an executable\n   * schema is returned instead.\n   *\n   * @return {GraphQLSchema} an instance of GraphQLSchema if valid SDL\n   */\n  get schema(): GraphQLSchema {\n    const Class = this.constructor\n    const resolvers = this.resolvers\n    let schema\n\n    // If we have a generated schema already and this instance has a\n    // resolvers object that is not falsey, check to see if the object\n    // has the executable schema flag set or not. If so, simply return\n    // the pre-existing object rather than create a new one.\n    if (this[MAP].get(wmkSchema)) {\n      schema = this[MAP].get(wmkSchema)\n\n      if (resolvers) {\n        // check for the executable schema flag\n        if (schema && schema[EXE]) {\n          return schema\n        }\n      }\n      else if (schema) {\n        return schema\n      }\n    }\n\n    // Attempt to generate a schema using the SDL for this instance. Throw\n    // an error if the SDL is insufficient to generate a GraphQLSchema object\n    try {\n      debug_log('[get .schema] creating schema from SDL')\n      this[MAP].set(wmkSchema, (schema = Class.buildSchema(this.sdl, true)))\n    }\n    catch (error) {\n      debug_log('[get .schema] failed to create schema')\n      debug_trace('[get .schema] ERROR!', error)\n      return null\n    }\n\n    // Only iterate over the fields if there are resolvers set\n    if (resolvers) {\n      forEachField(\n        schema,\n        (\n          type,\n          typeName,\n          typeDirectives,\n          field,\n          fieldName,\n          fieldArgs,\n          fieldDirectives,\n          schema,\n          context\n        ) => {\n          if (!resolvers) {\n            return\n          }\n\n          if (isRootType(type) && resolvers[fieldName]) {\n            field.resolve = resolvers[fieldName]\n            field.astNode.resolve = resolvers[fieldName]\n          }\n\n          if (resolvers[typeName] && resolvers[typeName][fieldName]) {\n            field.resolve = resolvers[typeName][fieldName]\n            field.astNode.resolve = resolvers[typeName][fieldName]\n          }\n        }\n      )\n\n      schema[EXE] = true\n    }\n\n    // Set the generated schema in the weak map using the weak map key\n    this[MAP].set(wmkSchema, schema)\n\n    return schema\n  }\n\n  /**\n   * Sets a GraphQLSchema object on the internal weak map store. If the value\n   * supplied is not truthy (i.e. null, undefined, or even false) then this\n   * method deletes any stored schema in the internal map. Otherwise, the\n   * supplied value is set on the map and subsequent get calls to `.schema`\n   * will return the value supplied.\n   *\n   * If there are bound resolvers on the supplied schema, a symbol denoting\n   * that the schema is an executable schema will be set to prevent it from\n   * being overwritten on subsequent get operations. The bound resolvers will\n   * be merged with the Schemata's resolvers object.\n   *\n   * If resolvers are subsequently set on the `Schemata` instance and the\n   * supplied schema does not have resolvers bound to it, subsequent get\n   * requests for the internal `.schema` may auto-generate a new one with\n   * bound resolvers. You have been warned. =)\n   *\n   * @param {GraphQLSchema} schema an instance of GraphQLSchema instance to\n   * store on the internal weak map. Any schema stored here will be modified\n   * by methods that do so.\n   */\n  set schema(schema: ?GraphQLSchema): void {\n    debug_log('[set .schema]: ', schema ? 'truthy' : 'falsey')\n    debug_trace('[set .schema] ', schema)\n\n    if (!schema) {\n      this[MAP].delete(wmkSchema)\n    }\n    else {\n      let schemaResolvers = stripResolversFromSchema(schema)\n\n      if (Object.keys(schemaResolvers).length) {\n        schema[EXE] = true\n\n        merge((this.resolvers = this.resolvers || {}), schemaResolvers)\n      }\n\n      this[MAP].set(wmkSchema, schema)\n    }\n  }\n\n  /**\n   * When a Schemata instance is merged with another GraphQLSchema, its\n   * resolvers get stored before they are wrapped in a function that updates\n   * the schema object it receives. This allows them to be wrapped safely at\n   * a later date should this instance be merged with another.\n   *\n   * @return {Array<ExtendedResolverMap>} an array of `ExtendedResolverMap`\n   * object instances\n   */\n  get prevResolverMaps(): Array<ExtendedResolverMap> {\n    return this[MAP].get(wmkPreboundResolvers)\n  }\n\n  /**\n   * Sets the pre-bound resolver map objects as an array of\n   * `ExtendedResolverMap` object instances on this instance of Schemata\n   *\n   * @param {Array<ExtendedResolverMap>} maps an array of `ExtendedResolverMap`\n   * object instances\n   */\n  set prevResolverMaps(maps: Array<ExtendedResolverMap>): void {\n    this[MAP].set(wmkPreboundResolvers, maps)\n  }\n\n  /**\n   * Returns a GraphQLSchema object, pre-bound, to the associated resolvers\n   * methods in `.resolvers`. If there are no resolvers, this is essentially\n   * the same as asking for a schema instance using `.schema`. If the SDL\n   * this instance is built around is insufficient to generate a GraphQLSchema\n   * instance, then an error will be thrown.\n   *\n   * @deprecated use `.schema` instead; this simply proxies to that\n   * @return {GraphQLSchema} an instance of GraphQLSchema with pre-bound\n   * resolvers\n   */\n  get executableSchema(): GraphQLSchema {\n    return this.schema\n  }\n\n  /**\n   * Returns the string this instance was generated with.\n   *\n   * @return {string} the string this class instance represents\n   */\n  get sdl(): string {\n    return this[TYPEDEFS_KEY]\n  }\n\n  /**\n   * A synonym or alias for `.sdl`. Placed here for the express purpose of\n   * destructuing when used with Apollo's makeExecutableSchema or other\n   * libraries expecting values of the same name\n   *\n   * i.e.\n   *   // sdl.typeDefs and sdl.resolvers will be where the function expects\n   *   let schema = require('graphql-tools').makeExecutableSchema(sdl)\n   *\n   * @return {string} a string of SDL/IDL for use with graphql\n   */\n  get typeDefs(): string {\n    return this.sdl\n  }\n\n  /**\n   * An internal call to buildResolvers(true), thereby requesting a flattened\n   * resolver map with Query, Mutation and Subscription fields exposed as root\n   * objects the way the Facebook reference implementation expects\n   *\n   * @return {Object} an object of functions or an empty object otherwise\n   */\n  get rootValue(): ResolverMap {\n    return this.buildResolvers(true)\n  }\n\n  /**\n   * Returns any resolvers function object associated with this instance.\n   *\n   * @return {Object} an object containing field resolvers or null if none\n   * are stored within\n   */\n  get resolvers(): ResolverMap {\n    return this[MAP].get(wmkResolvers)\n  }\n\n  /**\n   * A method to fetch a particular field resolver from the schema represented\n   * by this Schemata instance.\n   *\n   * @param {string} type the name of the type desired\n   * @param {string} field the name of the field containing the resolver\n   * @return {Function} the function resolver for the type and field in\n   * question\n   */\n  schemaResolverFor(type: string, field: string): ?Function {\n    if (!this.resolvers || !Object.keys(this.resolvers).length || !this.valid) {\n      return null\n    }\n\n    let _type = this.schema.getType(type)\n    let _field = (_type.getFields() && _type.getFields()[field]) || null\n    let resolve = (_field && _field.resolve) || null\n\n    return resolve\n  }\n\n  /**\n   * Builds a schema based on the SDL in the instance and then parses it to\n   * fetch a named field in a named type. If either the type or field are\n   * missing or if the SDL cannot be built as a schema, null is returned.\n   *\n   * @param {string} type the name of a type\n   * @param {string} field the name of a field contained in the above type\n   * @return {FieldNode} the field reference in the type and field supplied\n   */\n  schemaFieldByName(type: string, field: string): FieldNode {\n    if (!this.validSchema || !this.schema) {\n      return null\n    }\n\n    let _type = this.schema.getType(type)\n    let _field = (_type.getFields() && _type.getFields()[field]) || null\n\n    return _field\n  }\n\n  /**\n   * For SDL that doesn't properly build into a GraphQLSchema, it can still be\n   * parsed and searched for a type by name.\n   *\n   * @param {string} type the name of a type\n   * @return {FieldNode} the field reference in the type and field supplied\n   */\n  astTypeByName(type: string): ASTNode {\n    if (!this.validSDL) {\n      return null\n    }\n\n    let _type = this.ast.definitions.find(f => f.name.value === type)\n\n    return _type\n  }\n\n  /**\n   * For SDL that doesn't properly build into a GraphQLSchema, it can still be\n   * searched for a type and field.\n   *\n   * @param {string} type the name of a type\n   * @param {string} field the name of a field contained in the above type\n   * @return {FieldNode} the field reference in the type and field supplied\n   */\n  astFieldByName(type: string, field: string): FieldNode {\n    if (!this.validSDL) {\n      return null\n    }\n\n    let _type = this.ast.definitions.find(f => f.name.value === type)\n    let _field =\n      (_type && _type.fields.find(f => f.name.value === field)) || null\n\n    return _field\n  }\n\n  /**\n   * Walks the AST for this SDL string and checks for the names of the fields\n   * of each of the root types; Query, Mutation and Subscription. If there are\n   * no root types defined, false is returned.\n   *\n   * If there is at least one root type *and* some resolvers *and* at least one\n   * of the fields of at least one root type is present in the root of the\n   * resolvers map, true is returned. Otherwise, false.\n   *\n   * @return {boolean} true if the defined resolvers have at least one root\n   * type field as a resolver on the root of the resolver map; false otherwise.\n   */\n  get hasFlattenedResolvers(): boolean {\n    let asts = (this.validSDL && this.ast.definitions) || null\n\n    if (!asts || !this.resolvers) {\n      return false\n    }\n\n    let query = asts.find(f => f.name.value == 'Query')\n    let mutation = asts.find(f => f.name.value == 'Mutation')\n    let subscription = asts.find(f => f.name.value == 'Subscription')\n    let resolvers = this.resolvers\n\n    if (!query && !mutation && !subscription) {\n      return false\n    }\n\n    for (let type of [query, mutation, subscription]) {\n      if (!type || !type.fields) {\n        continue\n      }\n\n      for (let field of type.fields) {\n        if (field.name.value in resolvers) {\n          return true\n        }\n      }\n    }\n\n    return false\n  }\n\n  /**\n   * Merging Schematas are a common feature in the modern world of GraphQL.\n   * Especially when there are multiple teams working in tandem. This feature\n   * supports merging of types, extended types, interfaces, enums, unions,\n   * input object types and directives for all of the above.\n   *\n   * @param {SchemaSource} schemaLanguage an instance of Schemata, a string of\n   * SDL, a Source instance of SDL, a GraphQLSchema or ASTNode that can be\n   * printed as an SDL string\n   * @param {ConflictResolvers} conflictResolvers an object containing up to\n   * four methods, each describing how to handle a conflict when an associated\n   * type of conflict occurs. If no object or method are supplied, the right\n   * hande value always takes precedence over the existing value; replacing it\n   * @return {Schemata} a new instance of Schemata\n   */\n  mergeSDL(\n    schemaLanguage: SchemaSource,\n    conflictResolvers: ?ConflictResolvers = DefaultConflictResolvers\n  ): Schemata {\n    let source = normalizeSource(schemaLanguage, true)\n\n    if (!source) {\n      throw new Error(inline`\n        The call to mergeSDL(schemaLanguage, conflictResolvers) received an\n        invalid value for schemaLanguage. Please check your code and try again.\n        Received ${schemaLanguage}.\n      `)\n    }\n\n    let lAST = this.ast\n    let rAST = source.ast\n    let _scalarFns = {}\n\n    // Ensure we have default behavior with any custom behavior assigned\n    // atop the default ones should only a partial custom be supplied.\n    conflictResolvers = merge(DefaultConflictResolvers, conflictResolvers)\n\n    for (let rType of rAST.definitions) {\n      let lType = lAST.definitions.find(a => a.name.value == rType.name.value)\n\n      if (\n        rType.kind &&\n        rType.kind.endsWith &&\n        rType.kind.endsWith('Extension')\n      ) {\n        rType = merge({}, rType)\n        rType.kind =\n          rType.kind.substring(0, rType.kind.length - 9) + 'Definition'\n      }\n\n      if (!lType) {\n        lAST.definitions.push(rType)\n        continue\n      }\n\n      switch (lType.kind) {\n      default:\n      case 'ObjectTypeDefinition':\n      case 'ObjectTypeDefinitionExtension':\n      case 'InterfaceTypeDefinition':\n      case 'InterfaceTypeDefinitionExtension':\n      case 'InputObjectTypeDefinition':\n      case 'InputObjectTypeDefinitionExtension':\n        combineTypeAndSubType('directives', lType, rType, conflictResolvers)\n        combineTypeAndSubType('fields', lType, rType, conflictResolvers)\n        break\n\n      case 'EnumTypeDefinition':\n        combineTypeAndSubType('directives', lType, rType, conflictResolvers)\n        combineTypeAndSubType('values', lType, rType, conflictResolvers)\n        break\n\n      case 'UnionTypeDefinition':\n        combineTypeAndSubType('directives', lType, rType, conflictResolvers)\n        combineTypeAndSubType('types', lType, rType, conflictResolvers)\n        break\n\n      case 'ScalarTypeDefinitionNode':\n        let lScalar, lScalarConfig, rScalar, rScalarConfig, resolver\n\n        combineTypeAndSubType('directives', lType, rType, conflictResolvers)\n\n        if (this.schema) {\n          lScalar = this.schema.getType(lType.name.value)\n          lScalarConfig = (lScalar && lScalar._scalarConfig) || null\n        }\n\n        if (source.schema) {\n          rScalar = source.schema.getType(rType.name.value)\n          rScalarConfig = (rScalar && rScalar._scalarConfig) || null\n        }\n\n        resolver = (conflictResolvers.scalarMergeResolver ||\n            DefaultConflictResolvers.scalarMergeResolver)(\n          lType,\n          lScalarConfig,\n          rType,\n          rScalarConfig\n        )\n\n        if (resolver) {\n          _scalarFns[lType.name.value] = _scalarFns[lType.name.value] || {}\n          _scalarFns[lType.name.value] = resolver\n        }\n\n        break\n      }\n    }\n\n    let merged = Schemata.from(this.constructor.gql.print(lAST))\n\n    if (Object.keys(_scalarFns).length) {\n      for (let typeName of Object.keys(_scalarFns)) {\n        merged.schema.getType(typeName)._scalarConfig = _scalarConfig[typeName]\n      }\n    }\n\n    return merged\n  }\n\n  /**\n   * Paring down Schematas can be handy for certain types of schema stitching.\n   * The SDL passed in and any associated resolvers will be removed from\n   * a copy of the SDL in this Schemata instance represents and the resolver\n   * map passed in.\n   *\n   * @param {SchemaSource} schemaLanguage an instance of Schemata, a string of\n   * SDL, a Source instance of SDL, a GraphQLSchema or ASTNode that can be\n   * printed as an SDL string\n   * @param {ResolverMap} resolverMap an object containing resolver functions,\n   * from either those set on this instance or those in the resolverMap added in\n   * @return {Schemata} a new Schemata instance with the changed values set\n   * on it\n   */\n  pareSDL(\n    schemaLanguage: SchemaSource,\n    resolverMap: ?ResolverMap = null\n  ): Schemata {\n    let source = normalizeSource(schemaLanguage, true)\n    if (!source) {\n      throw new Error(inline`\n        In the call to pareSDL(schemaLanguage), the supplied value for\n        \\`schemaLanguage\\` could not be parsed.\n      `)\n    }\n\n    if (schemaLanguage instanceof GraphQLSchema && !resolverMap) {\n      resolverMap = stripResolversFromSchema(schemaLanguage)\n    }\n\n    let resolvers = merge({}, resolverMap || this.resolvers || {})\n    let lAST = this.ast\n    let rAST = source.ast\n\n    for (let rType of rAST.definitions) {\n      let lType = lAST.definitions.find(a => a.name.value == rType.name.value)\n\n      if (\n        rType.kind &&\n        rType.kind.endsWith &&\n        rType.kind.endsWith('Extension')\n      ) {\n        let len = 'Extension'.length\n\n        rType = merge({}, rType)\n        rType.kind =\n          rType.kind.substring(0, rType.kind.length - len) + 'Definition'\n      }\n\n      if (!lType) {\n        lAST.definitions.push(rType)\n        continue\n      }\n\n      switch (lType.kind) {\n      default:\n      case 'ObjectTypeDefinition':\n      case 'ObjectTypeDefinitionExtension':\n      case 'InterfaceTypeDefinition':\n      case 'InterfaceTypeDefinitionExtension':\n      case 'InputObjectTypeDefinition':\n      case 'InputObjectTypeDefinitionExtension':\n        pareTypeAndSubType('directives', lType, rType, resolvers)\n        pareTypeAndSubType('fields', lType, rType, resolvers)\n\n        if (!lType.fields.length) {\n          let index = lAST.definitions.indexOf(lType)\n\n          if (index !== -1) {\n            lAST.definitions.splice(index, 1)\n          }\n        }\n        break\n\n      case 'EnumTypeDefinition':\n        pareTypeAndSubType('directives', lType, rType, resolvers)\n        pareTypeAndSubType('values', lType, rType, resolvers)\n\n        if (!lType.values.length) {\n          let index = lAST.definitions.indexOf(lType)\n\n          if (index !== -1) {\n            lAST.definitions.splice(index, 1)\n          }\n        }\n        break\n\n      case 'UnionTypeDefinition':\n        pareTypeAndSubType('directives', lType, rType, resolvers)\n        pareTypeAndSubType('types', lType, rType, resolvers)\n\n        if (!lType.types.length) {\n          let index = lAST.definitions.indexOf(lType)\n\n          if (index !== -1) {\n            lAST.definitions.splice(index, 1)\n          }\n        }\n        break\n\n      case 'ScalarTypeDefinitionNode':\n        let index = lAST.definitions.indexOf(lType)\n\n        if (index !== -1) {\n          lAST.definitions.splice(index, 1)\n        }\n        break\n      }\n    }\n\n    let result = Schemata.from(this.constructor.gql.print(lAST), resolvers)\n    result.schema\n\n    return result\n  }\n\n  /**\n   * A new Schemata object instance with merged schema definitions as its\n   * contents as well as merged resolvers and newly bound executable schema are\n   * all created in this step and passed back. The object instance itself is\n   * not modified\n   *\n   * Post merge, the previously stored and merged resolvers map are are applied\n   * and a new executable schema is built from the ashes of the old.\n   *\n   * @param {GraphQLSchema} schema an instance of GraphQLSchema to merge\n   * @param {ConflictResolvers} conflictResolvers an object containing up to\n   * four methods, each describing how to handle a conflict when an associated\n   * type of conflict occurs. If no object or method are supplied, the right\n   * hande value always takes precedence over the existing value; replacing it\n   * @return {Schemata} a new instance of Schemata with a merged schema string,\n   * merged resolver map and newly bound executable schema attached are all\n   * initiated\n   */\n  merge(\n    schema: SchemaSource,\n    config?: MergeOptionsConfig = DefaultMergeOptions\n  ): Schemata {\n    if (!schema) {\n      throw new Error(inline`\n        In the call to mergeSchema(schema), ${schema} was received as a value\n        and the code could not proceed because of it. Please check your code\n        and try again\n      `)\n    }\n\n    // Step0: Ensure we have all the defaults for config and schema\n    schema = normalizeSource(schema, true)\n\n    if (config !== DefaultMergeOptions) {\n      let mergedConfig = merge({}, DefaultMergeOptions)\n      config = merge(mergedConfig, config)\n    }\n\n    // Step1: Merge SDL; quit at this point if there are no resolvers\n    let left = Schemata.from(this, undefined, true)\n    let right = Schemata.from(schema, undefined, true)\n    let merged = left.mergeSDL(right, config.conflictResolvers)\n\n    // If neither schemata instance has a resolver, there is no reason\n    // to continue. Return the merged schemas and call it a day.\n    if (\n      (!left.resolvers || !Object.keys(left.resolvers).length) &&\n      (!right.resolvers || !Object.keys(right.resolvers).length)\n    ) {\n      return merged\n    }\n\n    // Step2: Backup resolvers from left, right, or both\n    let lResolvers = left.resolvers\n    let rResolvers = right.resolvers\n    let prevMaps = (left.prevResolverMaps || []).concat(\n      right.prevResolverMaps || [],\n      ExtendedResolverMap.from(left),\n      ExtendedResolverMap.from(right)\n    )\n    merged.prevResolverMaps = prevMaps\n\n    // Step3: Merge resolvers\n    let mergeResolvers = {}\n\n    if (prevMaps && prevMaps.length) {\n      mergeResolvers = prevMaps.reduce((p, c, i, a) => {\n        return merge(p, c.resolvers || {})\n      }, {})\n    }\n    else {\n      merge(mergeResolvers, left.resolvers)\n      merge(mergeResolvers, right.resolvers)\n    }\n    merged.resolvers = mergeResolvers\n\n    // Step 4: Trigger a new schema creation\n    if (config.createMissingResolvers) {\n      merged.resolvers = merged.buildResolverForEachField()\n    }\n    merged.clearSchema()\n    merged.schema\n\n    // Step5: Wrap resolvers\n    if (config.injectMergedSchema) {\n      merged.forEachField(\n        (\n          type,\n          typeName,\n          typeDirectives,\n          field,\n          fieldName,\n          fieldArgs,\n          fieldDirectives,\n          schema,\n          context\n        ) => {\n          if (field.resolve) {\n            field.resolve = ExtendedResolver.SchemaInjector(\n              field.resolve,\n              merged.schema\n            )\n\n            if (!merged.resolvers[typeName]) {\n              merged.resolvers[typeName] = {}\n            }\n\n            merged.resolvers[typeName][fieldName] = field.resolve\n          }\n        }\n      )\n\n      // Do this once more to ensure we are using the modified resolvers\n      merged.clearSchema()\n      merged.schema\n    }\n\n    // Step6: Return final merged product\n    return merged\n  }\n\n  /**\n   * Shortcut for the merge() function; mergeSDL still exists as an entity of\n   * itself, but merge() will invoke that function as needed to do its job and\n   * if there aren't any resolvers to consider, the functions act identically.\n   *\n   * @see merge\n   *\n   * @param {GraphQLSchema} schema an instance of GraphQLSchema to merge\n   * @param {ConflictResolvers} conflictResolvers an object containing up to\n   * four methods, each describing how to handle a conflict when an associated\n   * type of conflict occurs. If no object or method are supplied, the right\n   * hande value always takes precedence over the existing value; replacing it\n   * @return {Schemata} a new instance of Schemata with a merged schema string,\n   * merged resolver map and newly bound executable schema attached are all\n   * initiated\n   */\n  mergeSchema(\n    schema: GraphQLSchema | Schemata,\n    config?: MergeOptionsConfig = DefaultMergeOptions\n  ): Schemata {\n    return this.merge(schema, config)\n  }\n\n  /**\n   * Given a schema, based on the Schemata this object is based on, walk it and\n   * build up a resolver map. This function will always return a non-null\n   * object. It will be empty if there are either no resolvers to be found\n   * in the schema or if a valid schema cannot be created.\n   *\n   * @param {boolean|ResolverMap} flattenRootResolversOrFirstParam if this\n   * value is boolean, and if this value is true, the resolvers from Query,\n   * Mutation and Subscription types will be flattened to the root of the\n   * object. If the first parametr is an Object, it will be merged in normally\n   * with merge.\n   * @param {Array<ResolverMap>} ...extendWith an unlimited array of objects\n   * that can be used to extend the built resolver map.\n   * @return {ResolverMap} a resolver map; i.e. an object of resolver functions\n   */\n  buildResolvers(\n    flattenRootResolversOrFirstParam: boolean | ResolverMap,\n    ...extendWith: Array<ResolverMap>\n  ): ResolverMap {\n    let schemata = Schemata.from(this.sdl, this.resolvers)\n    let resolvers = merge(\n      {},\n      stripResolversFromSchema(schemata.schema) || schemata.resolvers || {}\n    )\n\n    // Next check to see if we are flattening or simply extending\n    if (typeof flattenRootResolversOrFirstParam === 'boolean') {\n      for (let rootType of ['Query', 'Mutation', 'Subscription']) {\n        if (flattenRootResolversOrFirstParam) {\n          if (resolvers[rootType]) {\n            for (let field of Object.keys(resolvers[rootType])) {\n              resolvers[field] = resolvers[rootType][field]\n              delete resolvers[rootType][field]\n            }\n\n            delete resolvers[rootType]\n          }\n        }\n        else {\n          for (let field of Object.keys(resolvers)) {\n            try {\n              debug_log('[buildResolvers()] finding field in schema')\n              if (schemata.schemaFieldByName(rootType, field)) {\n                resolvers[rootType] = resolvers[rootType] || {}\n                resolvers[rootType][field] = resolvers[field]\n                delete resolvers[field]\n              }\n            }\n            catch (error) {\n              debug_log(inline`\n                [buildResolvers()] Falling back to \\`astFieldByName()\\`\n              `)\n              debug_trace(\n                inline`\n                [buildResolvers()] Falling back to \\`astFieldByName()\\` due to\n              `,\n                error\n              )\n\n              if (schemata.astFieldByName(rootType, field)) {\n                resolvers[rootType] = resolvers[rootType] || {}\n                resolvers[rootType][field] = resolvers[field]\n                delete resolvers[field]\n              }\n            }\n          }\n        }\n      }\n    }\n    else {\n      resolvers = merge(resolvers || {}, flattenRootResolversOrFirstParam || {})\n    }\n\n    // Finally extend with any remaining arguments\n    if (extendWith.length) {\n      for (let item of extendWith) {\n        resolvers = merge(resolvers || {}, item || {})\n      }\n    }\n\n    return resolvers\n  }\n\n  /**\n   * From time to time it makes more sense to wrap every possible resolver\n   * mapping in given schema. Getting a handle to each fields resolver and\n   * or substituting missing ones with GraphQL's defaultFieldResolver can\n   * be a tiresome affair. This method walks the schema for you and returns\n   * any previously defined resolvers alongside defaultFieldResolvers for\n   * each possible field of every type in the schema.\n   *\n   * If a schema cannot be generated from the SDL represented by the instance\n   * of Schemata, then an error is thrown.\n   *\n   * @param {boolean|ResolverMap} flattenRootResolversOrFirstParam if this\n   * value is boolean, and if this value is true, the resolvers from Query,\n   * Mutation and Subscription types will be flattened to the root of the\n   * object. If the first parametr is an ResolverMap, it will be merged in\n   * normally with merge.\n   * @param {Array<ResolverMap>} ...extendWith an unlimited array of objects\n   * that can be used to extend the built resolver map.\n   * @return {ResolverMap} a resolver map; i.e. an object of resolver functions\n   */\n  buildResolverForEachField(\n    flattenRootResolversOrFirstParam: boolean | ResolverMap,\n    ...extendWith: Array<ResolverMap>\n  ): ResolverMap {\n    if (!this.schema) {\n      throw new Error(inline`\n        buildResolverForEachField() cannot be called unless there is enough\n        valid SDL in the instance to construct a schema. Please check your\n        code!\n      `)\n    }\n\n    let interim = Schemata.from(this.sdl, this.resolvers)\n    let r = {}\n\n    interim.forEachField(\n      (\n        type,\n        typeName,\n        typeDirectives,\n        field,\n        fieldName,\n        fieldArgs,\n        fieldDirectives,\n        schema,\n        context\n      ) => {\n        // Ensure the path to the type in question exists before continuing\n        // onward\n        (r[typeName] = r[typeName] || {})[fieldName] =\n          (r[typeName][fieldName] || {})\n\n        r[typeName][fieldName] = field.resolve || defaultFieldResolver\n      }\n    )\n\n    interim.resolvers = r\n\n    return interim.buildResolvers(\n      flattenRootResolversOrFirstParam,\n      ...extendWith\n    )\n  }\n\n  /**\n   * A method to determine if an executable schema is attached to this Schemata\n   * instance. It does so by walking the schema fields via `buildResolvers()`\n   * and reporting whether there is anything inside the results or not.\n   *\n   * @return {boolean} true if there is at least one resolver on at least one\n   * field of a type in this Schemata instance's schema.\n   */\n  get hasAnExecutableSchema(): boolean {\n    return Object.keys(this.buildResolvers()).length > 0\n  }\n\n  /**\n   * If the `.sdl` property is valid SDL/IDL and can generate valid AST nodes\n   * this function will return true. It will return false otherwise.\n   *\n   * @return {boolean} true if the string can be parsed; false otherwise\n   */\n  get validSDL(): boolean {\n    try {\n      this.constructor.gql.parse(this.sdl)\n      debug_log('[get .validSDL] true')\n      return true\n    }\n    catch (e) {\n      debug_log('[get .validSDL] false')\n      debug_trace('[get .validSDL] ', e)\n      return false\n    }\n  }\n\n  /**\n   * If the `.schema` property is valid SDL/IDL and can generate a valid\n   * GraphQLSchema, this function will return true. It will return false\n   * otherwise.\n   *\n   * @return {boolean} true if the string can be parsed into a schema; false\n   * otherwise\n   */\n  get validSchema(): boolean {\n    try {\n      this.schema\n      debug_log('[get .validSchema] true')\n      return true\n    }\n    catch (e) {\n      debug_log('[get .validSchema] false')\n      debug_trace('[get .validSchema] ', e)\n      return false\n    }\n  }\n\n  /**\n   * Returns true if the string underlying this instance represents valid SDL\n   * that can be both converted to AST nodes or a valid GraphQLSchema instance\n   *\n   * @return {boolean} true if it is valid for both `parse()` as well as the\n   * `buildSchema()` function\n   */\n  get valid(): boolean {\n    return this.validSDL && this.validSchema\n  }\n\n  /**\n   * If the internal resolvers object needs to be changed after creation, this\n   * method allows a way to do so. Setting the value to `null` is equivalent\n   * to removing any stored value. Finally the contents are stored in a weak\n   * map so its contents are not guaranteed over a long period of time.\n   *\n   * @param {ResolverMap} resolvers an object containing field resolvers for\n   * this string instance.\n   */\n  set resolvers(resolvers: ?ResolverMap): void {\n    this[MAP].set(wmkResolvers, resolvers)\n    this.clearSchema()\n  }\n\n  /**\n   * Removes the resolver map associated with this Schemata instance\n   */\n  clearResolvers(): void {\n    this.resolvers = null\n  }\n\n  /**\n   * Removes the schema stored with this Schemata instance\n   */\n  clearSchema(): void {\n    this.schema = null\n  }\n\n  /**\n   * Returns the underlying string passed or generated in the constructor when\n   * inspected in the nodeJS REPL.\n   *\n   * @return {string} the SDL/IDL string this class was created on\n   */\n  [Util.inspect.custom](depth, options): string {\n    return this.sdl\n  }\n\n  /**\n   * The same as `inspect()`, `toString()`, and `valueOf()`. This method\n   * returns the underlying string this class instance was created on.\n   *\n   * @return {string} [description]\n   */\n  toString(): string {\n    return this.sdl\n  }\n\n  /**\n   * The same as `inspect()`, `toString()`, and `valueOf()`. This method\n   * returns the underlying string this class instance was created on.\n   *\n   * @return {string} [description]\n   */\n  valueOf(): string {\n    return this.sdl\n  }\n\n  /**\n   * Iterates over the values contained in a Schema's typeMap. If a desired\n   * value is encountered, the supplied callback will be invoked. The values are\n   * the constants ALL, TYPES, INTERFACES, ENUMS, UNIONS and SCALARS. Optionally\n   * HIDDEN is another value that can be bitmasked together for a varied result.\n   * HIDDEN exposes the values in the schema typemap that begin with a double\n   * underscore.\n   *\n   * The signature for the function callback is as follows:\n   * (\n   *   type: mixed,\n   *   typeName: string,\n   *   typeDirectives: Array<GraphQLDirective>\n   *   schema: GraphQLSchema,\n   *   context: mixed,\n   * ) => void\n   *\n   * Where:\n   *   `type`           - the object instance from within the `GraphQLSchema`\n   *   `typeName`       - the name of the object; \"Query\" for type Query and\n   *                      so on.\n   *   `typeDirectives` - an array of directives applied to the object or an\n   *                      empty array if there are none applied.\n   *   `schema`         - an instance of `GraphQLSchema` over which to iterate\n   *   `context`        - usually an object, and usually the same object,\n   *                      passed to the call to `makeExecutableSchema()`\n   *                      or `graphql()`\n   *\n   * @param {Function} fn a function with a signature defined above\n   * @param {mixed} context usually an object but any mixed value the denotes\n   * some shared context as is used with the schema during normal runtime.\n   * @param {Number} types a bitmask of one or more of the constants defined\n   * above. These can be OR'ed together and default to TYPES.\n   * @param {GraphQLSchema} suppliedSchema an optional schema to use rather\n   * than the one created or stored internally generated from this SDL\n   * @return {GraphQLSchema} a new schema is generated from this SDL, iterated\n   * over and returned.\n   */\n  forEachOf(\n    fn: ForEachOfResolver,\n    context: mixed,\n    types: number = TYPES,\n    suppliedSchema: ?GraphQLSchema = null\n  ): GraphQLSchema {\n    let schema = suppliedSchema || this.schema\n\n    forEachOf(schema, fn, context, types)\n\n    return schema\n  }\n\n  /**\n   * Shortcut to `forEachOf()` specific to types.\n   *\n   * @see #forEachOf\n   *\n   * @param {Function} fn a function with a signature defined above\n   * @param {mixed} context usually an object but any mixed value the denotes\n   * some shared context as is used with the schema during normal runtime.\n   * @param {GraphQLSchema} suppliedSchema an optional schema to use rather\n   * than the one created or stored internally generated from this Schemata\n   * @return {GraphQLSchema} a new schema is generated from this Schemata,\n   * iterated over and returned.\n   */\n  forEachType(\n    fn: ForEachOfResolver,\n    context: mixed,\n    suppliedSchema: ?GraphQLSchema\n  ): GraphQLSchema {\n    return this.forEachOf(fn, context, TYPES, suppliedSchema)\n  }\n\n  /**\n   * Shortcut to `forEachOf()` specific to input object types.\n   *\n   * @see #forEachOf\n   *\n   * @param {Function} fn a function with a signature defined above\n   * @param {mixed} context usually an object but any mixed value the denotes\n   * some shared context as is used with the schema during normal runtime.\n   * @param {GraphQLSchema} suppliedSchema an optional schema to use rather\n   * than the one created or stored internally generated from this Schemata\n   * @return {GraphQLSchema} a new schema is generated from this Schemata,\n   * iterated\n   * over and returned.\n   */\n  forEachInputObjectType(\n    fn: ForEachOfResolver,\n    context: mixed,\n    suppliedSchema: ?GraphQLSchema\n  ): GraphQLSchema {\n    return this.forEachOf(fn, context, INPUT_TYPES, suppliedSchema)\n  }\n\n  /**\n   * Shortcut to `forEachOf()` specific to unions.\n   *\n   * @see #forEachOf\n   *\n   * @param {Function} fn a function with a signature defined above\n   * @param {mixed} context usually an object but any mixed value the denotes\n   * some shared context as is used with the schema during normal runtime.\n   * @param {GraphQLSchema} suppliedSchema an optional schema to use rather\n   * than the one created or stored internally generated from this SDL\n   * @return {GraphQLSchema} a new schema is generated from this SDL, iterated\n   * over and returned.\n   */\n  forEachUnion(\n    fn: ForEachOfResolver,\n    context: mixed,\n    suppliedSchema: ?GraphQLSchema\n  ): GraphQLSchema {\n    return this.forEachOf(fn, context, UNIONS, suppliedSchema)\n  }\n\n  /**\n   * Shortcut to `forEachOf()` specific to enums.\n   *\n   * @see #forEachOf\n   *\n   * @param {Function} fn a function with a signature defined above\n   * @param {mixed} context usually an object but any mixed value the denotes\n   * some shared context as is used with the schema during normal runtime.\n   * @param {GraphQLSchema} suppliedSchema an optional schema to use rather\n   * than the one created or stored internally generated from this SDL\n   * @return {GraphQLSchema} a new schema is generated from this SDL, iterated\n   * over and returned.\n   */\n  forEachEnum(\n    fn: ForEachOfResolver,\n    context: mixed,\n    suppliedSchema: ?GraphQLSchema\n  ): GraphQLSchema {\n    return this.forEachOf(fn, context, ENUMS, suppliedSchema)\n  }\n\n  /**\n   * Shortcut to `forEachOf()` specific to interfaces.\n   *\n   * @see #forEachOf\n   *\n   * @param {Function} fn a function with a signature defined above\n   * @param {mixed} context usually an object but any mixed value the denotes\n   * some shared context as is used with the schema during normal runtime.\n   * @param {GraphQLSchema} suppliedSchema an optional schema to use rather\n   * than the one created or stored internally generated from this SDL\n   * @return {GraphQLSchema} a new schema is generated from this SDL, iterated\n   * over and returned.\n   */\n  forEachInterface(\n    fn: ForEachOfResolver,\n    context: mixed,\n    suppliedSchema: ?GraphQLSchema\n  ): GraphQLSchema {\n    return this.forEachOf(fn, context, INTERFACES, suppliedSchema)\n  }\n\n  /**\n   * Shortcut to `forEachOf()` specific to types.\n   *\n   * @see #forEachOf\n   *\n   * @param {Function} fn a function with a signature defined above\n   * @param {mixed} context usually an object but any mixed value the denotes\n   * some shared context as is used with the schema during normal runtime.\n   * @param {GraphQLSchema} suppliedSchema an optional schema to use rather\n   * than the one created or stored internally generated from this SDL\n   * @return {GraphQLSchema} a new schema is generated from this SDL,\n   * iterated over and returned.\n   */\n  forEachScalar(\n    fn: ForEachOfResolver,\n    context: mixed,\n    suppliedSchema: ?GraphQLSchema\n  ): GraphQLSchema {\n    return this.forEachOf(fn, context, SCALARS, suppliedSchema)\n  }\n\n  /**\n   * Shortcut to `forEachOf()` specific to all root types; Query, Mutation and\n   * Subscription that exist within the schema.\n   *\n   * @see #forEachOf\n   *\n   * @param {Function} fn a function with a signature defined above\n   * @param {mixed} context usually an object but any mixed value the denotes\n   * some shared context as is used with the schema during normal runtime.\n   * @param {GraphQLSchema} suppliedSchema an optional schema to use rather\n   * than the one created or stored internally generated from this SDL\n   * @return {GraphQLSchema} a new schema is generated from this SDL, iterated\n   * over and returned.\n   */\n  forEachRootType(\n    fn: ForEachOfResolver,\n    context: mixed,\n    suppliedSchema: ?GraphQLSchema\n  ): GraphQLSchema {\n    return this.forEachOf(fn, context, ROOT_TYPES, suppliedSchema)\n  }\n\n  /**\n   * An extension of `forEachOf` that targets the fields of the types in the\n   * schema's typeMap. This function provides more detail and allows greater\n   * access to any associated `context` than the function of the same name\n   * provided by the `graphql-tools` library.\n   *\n   * The signature for the callback function is as follows\n   *\n   * (\n   *   type: mixed,\n   *   typeName: string,\n   *   typeDirectives: Array<GraphQLDirective>,\n   *   field: mixed,\n   *   fieldName: string,\n   *   fieldArgs: Array<GraphQLArgument>,\n   *   fieldDirectives: Array<GraphQLDirective>,\n   *   schema: GraphQLSchema,\n   *   context: mixed\n   * ) => void\n   *\n   * Where\n   *\n   * Where:\n   *   `type`           - the object instance from within the `GraphQLSchema`\n   *   `typeName`       - the name of the object; \"Query\" for type Query and\n   *                      so on\n   *   `typeDirectives` - an array of directives applied to the object or an\n   *                      empty array if there are none applied.\n   *   `field`          - the field in question from the type\n   *   `fieldName`      - the name of the field as a string\n   *   `fieldArgs`      - an array of arguments for the field in question\n   *   `fieldDirectives`- an array of directives applied to the field or an\n   *                      empty array should there be no applied directives\n   *   `schema`         - an instance of `GraphQLSchema` over which to iterate\n   *   `context`        - usually an object, and usually the same object, passed\n   *                      to the call to `makeExecutableSchema()` or `graphql()`\n   *\n   * @param {Function} fn a function with a signature defined above\n   * @param {mixed} context usually an object but any mixed value the denotes\n   * some shared context as is used with the schema during normal runtime.\n   * @param {GraphQLSchema} suppliedSchema an optional schema to use rather\n   * than the one created or stored internally generated from this SDL\n   * @return {GraphQLSchema} a new schema is generated from this SDL, iterated\n   * over and returned.\n   */\n  forEachField(\n    fn: ForEachFieldResolver,\n    context: mixed,\n    types: number = ALL,\n    suppliedSchema: ?GraphQLSchema = null\n  ): GraphQLSchema {\n    let schema = suppliedSchema || this.schema\n\n    forEachField(schema, fn, context, types)\n\n    return schema\n  }\n\n  /**\n   * `forEachField()` shortcut focusing on GraphQLObjectTypes specifically.\n   *\n   * @param {ForEachFieldResolver} fn a callback function that is invoked for\n   * each field of any GraphQLObjectType found\n   * @param {mixed} context usually an object but any mixed value the denotes\n   * some shared context as is used with the schema during normal runtime.\n   * @param {GraphQLSchema} suppliedSchema an optional schema to use rather\n   * than the one created or stored internally generated from this SDL\n   * @return {GraphQLSchema} either the supplied GraphQLSchema or one generated\n   * to facilitate the task\n   */\n  forEachTypeField(\n    fn: ForEachFieldResolver,\n    context: mixed,\n    suppliedSchema: ?GraphQLSchema = null\n  ): GraphQLSchema {\n    let schema = suppliedSchema || this.schema\n\n    forEachField(schema, fn, context, TYPES)\n\n    return schema\n  }\n\n  /**\n   * `forEachField()` shortcut focusing on GraphQLInterfaceType specifically.\n   *\n   * @param {ForEachFieldResolver} fn a callback function that is invoked for\n   * each field of any GraphQLObjectType found\n   * @param {mixed} context usually an object but any mixed value the denotes\n   * some shared context as is used with the schema during normal runtime.\n   * @param {GraphQLSchema} suppliedSchema an optional schema to use rather\n   * than the one created or stored internally generated from this SDL\n   * @return {GraphQLSchema} either the supplied GraphQLSchema or one generated\n   * to facilitate the task\n   */\n  forEachInterfaceField(\n    fn: ForEachFieldResolver,\n    context: mixed,\n    suppliedSchema: ?GraphQLSchema = null\n  ): GraphQLSchema {\n    let schema = suppliedSchema || this.schema\n\n    forEachField(schema, fn, context, INTERFACES)\n\n    return schema\n  }\n\n  /**\n   * `forEachField()` shortcut focusing on GraphQLInputObjectType specifically.\n   *\n   * @param {ForEachFieldResolver} fn a callback function that is invoked for\n   * each field of any GraphQLObjectType found\n   * @param {mixed} context usually an object but any mixed value the denotes\n   * some shared context as is used with the schema during normal runtime.\n   * @param {GraphQLSchema} suppliedSchema an optional schema to use rather\n   * than the one created or stored internally generated from this SDL\n   * @return {GraphQLSchema} either the supplied GraphQLSchema or one generated\n   * to facilitate the task\n   */\n  forEachInputObjectField(\n    fn: ForEachFieldResolver,\n    context: mixed,\n    suppliedSchema: ?GraphQLSchema = null\n  ): GraphQLSchema {\n    let schema = suppliedSchema || this.schema\n\n    forEachField(schema, fn, context, INPUT_TYPES)\n\n    return schema\n  }\n\n  /**\n   * Wrapper for `require('graphql').graphqlSync()` that automatically passes\n   * in the internal `.schema` reference as the first parameter.\n   *\n   * @param {string|Source} query A GraphQL language formatted string\n   * representing the requested operation.\n   * @param {mixed} contextValue a bit of shared context to pass to resolvers\n   * @param {Object} variableValues A mapping of variable name to runtime value\n   * to use for all variables defined in the requestString.\n   * @param {ResolverMap|null} rootValue provided as the first argument to\n   * resolver functions on the top level type (e.g. the query object type).\n   * @param {string} operationName The name of the operation to use if\n   * requestString contains multiple possible operations. Can be omitted if\n   * requestString contains only one operation.\n   * @param {GraphQLFieldResolver<any, any>} fieldResolver A resolver function\n   * to use when one is not provided by the schema. If not provided, the\n   * default field resolver is used (which looks for a value or method on the\n   * source value with the field's name).\n   * @return {ExecutionResult} the requested results. An error is thrown if\n   * the results could not be fulfilled or invalid input/output was specified.\n   */\n  run(\n    query: string | Source,\n    contextValue?: mixed,\n    variableValues?: ?ObjMap<mixed>,\n    rootValue?: mixed,\n    operationName?: ?string,\n    fieldResolver?: ?GraphQLFieldResolver<any, any>\n  ): ExecutionResult {\n    return this.constructor.gql.graphqlSync(\n      this.schema,\n      query,\n      this.resolvers || rootValue,\n      contextValue,\n      variableValues,\n      operationName,\n      fieldResolver\n    )\n  }\n\n  /**\n   * Wrapper for `require('graphql').graphql()` that automatically passes\n   * in the internal `.schema` reference as the first parameter.\n   *\n   * @param {string|Source} query A GraphQL language formatted string\n   * representing the requested operation.\n   * @param {mixed} contextValue a bit of shared context to pass to resolvers\n   * @param {Object} variableValues A mapping of variable name to runtime value\n   * to use for all variables defined in the requestString.\n   * @param {ResolverMap|null} The value provided as the first argument to\n   * resolver functions on the top level type (e.g. the query object type).\n   * @param {string} operationName The name of the operation to use if\n   * requestString contains multiple possible operations. Can be omitted if\n   * requestString contains only one operation.\n   * @param {GraphQLFieldResolver<any, any>} fieldResolver A resolver function\n   * to use when one is not provided by the schema. If not provided, the\n   * default field resolver is used (which looks for a value or method on the\n   * source value with the field's name).\n   * @return {Promise<ExecutionResult>} a Promise contianing the requested\n   * results\n   */\n  async runAsync(\n    query: string | Source,\n    contextValue?: mixed,\n    variableValues?: ?ObjMap<mixed>,\n    rootValue?: mixed,\n    operationName?: ?string,\n    fieldResolver?: ?GraphQLFieldResolver<any, any>\n  ): Promise<ExecutionResult> {\n    return this.constructor.gql.graphql(\n      this.schema,\n      query,\n      this.resolvers || rootValue,\n      contextValue,\n      variableValues,\n      operationName,\n      fieldResolver\n    )\n  }\n\n  /**\n   * A little wrapper used to catch any errors thrown when building a schema\n   * from the string SDL representation of a given instance.\n   *\n   * @param {SchemaSource} sdl an instance of Schemata, a string of SDL, a\n   * Source instance of SDL, a GraphQLSchema or ASTNode that can be printed as\n   * an SDL string\n   * @param {boolean} showError true if the error should be thrown, false if\n   * the error should be silently suppressed\n   * @param {BuildSchemaOptions&ParseOptions} schemaOpts for advanced users,\n   * passing through additional buildSchema() options can be done here\n   * @return {GraphQLSchema|null} null if an error occurs and errors are not\n   * surfaced or a valid GraphQLSchema object otherwise\n   */\n  static buildSchema(\n    sdl: SchemaSource,\n    showError: boolean = false,\n    schemaOpts: BuildSchemaOptions & ParseOptions = undefined\n  ): ?GraphQLSchema {\n    try {\n      debug_log('[static buildSchema()] normalizing source')\n      let source = normalizeSource(sdl)\n\n      debug_log('[static buildSchema()] building schema')\n      return this.gql.buildSchema(source, schemaOpts)\n    }\n    catch (e) {\n      debug_log('[static buildSchema()] failed to build!')\n      debug_trace('[static buildSchema()] ', e)\n      if (showError) {\n        throw e\n      }\n      return null\n    }\n  }\n\n  /**\n   * A little wrapper used to catch any errors thrown when parsing Schemata for\n   * ASTNodes. If showError is true, any caught errors are thrown once again.\n   *\n   * @param {SchemaSource} sdl an instance of Schemata, a string of SDL, a\n   * Source instance of SDL, a GraphQLSchema or ASTNode that can be printed as\n   * an SDL string\n   * @param {boolean} showError if true, any caught errors will be thrown once\n   * again\n   * @param {boolean} enhance a generator keyed with `Symbol.iterator` is set\n   * on the resulting astNode object allowing the resulting `.ast` value to\n   * be iterable. The code iterates over each definition of the resulting\n   * DocumentNode. This behavior defaults to true and should not have any ill\n   * effects on code expecting vanilla ASTNode objects\n   * @return {ASTNode|null} null if an error occurs and errors are suppressed,\n   * a top level Document ASTNode otherwise\n   */\n  static parse(\n    sdl: SchemaSource,\n    showError: boolean = false,\n    enhance: boolean = true\n  ): ?ASTNode {\n    try {\n      debug_log('[static parse()] normalizing source')\n      let source = normalizeSource(sdl)\n\n      debug_log('[static parse()] parsing')\n      let node = this.gql.parse(source)\n\n      if (enhance) {\n        debug_log('[static parse()] enhancing')\n        node[Symbol.iterator] = function*() {\n          for (let node of this.definitions) {\n            yield node\n          }\n        }\n      }\n\n      return node\n    }\n    catch (e) {\n      debug_log('[static parse()] failed to parse')\n      debug_trace('[static parse()] ', e)\n      if (showError) {\n        throw e\n      }\n      return null\n    }\n  }\n\n  /**\n   * A little wrapper used to catch any errors thrown when printing an ASTNode\n   * to string form using `require('graphql').print()`. If `showError` is true\n   * any thrown errors will be rethrown, otherwise null is returned instead.\n   *\n   * Should all go as planned, an instance of Schemata wrapped with the printed\n   * SDL will be returned.\n   *\n   * @since 1.7\n   *\n   * @param {ASTNode|GraphQLSchema} ast an ASTNode, usually a\n   * DocumentNode generated with some version of `require('graphql').parse()`.\n   * If an instance of GraphQLSchema is supplied, `printSchema()` is used\n   * instead of `print()`\n   * @param {boolean} showError if true, any caught errors will be thrown once\n   * again\n   * @return {Schemata|null} null if an error occurs (and showError is false)\n   * or an instance of Schemata wrapping the resulting SDL string from the\n   * print operation\n   */\n  static print(\n    ast: ASTNode | GraphQLSchema,\n    showError: boolean = false\n  ): ?Schemata {\n    try {\n      let source\n\n      if (ast instanceof GraphQLSchema) {\n        debug_log('[static print()] printing schema')\n        source = this.gql.printSchema(ast)\n      }\n      else {\n        debug_log('[static print()] printing ASTNode')\n        source = this.gql.print(ast)\n      }\n\n      debug_log('[static print()] creating new Schemata from print')\n      return Schemata.from(source)\n    }\n    catch (e) {\n      debug_log('[static print()] failed to print')\n      debug_trace('[static print()] ', e)\n      if (showError) {\n        throw e\n      }\n      return null\n    }\n  }\n\n  /**\n   * A simple pass thru used within the class to reference graphql methods\n   * and classes.\n   *\n   * @return {mixed} the results of `require('graphql')`\n   */\n  static get gql(): mixed {\n    return require('graphql')\n  }\n\n  /**\n   * Shorthand way of invoking `new Schemata()`\n   *\n   * @param {SchemaSource} typeDefs an instance of Schemata, a string of SDL,\n   * a Source instance of SDL, a GraphQLSchema or ASTNode that can be printed\n   * as an SDL string\n   * @param {ResolverMap} resolvers an object containing field resolvers for\n   * for the schema represented with this string. [Optional]\n   * @param {boolean} buildResolvers if this flag is set to true, build a set\n   * of resolvers after the rest of the instance is initialized and set the\n   * results on the `.resolvers` property of the newly created instance. If\n   * buildResolvers is the string \"all\", then a resolver for each field not\n   * defined will be returned with a `defaultFieldResolver` as its value\n   * @param {boolean} flattenResolvers if true, and if `buildResolvers` is true,\n   * then make an attempt to flatten the root types to the base of the\n   * resolver map object.\n   * @return {Schemata} an instance of Schemata\n   */\n  static from(\n    typeDefs: SchemaSource,\n    resolvers: ?ResolverMap = null,\n    buildResolvers: boolean | string = false,\n    flattenResolvers: boolean = false\n  ): Schemata {\n    return new this(typeDefs, resolvers, buildResolvers, flattenResolvers)\n  }\n\n  /**\n   * Constant used with `forEachOf()` that signifies you wish to iterate\n   * over every available type within the schema.\n   *\n   * @type {number}\n   */\n  static get ALL(): number {\n    return ALL\n  }\n\n  /**\n   * Constant used with `forEachOf()` that signifies you wish to iterate\n   * over every available type within the schema.\n   *\n   * @type {number}\n   */\n  static get TYPES(): number {\n    return TYPES\n  }\n\n  /**\n   * Constant used with `forEachOf()` that signifies you wish to iterate\n   * over every available interface within the schema.\n   *\n   * @type {number}\n   */\n  static get INTERFACES(): number {\n    return INTERFACES\n  }\n\n  /**\n   * Constant used with `forEachOf()` that signifies you wish to iterate\n   * over every available enum within the schema.\n   *\n   * @type {number}\n   */\n  static get ENUMS(): number {\n    return ENUMS\n  }\n\n  /**\n   * Constant used with `forEachOf()` that signifies you wish to iterate\n   * over every available union within the schema.\n   *\n   * @type {number}\n   */\n  static get UNIONS(): number {\n    return UNIONS\n  }\n\n  /**\n   * Constant used with `forEachOf()` that signifies you wish to iterate\n   * over every available scalar within the schema.\n   *\n   * @type {number}\n   */\n  static get SCALARS(): number {\n    return SCALARS\n  }\n\n  /**\n   * Constant used with `forEachOf()` that signifies you wish to iterate\n   * over every available root type; Query, Mutation and Subscription\n   *\n   * @type {number}\n   */\n  static get ROOT_TYPES(): number {\n    return ROOT_TYPES\n  }\n\n  /**\n   * Constant used with `forEachOf()` that signifies you wish to iterate\n   * over every available GraphQLInputObjectType within the schema.\n   *\n   * @type {number}\n   */\n  static get INPUT_TYPES(): number {\n    return INPUT_TYPES\n  }\n\n  /**\n   * Constant used with `forEachOf()` that signifies you also wish to\n   * iterate over the meta types. These are denoted by a leading double\n   * underscore.\n   *\n   * Can be OR'ed together such as `Schemata.TYPES | Schemata.HIDDEN`\n   *\n   * @type {number}\n   */\n  static get HIDDEN(): number {\n    return HIDDEN\n  }\n}\n\n/**\n * Given an type, determine if the type is a root type; i.e. one of Query,\n * Mutation or Subscription as defined in the `graphql` library.\n *\n * @param  {mixed} t a GraphQL AST or object type denoting a schema type\n * @return {Boolean} true if the type supplied is a root type; false otherwise\n */\nexport const isRootType = t => {\n  if (t === undefined || t === null || !t) {\n    return false\n  }\n\n  let name = typeof t.name === 'string' ? t.name : t.name.value\n\n  return (\n    t instanceof GraphQLObjectType &&\n    (t.name === 'Query' || t.name === 'Mutation' || t.name === 'Subscription')\n  )\n}\n\n/**\n * Loops over the `resolverInjectors` in the supplied config object and\n * lets each supplied function have a pass to inspect or modify the parameters\n * that will be used to bind future resolver functions.\n *\n * @param {MergeOptionsConfig} config a config object with an array of\n * `ResolverArgsTransformer` functions\n * @param {ResolverArgs} args an object with `source`, `args`, `context`\n * and `info`\n * @return {ResolverArgs} a resulting object with `source`, `args`,\n * `context` and `info`\n */\nexport function runInjectors(\n  config: MergeOptionsConfig,\n  resolverArgs: ResolverArgs\n): ResolverArgs {\n  let args: ResolverArgs\n\n  if (!Array.isArray(config.resolverInjectors)) {\n    config.resolverInjectors = [config.resolverInjectors]\n  }\n\n  for (let injector of config.resolverInjectors) {\n    args = injector(resolverArgs)\n  }\n\n  return args\n}\n\n/**\n * The merge options config takes the arguments passed into a given `resolve()`\n * function, allowing the implementor to modify the values before passing them\n * back out.\n *\n * This function takes a schema to inject into the info object, or fourth\n * parameter, passed to any resolver. Any `extraConfig` object added in will\n * have its resolverInjectors added to the list to be processed.\n *\n * @param {GraphQLSchema} schema the GraphQLSchema object being inserted\n * @param {MergeOptionsConfig} extraConfig an optional extraConfig option to\n * merge with the resulting output\n * @return {MergeOptionsConfig} a MergeOptionsConfig object that contains at\n * least a single `ResolverArgsTransformer` which injects the supplied `schema`\n * into the `info` object.\n */\nexport function SchemaInjectorConfig(\n  schema: GraphQLSchema,\n  extraConfig?: MergeOptionsConfig\n): MergeOptionsConfig {\n  let baseConfig = {\n    resolverInjectors: [\n      function __schema_injector__({ source, args, context, info }) {\n        info.schema = schema || info.schema\n        return { source, args, context, info }\n      },\n    ],\n  }\n\n  if (extraConfig) {\n    if (extraConfig.resolverInjectors) {\n      if (!Array.isArray(extraConfig.resolverInjectors)) {\n        baseConfig.resolverInjectors.push(extraConfig.resolverInjectors)\n      }\n      else {\n        baseConfig.resolverInjectors = baseConfig.resolverInjectors.concat(\n          extraConfig.resolverInjectors\n        )\n      }\n    }\n  }\n\n  return baseConfig\n}\n\n/**\n * Walk the supplied GraphQLSchema instance and retrieve the resolvers stored\n * on it. These values are then returned with a [typeName][fieldName] pathing\n *\n * @param {GraphQLSchema} schema an instance of GraphQLSchema\n * @return {ResolverMap} an object containing a mapping of typeName.fieldName\n * that links to the resolve() function it is associated within the supplied\n * schema\n */\nexport function stripResolversFromSchema(schema: GraphQLSchema): ?ResolverMap {\n  let resolvers = {}\n\n  if (!schema) {\n    return null\n  }\n\n  forEachField(\n    schema,\n    (\n      type,\n      typeName,\n      typeDirectives,\n      field,\n      fieldName,\n      fieldArgs,\n      fieldDirectives,\n      _schema,\n      context\n    ) => {\n      if (field.resolve) {\n        resolvers[typeName] = resolvers[typeName] || {}\n        resolvers[typeName][fieldName] = resolvers[typeName][fieldName] || {}\n        resolvers[typeName][fieldName] = field.resolve\n      }\n    }\n  )\n\n  return resolvers\n}\n\n/** @type {Symbol} a unique symbol used as a key to all instance sdl strings */\nexport const TYPEDEFS_KEY = Symbol('internal-typedefs-key')\n\n/** @type {Symbol} a constant symbol used as a key to a flag for express-gql */\nexport const GRAPHIQL_FLAG = Symbol.for('internal-graphiql-key')\n\n/** @type {Symbol} a unique symbol used as a key to all instance `WeakMap`s */\nexport const MAP = Symbol('internal-weak-map-key')\n\n/** @type {Symbol} a key used to store the __executable__ flag on a schema */\nexport const EXE = Symbol('executable-schema')\n\n/** @type {Object} a key used to store a resolver object in a WeakMap */\nconst wmkResolvers = Object(Symbol('GraphQL Resolvers storage key'))\n\n/** @type {Object} a key used to store an internal schema in a WeakMap */\nconst wmkSchema = Object(Symbol('GraphQLSchema storage key'))\n\n/**\n * This is a `Symbol` key to a `WeakSet` of `ExtendedResolverMap` instances,\n * each of which have at least three properties:\n *\n *  - schema\n *  - sdl\n *  - resolvers\n *\n * One of these are created and added to the set whenever a mergeSchema is\n * performed. On each subsequent mergeSDL/Schema a new instance is added such\n * that new versions exist to be wrapped anew\n *\n * @type {[type]}\n */\nconst wmkPreboundResolvers = Object(Symbol('Resolvers pre-merge-wrapped'))\n\n/**\n * The default field resolver blindly takes returns the right field. This\n * resolver is used when one is not specified.\n *\n * @param {ASTNode} leftType The matching left type indicating conflict\n * @param {FieldNode} leftField The field causing the conflict\n * @param {ASTNode} rightType The matching right type indicating conflict\n * @param {FieldNode} rightField the field cause the conflict\n *\n * @return {FieldNode} the field that should be used after resolution\n */\nexport function DefaultFieldMergeResolver(\n  leftType: ASTNode,\n  leftField: FieldNode,\n  rightType: ASTNode,\n  rightField: FieldNode\n): FieldNode {\n  return rightField\n}\n\n/**\n * The default directive resolver blindly takes returns the right field. This\n * resolver is used when one is not specified.\n *\n * @param {ASTNode} leftType The matching left type indicating conflict\n * @param {DirectiveNode} leftDirective The field causing the conflict\n * @param {ASTNode} rightType The matching right type indicating conflict\n * @param {DirectiveNode} rightDirective the field cause the conflict\n *\n * @return {DirectiveNode} the directive that should be used after resolution\n */\nexport function DefaultDirectiveMergeResolver(\n  leftType: ASTNode,\n  leftDirective: DirectiveNode,\n  rightType: ASTNode,\n  rightDirective: DirectiveNode\n): DirectiveNode {\n  return rightDirective\n}\n\n/**\n * The default field resolver blindly takes returns the right field. This\n * resolver is used when one is not specified.\n *\n * @param {ASTNode} leftType The matching left type indicating conflict\n * @param {DirectiveNode} leftDirective The field causing the conflict\n * @param {ASTNode} rightType The matching right type indicating conflict\n * @param {DirectiveNode} rightDirective the field cause the conflict\n *\n * @return {DirectiveNode} the directive that should be used after resolution\n */\nexport function DefaultEnumMergeResolver(\n  leftType: ASTNode,\n  leftValue: EnumValueNode,\n  rightType: ASTNode,\n  rightValue: EnumValueNode\n): EnumValueNode {\n  return rightValue\n}\n\n/**\n * The default union resolver blindly takes returns the right type. This\n * resolver is used when one is not specified.\n *\n * @param {ASTNode} leftType The matching left type indicating conflict\n * @param {NamedTypeNode} leftUnion The named node causing the conflict\n * @param {ASTNode} rightType The matching right type indicating conflict\n * @param {NamedTypeNode} rightUnion the named node cause the conflict\n *\n * @return {NamedTypeNode} the directive that should be used after resolution\n */\nexport function DefaultUnionMergeResolver(\n  leftType: ASTNode,\n  leftUnion: NamedTypeNode,\n  rightType: ASTNode,\n  rightUnion: NamedTypeNode\n): NamedTypeNode {\n  return rightUnion\n}\n\n/**\n * The default scalar merge resolver returns the right config when there is\n * one, otherwise the left one or null will be the default result. This is\n * slightly different behavior since resolvers for scalars are not always\n * available.\n *\n * @param {GraphQLScalarTypeConfig} leftConfig *if* there is a resolver defined\n * for the existing ScalarTypeDefinitionNode it will be provided here. If this\n * value is null, there is no availabe config with serialize(), parseValue() or\n * parseLiteral() to work with.\n * @param {ScalarTypeDefinitionNode} rightScalar the definition node found when\n * parsing ASTNodes. This is to be merged value that conflicts with the\n * existing value\n * @param {GraphQLScalarTypeConfig} rightConfig *if* there is a resolver\n * defined for the existing ScalarTypeDefinitionNode it will be provided here.\n * If this value is null, there is no availabe config with serialize(),\n * parseValue() or parseLiteral() to work with.\n * @return {GraphQLScalarTypeConfig} whichever type config or resolver was\n * desired should be returned here.\n *\n * @see https://www.apollographql.com/docs/graphql-tools/scalars.html\n * @see http://graphql.org/graphql-js/type/#graphqlscalartype\n */\nexport function DefaultScalarMergeResolver(\n  leftScalar: ScalarTypeDefinitionNode,\n  leftConfig: GraphQLScalarTypeConfig,\n  rightScalar: ScalarTypeDefinitionNode,\n  rightConfig: GraphQLScalarTypeConfig\n): GraphQLScalarTypeConfig {\n  return rightConfig ? rightConfig : leftConfig || null\n}\n\n/**\n * In order to facilitate merging, there needs to be some contingency plan\n * for what to do when conflicts arise. This object specifies one of each\n * type of resolver. Each simply takes the right-hand value.\n *\n * @type {Object}\n */\nexport const DefaultConflictResolvers: ConflictResolvers = {\n  /** A handler for resolving fields in matching types */\n  fieldMergeResolver: DefaultFieldMergeResolver,\n\n  /** A handler for resolving directives in matching types */\n  directiveMergeResolver: DefaultDirectiveMergeResolver,\n\n  /** A handler for resolving conflicting enum values */\n  enumValueMergeResolver: DefaultEnumMergeResolver,\n\n  /** A handler for resolving type values in unions */\n  typeValueMergeResolver: DefaultUnionMergeResolver,\n\n  /** A handler for resolving scalar configs in custom scalars */\n  scalarMergeResolver: DefaultScalarMergeResolver,\n}\n\n/**\n * A `MergeOptionsConfig` object with an empty array of\n * `ResolverArgsTransformer` instances\n *\n * @type {MergeOptionsConfig}\n */\nexport const DefaultMergeOptions: MergeOptionsConfig = {\n  conflictResolvers: DefaultConflictResolvers,\n  resolverInjectors: [],\n  injectMergedSchema: true,\n  createMissingResolvers: false,\n}\n\nconst subTypeResolverMap: Map<string, Function> = new Map()\nsubTypeResolverMap.set('fields', 'fieldMergeResolver')\nsubTypeResolverMap.set('directives', 'directiveMergeResolver')\nsubTypeResolverMap.set('values', 'enumValueMergeResolver')\nsubTypeResolverMap.set('types', 'typeValueMergeResolver')\nsubTypeResolverMap.set('scalars', 'scalarMergeResolver')\n\n/**\n * Compares and combines a subset of ASTNode fields. Designed to work on all\n * the various types that might have a merge conflict.\n *\n * @param {string} subTypeName the name of the field type; one of the following\n * values: 'fields', 'directives', 'values', 'types'\n * @param {ASTNode} lType the lefthand type containing the subtype to compare\n * @param {ASTNode} lSubType the lefthand subtype; fields, directive, value or\n * named union type\n * @param {ASTNode} rType the righthand type containing the subtype to compare\n * @param {ASTNode} rSubType the righthand subtype; fields, directive, value or\n * named union type\n */\nfunction combineTypeAndSubType(\n  subTypeName: string,\n  lType: ASTNode,\n  rType: ASTNode,\n  conflictResolvers: ConflictResolvers = DefaultConflictResolvers\n): void {\n  if (rType[subTypeName]) {\n    for (let rSubType of rType[subTypeName]) {\n      let lSubType = lType[subTypeName].find(\n        f => f.name.value == rSubType.name.value\n      )\n\n      if (!lSubType) {\n        lType[subTypeName].push(rSubType)\n        continue\n      }\n\n      let resolver = subTypeResolverMap.get(subTypeName) || 'fieldMergeResolver'\n      let resultingSubType = conflictResolvers[resolver](\n        lType,\n        lSubType,\n        rType,\n        rSubType\n      )\n      let index = lType.fields.indexOf(lSubType)\n\n      lType[subTypeName].splice(index, 1, resultingSubType)\n    }\n  }\n}\n\n/**\n * Compares a subset of ASTNode fields. Designed to work on all the various\n * types that might have a merge conflict.\n *\n * @param {string} subTypeName the name of the field type; one of the following\n * values: 'fields', 'directives', 'values', 'types'\n * @param {ASTNode} lType the lefthand type containing the subtype to compare\n * @param {ASTNode} lSubType the lefthand subtype; fields, directive, value or\n * named union type\n * @param {ASTNode} rType the righthand type containing the subtype to compare\n * @param {ASTNode} rSubType the righthand subtype; fields, directive, value or\n * named union type\n */\nfunction pareTypeAndSubType(\n  subTypeName: string,\n  lType: ASTNode,\n  rType: ASTNode,\n  resolvers: ResolverMap = {}\n): void {\n  for (let rSubType of rType[subTypeName]) {\n    let lSubType = lType[subTypeName].find(\n      f => f.name.value == rSubType.name.value\n    )\n\n    if (!lSubType) {\n      continue\n    }\n\n    let index = lType.fields.indexOf(lSubType)\n    lType[subTypeName].splice(index, 1)\n\n    if (\n      resolvers[lType.name.value] &&\n      resolvers[lType.name.value][lSubType.name.value]\n    ) {\n      delete resolvers[lType.name.value][lSubType.name.value]\n    }\n    else if (resolvers[lSubType.name.value]) {\n      delete resolvers[lSubType.name.value]\n    }\n  }\n}\n\n/**\n * Small function that sorts through the typeDefs value supplied which can be\n * any one of a Schemata instance, GraphQLSchema instance, Source instance or a\n * string.\n *\n * @param {SchemaSource} typeDefs an instance of Schemata, a string of SDL,\n * a Source instance of SDL, a GraphQLSchema or ASTNode that can be printed\n * as an SDL string\n * @return {string} a string representing the thing supplied as typeDefs\n */\nexport function normalizeSource(\n  typeDefs: SchemaSource,\n  wrap: boolean = false\n): string | Schemata {\n  if (!typeDefs) {\n    throw new Error(inline`\n      normalizeSource(typeDefs): typeDefs was invalid when passed to the\n      function \\`normalizeSource\\`. Please check your code and try again.\n\n      (received: ${typeDefs})\n    `)\n  }\n\n  if (typeDefs instanceof Schemata && typeDefs.valid && wrap) {\n    return typeDefs\n  }\n\n  let source = (\n    typeDefs.body ||\n    typeDefs.sdl ||\n    (typeof typeDefs === 'string' && typeDefs) ||\n    (typeof typeDefs === 'object' && Schemata.print(typeDefs)) ||\n    (typeDefs instanceof GraphQLSchema\n      ? printSchema(typeDefs)\n      : typeDefs.toString())\n  ).toString().trim()\n\n  return wrap ? Schemata.from(source) : source\n}\n\nexport default Schemata\n"]}