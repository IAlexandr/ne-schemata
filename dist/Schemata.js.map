{"version":3,"sources":["../src/Schemata.js"],"names":["runInjectors","SchemaInjectorConfig","stripResolversFromSchema","DefaultFieldMergeResolver","DefaultDirectiveMergeResolver","DefaultEnumMergeResolver","DefaultUnionMergeResolver","DefaultScalarMergeResolver","normalizeSource","debug_log","require","debug_trace","Schemata","String","constructor","typeDefs","resolvers","buildResolvers","flattenResolvers","GRAPHIQL_FLAG","TYPEDEFS_KEY","MAP","WeakMap","set","wmkSchema","wmkResolvers","wmkPreboundResolvers","prevResolverMaps","get","EXE","Symbol","for","buildResolverForEachField","species","iterator","toString","bind","toStringTag","name","ast","parse","sdl","graphiql","value","schema","Object","keys","length","executableSchema","buildSchema","error","maps","isRootType","t","undefined","Class","forEachField","type","typeName","typeDirectives","field","fieldName","fieldArgs","fieldDirectives","context","resolve","astNode","rootValue","schemaResolverFor","valid","_type","getType","_field","getFields","schemaFieldByName","validSchema","astTypeByName","validSDL","definitions","find","f","astFieldByName","fields","hasFlattenedResolvers","asts","query","mutation","subscription","mergeSDL","schemaLanguage","conflictResolvers","DefaultConflictResolvers","source","Error","lAST","rAST","_scalarFns","rType","lType","a","kind","endsWith","substring","push","combineTypeAndSubType","lScalar","lScalarConfig","rScalar","rScalarConfig","resolver","_scalarConfig","scalarMergeResolver","merged","from","gql","print","pareSDL","resolverMap","len","pareTypeAndSubType","index","indexOf","splice","values","types","result","mergeSchema","config","DefaultMergeOptions","left","right","exResolverMaps","mergeResolvers","schemata","concat","reduce","p","c","i","wrapResolvers","object","entries","key","originalResolver","args","info","_args","flattenRootResolversOrFirstParam","extendWith","rootType","item","interim","r","hasAnExecutableSchema","e","clearResolvers","clearSchema","inspect","valueOf","forEachOf","fn","suppliedSchema","forEachType","forEachInputObjectType","INPUT_TYPES","forEachUnion","forEachEnum","forEachInterface","forEachScalar","forEachRootType","forEachTypeField","forEachInterfaceField","forEachInputObjectField","run","contextValue","variableValues","operationName","fieldResolver","graphqlSync","runAsync","graphql","showError","schemaOpts","enhance","node","printSchema","ALL","TYPES","INTERFACES","ENUMS","UNIONS","SCALARS","ROOT_TYPES","HIDDEN","resolverInjectors","resolverArgs","Array","isArray","injector","extraConfig","baseConfig","__schema_injector__","_schema","leftType","leftField","rightType","rightField","leftDirective","rightDirective","leftValue","rightValue","leftUnion","rightUnion","leftScalar","leftConfig","rightScalar","rightConfig","fieldMergeResolver","directiveMergeResolver","enumValueMergeResolver","typeValueMergeResolver","subTypeResolverMap","Map","subTypeName","rSubType","lSubType","resultingSubType","wrap","body"],"mappings":"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","file":"Schemata.js","sourceRoot":"src","sourcesContent":["// @flow\n\nconst debug_log = require('debug')('schemata:normal')\nconst debug_trace = require('debug')('schemata:trace')\n\nimport type {\n  ASTNode,\n  BuildSchemaOptions,\n  DirectiveNode,\n  EnumValueNode,\n  ExecutionResult,\n  FieldNode,\n  GraphQLFieldResolver,\n  GraphQLResolveInfo,\n  GraphQLScalarTypeConfig,\n  NamedTypeNode,\n  ObjMap,\n  ParseOptions,\n  ScalarTypeDefinitionNode,\n  Source,\n} from 'graphql'\n\nimport {\n  defaultFieldResolver,\n  GraphQLObjectType,\n  GraphQLSchema,\n  printSchema\n} from 'graphql'\n\nimport { ExtendedResolverMap } from './ExtendedResolverMap'\nimport { inline } from 'ne-tag-fns'\nimport merge from 'deepmerge'\n\nimport {\n  forEachOf,\n  forEachField,\n\n  ALL,\n  TYPES,\n  INTERFACES,\n  ENUMS,\n  UNIONS,\n  SCALARS,\n  ROOT_TYPES,\n  HIDDEN\n} from './forEachOf'\n\nimport type { ForEachOfResolver, ForEachFieldResolver } from './forEachOf'\n\n/**\n * A small `String` extension that makes working with SDL/IDL text far easier\n * in both your own libraries as well as in a nodeJS REPL. Built-in to what\n * appears to be a normal String for all intents and purposes, are the ability\n * to transform the string into a set of AST nodes, a built schema or back to\n * the SDL string.\n *\n * @class  Schemata\n */\nexport class Schemata extends String {\n  /**\n   * Creates a new `String`, presumably of SDL or IDL. The getter `.valid`\n   * will provide some indication as to whether or not the code is valid.\n   *\n   * @constructor\n   * @memberOf Schemata\n   *\n   * @param {string|Schemata|Source|Class<GraphQLSchema>|ASTNode} typeDefs\n   * an instance of Schemata, a string of SDL, a Source instance of SDL, a\n   * GraphQLSchema or ASTNode that can be printed as an SDL string\n   * @param {ResolverMap} resolvers an object containing field resolvers for\n   * for the schema represented with this string. [Optional]\n   * @param {boolean} buildResolvers if this flag is set to true, build a set\n   * of resolvers after the rest of the instance is initialized and set the\n   * results on the `.resolvers` property of the newly created instance. If\n   * buildResolvers is the string \"all\", then a resolver for each field not\n   * defined will be returned with a `defaultFieldResolver` as its value\n   * @param {boolean} flattenResolvers if true, and if `buildResolvers` is true,\n   * then make an attempt to flatten the root types to the base of the\n   * resolver map object.\n   */\n  constructor(\n    typeDefs: string\n      | Class<Source>\n      | Class<Schemata>\n      | Class<GraphQLSchema>\n      | ASTNode,\n    resolvers: ?ResolverMap = null,\n    buildResolvers: boolean | string = false,\n    flattenResolvers: boolean = false,\n  ) {\n    super(normalizeSource(typeDefs))\n\n    resolvers = (\n      resolvers\n      || typeDefs instanceof Schemata && typeDefs.resolvers\n      || typeDefs instanceof GraphQLSchema && stripResolversFromSchema(typeDefs)\n      || null\n    )\n\n    this[GRAPHIQL_FLAG] = true\n    this[TYPEDEFS_KEY] = normalizeSource(typeDefs)\n    this[MAP] = new WeakMap()\n    this[MAP].set(\n      wmkSchema,\n      typeDefs instanceof GraphQLSchema ? typeDefs : null\n    )\n    this[MAP].set(wmkResolvers, resolvers)\n    this[MAP].set(\n      wmkPreboundResolvers,\n      typeDefs instanceof Schemata ? typeDefs.prevResolverMaps : []\n    )\n\n    // Mark a schema passed to use in the constructor as an executable schema\n    // to prevent any replacement of the value by getters that generate a\n    // schema from the SDL\n    if (this[MAP].get(wmkSchema)) {\n      this[MAP].get(wmkSchema)[EXE] = true\n      this[MAP].get(wmkSchema)[Symbol.for('constructor-supplied-schema')] = true\n    }\n\n    // If buildResolvers is true, after the rest is already set and done, go\n    // ahead and build a new set of resolver functions for this instance\n    if (buildResolvers) {\n      if (buildResolvers === \"all\") {\n        this.resolvers = this.buildResolverForEachField(flattenResolvers)\n      }\n      else {\n        this.resolvers = this.buildResolvers(flattenResolvers)\n      }\n    }\n  }\n\n  /**\n   * Symbol.species ensures that any String methods used on this instance will\n   * result in a Schemata instance rather than a String. NOTE: this does not\n   * work as expected in current versions of node. This bit of code here is\n   * basically a bit of future proofing for when Symbol.species starts working\n   * with String extended classes\n   *\n   * @type {Function}\n   */\n  static get [Symbol.species](): Function { return Schemata }\n\n  /**\n   * Redefine the iterator for Schemata instances so that they simply show the\n   * contents of the SDL/typeDefs.\n   *\n   * @type {Function}\n   */\n  get [Symbol.iterator](): Function {\n    return (function *() {\n      yield this.toString()\n    }).bind(this)\n  }\n\n  /**\n   * Ensures that instances of Schemata report internally as Schemata object.\n   * Specifically using things like `Object.prototype.toString`.\n   *\n   * @type {string}\n   */\n  get [Symbol.toStringTag](): string { return this.constructor.name }\n\n  /**\n   * Returns the AST nodes for this snippet of SDL. It will throw an error\n   * if the string is not valid SDL/IDL.\n   *\n   * @return {ASTNode} any valid ASTNode supported by GraphQL\n   */\n  get ast(): ASTNode { return this.constructor.parse(this.sdl, false) }\n\n  /**\n   * Retrieves the `graphiql` flag, which defaults to true. This flag can\n   * make setting up an endpoint from a Schemata instance easier with\n   * express-graphql\n   *\n   * @type {boolean}\n   */\n  get graphiql(): boolean { return this[GRAPHIQL_FLAG] }\n\n  /**\n   * Setter to alter the default 'true' flag to make an Schemata instance a\n   * valid single argument to functions like `graphqlHTTP()` from express\n   * GraphQL.\n   *\n   * NOTE: this flag means nothing to the Schemata class but might be useful in\n   * your project.\n   *\n   * @type {boolean} true if graphiql should be started; false otherwise\n   */\n  set graphiql(value: boolean): void { this[GRAPHIQL_FLAG] = value }\n\n  /**\n   * Returns a GraphQLSchema object. Note this will fail and throw an error\n   * if there is not at least one Query, Subscription or Mutation type defined.\n   * If there is no stored schema, and there are resolvers, an executable\n   * schema is returned instead.\n   *\n   * @return {GraphQLSchema} an instance of GraphQLSchema if valid SDL\n   */\n  get schema(): Class<GraphQLSchema> {\n    if (this[MAP].get(wmkSchema)) {\n      debug_log('[get .schema] retrieving existing schema')\n      return this[MAP].get(wmkSchema)\n    }\n\n    try {\n      if (this.resolvers && Object.keys(this.resolvers).length) {\n        debug_log('[get .schema] creating executable schema instead')\n        return this.executableSchema\n      }\n      else {\n        debug_log('[get .schema] building new schema')\n        this[MAP].set(wmkSchema, this.constructor.buildSchema(this.sdl, true))\n        this[MAP].get(wmkSchema)[EXE] = false\n      }\n    }\n    catch (error) {\n      debug_log('[get .schema] failed to build schema!!')\n      debug_trace('[get .schema] ', error)\n      return null\n    }\n\n    return this[MAP].get(wmkSchema)\n  }\n\n  /**\n   * Sets a GraphQLSchema object on the internal weak map store.\n   *\n   * @param {GraphQLSchema} schema an instance of GraphQLSchema instance to\n   * store on the internal weak map. Any schema stored here will be modified\n   * by methods that do so.\n   */\n  set schema(schema: ?GraphQLSchema): void {\n    debug_log('[set .schema]: ', schema ? 'truthy' : 'falsey')\n    debug_trace('[set .schema] ', schema)\n    this[MAP].set(wmkSchema, schema)\n  }\n\n  /**\n   * When a Schemata instance is merged with another GraphQLSchema, its\n   * resolvers get stored before they are wrapped in a function that updates\n   * the schema object it receives. This allows them to be wrapped safely at\n   * a later date should this instance be merged with another.\n   *\n   * @return {Array<ExtendedResolverMap>} an array of `ExtendedResolverMap`\n   * object instances\n   */\n  get prevResolverMaps(): Array<ExtendedResolverMap> {\n    return this[MAP].get(wmkPreboundResolvers)\n  }\n\n  /**\n   * Sets the pre-bound resolver map objects as an array of\n   * `ExtendedResolverMap` object instances on this instance of Schemata\n   *\n   * @param {Array<ExtendedResolverMap>} maps an array of `ExtendedResolverMap`\n   * object instances\n   */\n  set prevResolverMaps(maps: Array<ExtendedResolverMap>): void {\n    this[MAP].set(wmkPreboundResolvers, maps)\n  }\n\n  /**\n   * Returns a GraphQLSchema object, pre-bound, to the associated resolvers\n   * methods in `.resolvers`. If `.resolvers` is falsey, an error will be\n   * thrown.\n   *\n   * @return {GraphQLSchema} an instance of GraphQLSchema with pre-bound\n   * resolvers\n   */\n  get executableSchema(): Class<GraphQLSchema> {\n    const isRootType = (t) => {\n      if (t === undefined || t === null || !t) {\n        return false;\n      }\n\n      let name = (typeof t.name === 'string') ? t.name : t.name.value\n\n      return ((t instanceof GraphQLObjectType) &&\n        (t.name === 'Query'\n        || t.name === 'Mutation'\n        || t.name === 'Subscription')\n      )\n    }\n    const Class = this.constructor\n    const resolvers = this.resolvers\n    let schema\n\n    if (this[MAP].get(wmkSchema) && this.resolvers) {\n      schema = this[MAP].get(wmkSchema)\n\n      if (schema && schema[EXE]) {\n        return schema\n      }\n    }\n\n    try {\n      debug_log('[get .executableSchema] creating schema from SDL')\n      this[MAP].set(wmkSchema, (schema = Class.buildSchema(this.sdl, true)))\n    }\n    catch (error) {\n      debug_log('[get .executableSchema] failed to create schema')\n      debug_trace('[get .executableSchema] ERROR!', error)\n      return null\n    }\n\n    this.forEachField((\n      type, typeName, typeDirectives,\n      field, fieldName, fieldArgs, fieldDirectives,\n      schema, context\n    ) => {\n      if (!resolvers) { return }\n\n      if (isRootType(type) && resolvers[fieldName]) {\n        field.resolve = resolvers[fieldName]\n        field.astNode.resolve = resolvers[fieldName]\n      }\n\n      if (resolvers[typeName] && resolvers[typeName][fieldName]) {\n        field.resolve = resolvers[typeName][fieldName]\n        field.astNode.resolve = resolvers[typeName][fieldName]\n      }\n    })\n\n    schema[EXE] = true\n    this[MAP].set(wmkSchema, schema)\n\n    return schema;\n  }\n\n  /**\n   * Returns the string this instance was generated with.\n   *\n   * @return {string} the string this class instance represents\n   */\n  get sdl(): string { return this[TYPEDEFS_KEY] }\n\n  /**\n   * A synonym or alias for `.sdl`. Placed here for the express purpose of\n   * destructuing when used with Apollo's makeExecutableSchema or other\n   * libraries expecting values of the same name\n   *\n   * i.e.\n   *   // sdl.typeDefs and sdl.resolvers will be where the function expects\n   *   let schema = require('graphql-tools').makeExecutableSchema(sdl)\n   *\n   * @return {string} a string of SDL/IDL for use with graphql\n   */\n  get typeDefs(): string { return this.sdl }\n\n  /**\n   * An internal call to buildResolvers(true), thereby requesting a flattened\n   * resolver map with Query, Mutation and Subscription fields exposed as root\n   * objects the way the Facebook reference implementation expects\n   *\n   * @return {Object} an object of functions or an empty object otherwise\n   */\n  get rootValue(): ResolverMap { return this.buildResolvers(true) }\n\n  /**\n   * Returns any resolvers function object associated with this instance.\n   *\n   * @return {Object} an object containing field resolvers or null if none\n   * are stored within\n   */\n  get resolvers(): ResolverMap { return this[MAP].get(wmkResolvers) }\n\n  /**\n   * A method to fetch a particular field resolver from the schema represented\n   * by this Schemata instance.\n   *\n   * @param {string} type the name of the type desired\n   * @param {string} field the name of the field containing the resolver\n   * @return {Function} the function resolver for the type and field in\n   * question\n   */\n  schemaResolverFor(type: string, field: string): ?Function {\n    if (\n      !this.resolvers\n      || !Object.keys(this.resolvers).length\n      || !this.valid\n    ) {\n      return null\n    }\n\n    let _type = this.executableSchema.getType(type)\n    let _field = _type.getFields() && _type.getFields()[field] || null\n    let resolve = _field && _field.resolve || null\n\n    return resolve\n  }\n\n  /**\n   * Builds a schema based on the SDL in the instance and then parses it to\n   * fetch a named field in a named type. If either the type or field are\n   * missing or if the SDL cannot be built as a schema, null is returned.\n   *\n   * @param {string} type the name of a type\n   * @param {string} field the name of a field contained in the above type\n   * @return {FieldNode} the field reference in the type and field supplied\n   */\n  schemaFieldByName(type: string, field: string): FieldNode {\n    if (!this.validSchema || !this.schema) { return null }\n\n    let _type = this.schema.getType(type)\n    let _field = _type.getFields() && _type.getFields()[field] || null\n\n    return _field\n  }\n\n  /**\n   * For SDL that doesn't properly build into a GraphQLSchema, it can still be\n   * parsed and searched for a type by name.\n   *\n   * @param {string} type the name of a type\n   * @return {FieldNode} the field reference in the type and field supplied\n   */\n  astTypeByName(type: string): ASTNode {\n    if (!this.validSDL) { return null }\n\n    let _type = this.ast.definitions.find(f => f.name.value === type)\n\n    return _type\n  }\n\n  /**\n   * For SDL that doesn't properly build into a GraphQLSchema, it can still be\n   * searched for a type and field.\n   *\n   * @param {string} type the name of a type\n   * @param {string} field the name of a field contained in the above type\n   * @return {FieldNode} the field reference in the type and field supplied\n   */\n  astFieldByName(type: string, field: string): FieldNode {\n    if (!this.validSDL) { return null }\n\n    let _type = this.ast.definitions.find(f => f.name.value === type)\n    let _field = _type && _type.fields.find(f => f.name.value === field) || null\n\n    return _field\n  }\n\n  /**\n   * Walks the AST for this SDL string and checks for the names of the fields\n   * of each of the root types; Query, Mutation and Subscription. If there are\n   * no root types defined, false is returned.\n   *\n   * If there is at least one root type *and* some resolvers *and* at least one\n   * of the fields of at least one root type is present in the root of the\n   * resolvers map, true is returned. Otherwise, false.\n   *\n   * @return {boolean} true if the defined resolvers have at least one root\n   * type field as a resolver on the root of the resolver map; false otherwise.\n   */\n  get hasFlattenedResolvers(): boolean {\n    let asts = this.validSDL && this.ast.definitions || null\n\n    if (!asts || !this.resolvers) { return false }\n\n    let query = asts.find(f => f.name.value == 'Query')\n    let mutation = asts.find(f => f.name.value == 'Mutation')\n    let subscription = asts.find(f => f.name.value == 'Subscription')\n    let resolvers = this.resolvers\n\n    if (!query && !mutation && !subscription) {\n      return false\n    }\n\n    for (let type of [query, mutation, subscription]) {\n      if (!type || !type.fields) { continue }\n\n      for (let field of type.fields) {\n        if (field.name.value in resolvers) {\n          return true\n        }\n      }\n    }\n\n    return false\n  }\n\n  /**\n   * Merging Schematas are a common feature in the modern world of GraphQL.\n   * Especially when there are multiple teams working in tandem. This feature\n   * supports merging of types, extended types, interfaces, enums, unions,\n   * input object types and directives for all of the above.\n   *\n   * @param {string|Class<Schemata>|Class<Source>|Class<GraphQLSchema>|ASTNode}\n   * schemaLanguage an instance of Schemata, a string of SDL, a Source instance\n   * of SDL, a GraphQLSchema or ASTNode that can be printed as an SDL string\n   * @param {ConflictResolvers} conflictResolvers an object containing up to\n   * four methods, each describing how to handle a conflict when an associated\n   * type of conflict occurs. If no object or method are supplied, the right\n   * hande value always takes precedence over the existing value; replacing it\n   * @return {Schemata} a new instance of Schemata\n   */\n  mergeSDL(\n    schemaLanguage: string\n      | Class<Source>\n      | Class<Schemata>\n      | Class<GraphQLSchema>\n      | ASTNode,\n    conflictResolvers: ?ConflictResolvers = DefaultConflictResolvers\n  ): Class<Schemata> {\n    let source = normalizeSource(schemaLanguage, true)\n\n    if (!source) {\n      throw new Error(inline`\n        The call to mergeSDL(schemaLanguage, conflictResolvers) received an\n        invalid value for schemaLanguage. Please check your code and try again.\n        Received ${schemaLanguage}.\n      `)\n    }\n\n    let lAST = this.ast\n    let rAST = source.ast\n    let _scalarFns = {}\n\n    // Ensure we have default behavior with any custom behavior assigned\n    // atop the default ones should only a partial custom be supplied.\n    conflictResolvers = merge(\n      DefaultConflictResolvers,\n      conflictResolvers\n    )\n\n    for (let rType of rAST.definitions) {\n      let lType = lAST.definitions.find(a => a.name.value == rType.name.value)\n\n      if (\n        rType.kind\n        && rType.kind.endsWith\n        && rType.kind.endsWith('Extension')\n      ) {\n        rType = merge({}, rType)\n        rType.kind =\n          rType.kind.substring(0, rType.kind.length - 9) + 'Definition'\n      }\n\n      if (!lType) {\n        lAST.definitions.push(rType)\n        continue\n      }\n\n      switch (lType.kind) {\n        default:\n        case 'ObjectTypeDefinition':\n        case 'ObjectTypeDefinitionExtension':\n        case 'InterfaceTypeDefinition':\n        case 'InterfaceTypeDefinitionExtension':\n        case 'InputObjectTypeDefinition':\n        case 'InputObjectTypeDefinitionExtension':\n          combineTypeAndSubType('directives', lType, rType, conflictResolvers)\n          combineTypeAndSubType('fields', lType, rType, conflictResolvers)\n          break;\n\n        case 'EnumTypeDefinition':\n          combineTypeAndSubType('directives', lType, rType, conflictResolvers)\n          combineTypeAndSubType('values', lType, rType, conflictResolvers)\n          break;\n\n        case 'UnionTypeDefinition':\n          combineTypeAndSubType('directives', lType, rType, conflictResolvers)\n          combineTypeAndSubType('types', lType, rType, conflictResolvers)\n          break;\n\n        case 'ScalarTypeDefinitionNode':\n          let lScalar, lScalarConfig, rScalar, rScalarConfig, resolver\n\n          combineTypeAndSubType('directives', lType, rType, conflictResolvers)\n\n          if (this.schema) {\n            lScalar = this.schema.getType(lType.name.value)\n            lScalarConfig = lScalar && lScalar._scalarConfig || null\n          }\n\n          if (source.schema) {\n            rScalar = source.schema.getType(rType.name.value)\n            rScalarConfig = rScalar && rScalar._scalarConfig || null\n          }\n\n          resolver = (\n            conflictResolvers.scalarMergeResolver\n            || DefaultConflictResolvers.scalarMergeResolver\n          )(lType, lScalarConfig, rType, rScalarConfig)\n\n          if (resolver) {\n            _scalarFns[lType.name.value] = _scalarFns[lType.name.value] || {}\n            _scalarFns[lType.name.value] = resolver\n          }\n\n          break;\n      }\n    }\n\n    let merged = Schemata.from(this.constructor.gql.print(lAST))\n\n    if (Object.keys(_scalarFns).length) {\n      for (let typeName of Object.keys(_scalarFns)) {\n        merged.schema.getType(typeName)._scalarConfig = _scalarConfig[typeName]\n      }\n    }\n\n    return merged\n  }\n\n  /**\n   * Paring down Schematas can be handy for certain types of schema stitching.\n   * The SDL passed in and any associated resolvers will be removed from\n   * a copy of the SDL in this Schemata instance represents and the resolver\n   * map passed in.\n   *\n   * @param {string|Schemata|Source|Class<GraphQLSchema>|ASTNode} schemaLanguage\n   * an instance of Schemata, a string of SDL, a Source instance of SDL, a\n   * GraphQLSchema or ASTNode that can be printed as an SDL string\n   * @param {ResolverMap} resolverMap an object containing resolver functions,\n   * from either those set on this instance or those in the resolverMap added in\n   * @return {Schemata} a new Schemata instance with the changed values set\n   * on it\n   */\n  pareSDL(\n    schemaLanguage: string\n      | Class<Schemata>\n      | Class<Source>\n      | Class<GraphQLSchema>,\n    resolverMap: ?ResolverMap = null\n  ): Class<Schemata> {\n    let source = normalizeSource(schemaLanguage, true)\n    if (!source) {\n      throw new Error(inline`\n        In the call to pareSDL(schemaLanguage), the supplied value for\n        \\`schemaLanguage\\` could not be parsed.\n      `)\n    }\n\n    if (schemaLanguage instanceof GraphQLSchema && !resolverMap) {\n      resolverMap = stripResolversFromSchema(schemaLanguage)\n    }\n\n    let resolvers = merge({}, resolverMap || this.resolvers || {})\n    let lAST = this.ast\n    let rAST = source.ast\n\n    for (let rType of rAST.definitions) {\n      let lType = lAST.definitions.find(a => a.name.value == rType.name.value)\n\n      if (\n        rType.kind\n        && rType.kind.endsWith\n        && rType.kind.endsWith('Extension')\n      ) {\n        let len = 'Extension'.length\n\n        rType = merge({}, rType)\n        rType.kind =\n          rType.kind.substring(0, rType.kind.length - len) + 'Definition'\n      }\n\n      if (!lType) {\n        lAST.definitions.push(rType)\n        continue\n      }\n\n      switch (lType.kind) {\n        default:\n        case 'ObjectTypeDefinition':\n        case 'ObjectTypeDefinitionExtension':\n        case 'InterfaceTypeDefinition':\n        case 'InterfaceTypeDefinitionExtension':\n        case 'InputObjectTypeDefinition':\n        case 'InputObjectTypeDefinitionExtension':\n          pareTypeAndSubType('directives', lType, rType, resolvers)\n          pareTypeAndSubType('fields', lType, rType, resolvers)\n\n          if (!lType.fields.length) {\n            let index = lAST.definitions.indexOf(lType)\n\n            if (index !== -1) {\n              lAST.definitions.splice(index, 1)\n            }\n          }\n          break;\n\n        case 'EnumTypeDefinition':\n          pareTypeAndSubType('directives', lType, rType, resolvers)\n          pareTypeAndSubType('values', lType, rType, resolvers)\n\n          if (!lType.values.length) {\n            let index = lAST.definitions.indexOf(lType)\n\n            if (index !== -1) {\n              lAST.definitions.splice(index, 1)\n            }\n          }\n          break;\n\n        case 'UnionTypeDefinition':\n          pareTypeAndSubType('directives', lType, rType, resolvers)\n          pareTypeAndSubType('types', lType, rType, resolvers)\n\n          if (!lType.types.length) {\n            let index = lAST.definitions.indexOf(lType)\n\n            if (index !== -1) {\n              lAST.definitions.splice(index, 1)\n            }\n          }\n          break;\n\n        case 'ScalarTypeDefinitionNode':\n          let index = lAST.definitions.indexOf(lType)\n\n          if (index !== -1) {\n            lAST.definitions.splice(index, 1)\n          }\n          break;\n      }\n    }\n\n    let result = Schemata.from(this.constructor.gql.print(lAST), resolvers)\n    result.executableSchema\n\n    return result\n  }\n\n  /**\n   * A new Schemata object instance with merged schema definitions as its\n   * contents as well as merged resolvers and newly bound executable schema are\n   * all created in this step and passed back. The object instance itself is\n   * not modified\n   *\n   * Post merge, the previously stored and merged resolvers map are are applied\n   * and a new executable schema is built from the ashes of the old.\n   *\n   * @param {GraphQLSchema} schema an instance of GraphQLSchema to merge\n   * @param {ConflictResolvers} conflictResolvers an object containing up to\n   * four methods, each describing how to handle a conflict when an associated\n   * type of conflict occurs. If no object or method are supplied, the right\n   * hande value always takes precedence over the existing value; replacing it\n   * @return {Schemata} a new instance of Schemata with a merged schema string,\n   * merged resolver map and newly bound executable schema attached are all\n   * initiated\n   */\n  mergeSchema(\n    schema: Class<GraphQLSchema> | Class<Schemata>,\n    conflictResolvers: ?ConflictResolvers = DefaultConflictResolvers,\n    config: ?MergeOptionsConfig = DefaultMergeOptions\n  ): Class<Schemata> {\n    if (!schema) {\n      throw new Error(inline`\n        In the call to mergeSchema(schema), ${schema} was received as a value\n        and the code could not proceed because of it. Please check your code\n        and try again\n      `)\n    }\n\n    let left = Schemata.from(this, undefined, \"all\")\n    let right = Schemata.from(schema, undefined, \"all\")\n\n    let exResolverMaps = right.prevResolverMaps || []\n    let mergeResolvers\n    let schemata\n\n    // Previous resolver maps should only consist of defined resolvers\n    if (left.prevResolverMaps && left.prevResolverMaps.length) {\n      exResolverMaps = exResolverMaps.concat(left.prevResolverMaps)\n    }\n    else {\n      exResolverMaps.push(ExtendedResolverMap.from(\n        Schemata.from(this, undefined, true)\n      ))\n    }\n    exResolverMaps.push(ExtendedResolverMap.from(\n      Schemata.from(schema, undefined, true)\n    ))\n\n    // Walk through the list of\n    if (exResolverMaps && exResolverMaps.length) {\n      mergeResolvers = exResolverMaps.reduce((p,c,i,a) => {\n        return merge(p, c.resolvers || {})\n      }, {})\n    }\n\n    // Create a resolver map with the newly wrapped resolvers and those\n    // in the schema represented by this instance.\n    schemata = left.mergeSDL(right)\n\n    // Store the previous original resolver maps\n    schemata.prevResolverMaps = exResolverMaps\n\n    // This function allows recursive wrapping of resolver functions,\n    // overriding which values they receive as arguments via the\n    // MergeOptionsConfig and schemaInjectors.\n    //\n    // WARNNING: This function definition needs to occur AFTER the definition\n    // of `schemata` one code line before as it is used by closure within\n    // the function below\n    let wrapResolvers = (object) => {\n      for (let [key, value] of Object.entries(object)) {\n        if (typeof value === 'object') {\n          object[key] = wrapResolvers(value)\n        }\n        else {\n          let originalResolver = value\n          object[key] = function(source, args, context, info) {\n            let _args = runInjectors(\n              SchemaInjectorConfig(schemata.executableSchema, config),\n              { source, args, context, info }\n            )\n\n            return originalResolver(\n              _args.source, _args.args, _args.context, _args.info\n            )\n          }\n        }\n      }\n\n      return object\n    }\n\n    // Set the resolvers on the result\n    schemata.resolvers = wrapResolvers(\n      merge(left.resolvers, merge(right.resolvers, mergeResolvers))\n    )\n\n    // Trigger a new schema creation\n    schemata.executableSchema\n\n    return schemata\n  }\n\n  /**\n   * Given a schema, based on the Schemata this object is based on, walk it and\n   * build up a resolver map. This function will always return a non-null\n   * object. It will be empty if there are either no resolvers to be found\n   * in the schema or if a valid schema cannot be created.\n   *\n   * @param {boolean|ResolverMap} flattenRootResolversOrFirstParam if this\n   * value is boolean, and if this value is true, the resolvers from Query,\n   * Mutation and Subscription types will be flattened to the root of the\n   * object. If the first parametr is an Object, it will be merged in normally\n   * with merge.\n   * @param {Array<ResolverMap>} ...extendWith an unlimited array of objects\n   * that can be used to extend the built resolver map.\n   * @return {ResolverMap} a resolver map; i.e. an object of resolver functions\n   */\n  buildResolvers(\n    flattenRootResolversOrFirstParam: boolean | ResolverMap,\n    ...extendWith: Array<ResolverMap>\n  ): ResolverMap {\n    let schemata = Schemata.from(this.sdl, this.resolvers)\n    let resolvers = merge({},\n      (stripResolversFromSchema(schemata.executableSchema)\n        || schemata.resolvers\n        || {}\n      )\n    )\n\n    // Next check to see if we are flattening or simply extending\n    if (typeof flattenRootResolversOrFirstParam === 'boolean') {\n      for (let rootType of ['Query', 'Mutation', 'Subscription']) {\n        if (flattenRootResolversOrFirstParam) {\n          if (resolvers[rootType]) {\n            for (let field of Object.keys(resolvers[rootType])) {\n              resolvers[field] = resolvers[rootType][field]\n              delete resolvers[rootType][field]\n            }\n\n            delete resolvers[rootType]\n          }\n        }\n        else {\n          for (let field of Object.keys(resolvers)) {\n            try {\n              debug_log('[buildResolvers()] finding field in schema')\n              if (schemata.schemaFieldByName(rootType, field)) {\n                resolvers[rootType] = resolvers[rootType] || {}\n                resolvers[rootType][field] = resolvers[field]\n                delete resolvers[field]\n              }\n            }\n            catch (error) {\n              debug_log(inline`\n                [buildResolvers()] Falling back to \\`astFieldByName()\\`\n              `)\n              debug_trace(inline`\n                [buildResolvers()] Falling back to \\`astFieldByName()\\` due to\n              `, error)\n\n              if (schemata.astFieldByName(rootType, field)) {\n                resolvers[rootType] = resolvers[rootType] || {}\n                resolvers[rootType][field] = resolvers[field]\n                delete resolvers[field]\n              }\n            }\n          }\n        }\n      }\n    }\n    else {\n      resolvers = merge(resolvers || {}, flattenRootResolversOrFirstParam || {})\n    }\n\n    // Finally extend with any remaining arguments\n    if (extendWith.length) {\n      for (let item of extendWith) {\n        resolvers = merge(resolvers || {}, item || {})\n      }\n    }\n\n    return resolvers\n  }\n\n  /**\n   * From time to time it makes more sense to wrap every possible resolver\n   * mapping in given schema. Getting a handle to each fields resolver and\n   * or substituting missing ones with GraphQL's defaultFieldResolver can\n   * be a tiresome affair. This method walks the schema for you and returns\n   * any previously defined resolvers alongside defaultFieldResolvers for\n   * each possible field of every type in the schema.\n   *\n   * If a schema cannot be generated from the SDL represented by the instance\n   * of Schemata, then an error is thrown.\n   *\n   * @param {boolean|ResolverMap} flattenRootResolversOrFirstParam if this\n   * value is boolean, and if this value is true, the resolvers from Query,\n   * Mutation and Subscription types will be flattened to the root of the\n   * object. If the first parametr is an ResolverMap, it will be merged in\n   * normally with merge.\n   * @param {Array<ResolverMap>} ...extendWith an unlimited array of objects\n   * that can be used to extend the built resolver map.\n   * @return {ResolverMap} a resolver map; i.e. an object of resolver functions\n   */\n  buildResolverForEachField(\n    flattenRootResolversOrFirstParam: boolean | ResolverMap,\n    ...extendWith: Array<ResolverMap>\n  ): ResolverMap {\n    if (!this.schema) {\n      throw new Error(inline`\n        buildResolverForEachField() cannot be called unless there is enough\n        valid SDL in the instance to construct a schema. Please check your\n        code!\n      `)\n    }\n\n    let interim = Schemata.from(this.schema)\n    let r = {}\n\n    interim.forEachField((\n      type, typeName, typeDirectives,\n      field, fieldName, fieldArgs, fieldDirectives,\n      schema, context\n    ) => {\n      // Ensure the path to the type in question exists before continuing\n      // onward\n      (r[typeName] = (r[typeName] || {}))[fieldName]\n        = r[typeName][fieldName] || {}\n\n      r[typeName][fieldName] = field.resolve || defaultFieldResolver\n    })\n\n    interim.resolvers = r\n\n    return interim.buildResolvers(\n      flattenRootResolversOrFirstParam,\n      ...extendWith\n    )\n  }\n\n  /**\n   * A method to determine if an executable schema is attached to this Schemata\n   * instance. It does so by walking the schema fields via `buildResolvers()`\n   * and reporting whether there is anything inside the results or not.\n   *\n   * @return {boolean} true if there is at least one resolver on at least one\n   * field of a type in this Schemata instance's schema.\n   */\n  get hasAnExecutableSchema(): boolean {\n    return Object.keys(this.buildResolvers()).length > 0;\n  }\n\n  /**\n   * If the `.sdl` property is valid SDL/IDL and can generate valid AST nodes\n   * this function will return true. It will return false otherwise.\n   *\n   * @return {boolean} true if the string can be parsed; false otherwise\n   */\n  get validSDL(): boolean {\n    try {\n      this.constructor.gql.parse(this.sdl)\n      debug_log('[get .validSDL] true')\n      return true\n    }\n    catch(e) {\n      debug_log('[get .validSDL] false')\n      debug_trace('[get .validSDL] ', e)\n      return false\n    }\n  }\n\n  /**\n   * If the `.schema` property is valid SDL/IDL and can generate a valid\n   * GraphQLSchema, this function will return true. It will return false\n   * otherwise.\n   *\n   * @return {boolean} true if the string can be parsed into a schema; false\n   * otherwise\n   */\n  get validSchema(): boolean {\n    try {\n      this.schema;\n      debug_log('[get .validSchema] true')\n      return true\n    }\n    catch (e) {\n      debug_log('[get .validSchema] false')\n      debug_trace('[get .validSchema] ', e)\n      return false\n    }\n  }\n\n  /**\n   * Returns true if the string underlying this instance represents valid SDL\n   * that can be both converted to AST nodes or a valid GraphQLSchema instance\n   *\n   * @return {boolean} true if it is valid for both `parse()` as well as the\n   * `buildSchema()` function\n   */\n  get valid(): boolean { return this.validSDL && this.validSchema }\n\n\n  /**\n   * If the internal resolvers object needs to be changed after creation, this\n   * method allows a way to do so. Setting the value to `null` is equivalent\n   * to removing any stored value. Finally the contents are stored in a weak\n   * map so its contents are not guaranteed over a long period of time.\n   *\n   * @param {ResolverMap} resolvers an object containing field resolvers for\n   * this string instance.\n   */\n  set resolvers(resolvers: ?ResolverMap): void {\n    this[MAP].set(wmkResolvers, resolvers)\n  }\n\n  /**\n   * Removes the resolver map associated with this Schemata instance\n   */\n  clearResolvers(): void {\n    this.resolvers = null\n  }\n\n  /**\n   * Removes the schema stored with this Schemata instance\n   */\n  clearSchema(): void {\n    this.schema = null\n  }\n\n  /**\n   * Returns the underlying string passed or generated in the constructor when\n   * inspected in the nodeJS REPL.\n   *\n   * @return {string} the SDL/IDL string this class was created on\n   */\n  inspect(): string { return this.sdl }\n\n  /**\n   * The same as `inspect()`, `toString()`, and `valueOf()`. This method\n   * returns the underlying string this class instance was created on.\n   *\n   * @return {string} [description]\n   */\n  toString(): string { return this.sdl }\n\n  /**\n   * The same as `inspect()`, `toString()`, and `valueOf()`. This method\n   * returns the underlying string this class instance was created on.\n   *\n   * @return {string} [description]\n   */\n  valueOf(): string { return this.sdl }\n\n  /**\n   * Iterates over the values contained in a Schema's typeMap. If a desired\n   * value is encountered, the supplied callback will be invoked. The values are\n   * the constants ALL, TYPES, INTERFACES, ENUMS, UNIONS and SCALARS. Optionally\n   * HIDDEN is another value that can be bitmasked together for a varied result.\n   * HIDDEN exposes the values in the schema typemap that begin with a double\n   * underscore.\n   *\n   * The signature for the function callback is as follows:\n   * (\n   *   type: mixed,\n   *   typeName: string,\n   *   typeDirectives: Array<GraphQLDirective>\n   *   schema: Class<GraphQLSchema>,\n   *   context: mixed,\n   * ) => void\n   *\n   * Where:\n   *   `type`           - the object instance from within the `GraphQLSchema`\n   *   `typeName`       - the name of the object; \"Query\" for type Query and\n   *                      so on.\n   *   `typeDirectives` - an array of directives applied to the object or an\n   *                      empty array if there are none applied.\n   *   `schema`         - an instance of `GraphQLSchema` over which to iterate\n   *   `context`        - usually an object, and usually the same object,\n   *                      passed to the call to `makeExecutableSchema()`\n   *                      or `graphql()`\n   *\n   * @param {Function} fn a function with a signature defined above\n   * @param {mixed} context usually an object but any mixed value the denotes\n   * some shared context as is used with the schema during normal runtime.\n   * @param {Number} types a bitmask of one or more of the constants defined\n   * above. These can be OR'ed together and default to TYPES.\n   * @param {GraphQLSchema} suppliedSchema an optional schema to use rather\n   * than the one created or stored internally generated from this SDL\n   * @return {GraphQLSchema} a new schema is generated from this SDL, iterated\n   * over and returned.\n   */\n  forEachOf(\n    fn: ForEachOfResolver,\n    context: mixed,\n    types: number = TYPES,\n    suppliedSchema: ?GraphQLSchema = null\n  ): Class<GraphQLSchema> {\n    let schema = suppliedSchema || this.schema\n\n    forEachOf(schema, fn, context, types)\n\n    return schema\n  }\n\n  /**\n   * Shortcut to `forEachOf()` specific to types.\n   *\n   * @see #forEachOf\n   *\n   * @param {Function} fn a function with a signature defined above\n   * @param {mixed} context usually an object but any mixed value the denotes\n   * some shared context as is used with the schema during normal runtime.\n   * @param {GraphQLSchema} suppliedSchema an optional schema to use rather\n   * than the one created or stored internally generated from this Schemata\n   * @return {GraphQLSchema} a new schema is generated from this Schemata,\n   * iterated over and returned.\n   */\n  forEachType(\n    fn: ForEachOfResolver,\n    context: mixed,\n    suppliedSchema: ?GraphQLSchema\n  ): Class<GraphQLSchema> {\n    return this.forEachOf(fn, context, TYPES, suppliedSchema)\n  }\n\n  /**\n   * Shortcut to `forEachOf()` specific to input object types.\n   *\n   * @see #forEachOf\n   *\n   * @param {Function} fn a function with a signature defined above\n   * @param {mixed} context usually an object but any mixed value the denotes\n   * some shared context as is used with the schema during normal runtime.\n   * @param {GraphQLSchema} suppliedSchema an optional schema to use rather\n   * than the one created or stored internally generated from this Schemata\n   * @return {GraphQLSchema} a new schema is generated from this Schemata,\n   * iterated\n   * over and returned.\n   */\n  forEachInputObjectType(\n    fn: ForEachOfResolver,\n    context: mixed,\n    suppliedSchema: ?GraphQLSchema\n  ): Class<GraphQLSchema> {\n    return this.forEachOf(fn, context, INPUT_TYPES, suppliedSchema)\n  }\n\n  /**\n   * Shortcut to `forEachOf()` specific to unions.\n   *\n   * @see #forEachOf\n   *\n   * @param {Function} fn a function with a signature defined above\n   * @param {mixed} context usually an object but any mixed value the denotes\n   * some shared context as is used with the schema during normal runtime.\n   * @param {GraphQLSchema} suppliedSchema an optional schema to use rather\n   * than the one created or stored internally generated from this SDL\n   * @return {GraphQLSchema} a new schema is generated from this SDL, iterated\n   * over and returned.\n   */\n  forEachUnion(\n    fn: ForEachOfResolver,\n    context: mixed,\n    suppliedSchema: ?GraphQLSchema\n  ): Class<GraphQLSchema> {\n    return this.forEachOf(fn, context, UNIONS, suppliedSchema)\n  }\n\n  /**\n   * Shortcut to `forEachOf()` specific to enums.\n   *\n   * @see #forEachOf\n   *\n   * @param {Function} fn a function with a signature defined above\n   * @param {mixed} context usually an object but any mixed value the denotes\n   * some shared context as is used with the schema during normal runtime.\n   * @param {GraphQLSchema} suppliedSchema an optional schema to use rather\n   * than the one created or stored internally generated from this SDL\n   * @return {GraphQLSchema} a new schema is generated from this SDL, iterated\n   * over and returned.\n   */\n  forEachEnum(\n    fn: ForEachOfResolver,\n    context: mixed,\n    suppliedSchema: ?GraphQLSchema\n  ): Class<GraphQLSchema> {\n    return this.forEachOf(fn, context, ENUMS, suppliedSchema)\n  }\n\n  /**\n   * Shortcut to `forEachOf()` specific to interfaces.\n   *\n   * @see #forEachOf\n   *\n   * @param {Function} fn a function with a signature defined above\n   * @param {mixed} context usually an object but any mixed value the denotes\n   * some shared context as is used with the schema during normal runtime.\n   * @param {GraphQLSchema} suppliedSchema an optional schema to use rather\n   * than the one created or stored internally generated from this SDL\n   * @return {GraphQLSchema} a new schema is generated from this SDL, iterated\n   * over and returned.\n   */\n  forEachInterface(\n    fn: ForEachOfResolver,\n    context: mixed,\n    suppliedSchema: ?GraphQLSchema\n  ): Class<GraphQLSchema> {\n    return this.forEachOf(fn, context, INTERFACES, suppliedSchema)\n  }\n\n  /**\n   * Shortcut to `forEachOf()` specific to types.\n   *\n   * @see #forEachOf\n   *\n   * @param {Function} fn a function with a signature defined above\n   * @param {mixed} context usually an object but any mixed value the denotes\n   * some shared context as is used with the schema during normal runtime.\n   * @param {GraphQLSchema} suppliedSchema an optional schema to use rather\n   * than the one created or stored internally generated from this SDL\n   * @return {GraphQLSchema} a new schema is generated from this SDL,\n   * iterated over and returned.\n   */\n  forEachScalar(\n    fn: ForEachOfResolver,\n    context: mixed,\n    suppliedSchema: ?GraphQLSchema\n  ): Class<GraphQLSchema> {\n    return this.forEachOf(fn, context, SCALARS, suppliedSchema)\n  }\n\n  /**\n   * Shortcut to `forEachOf()` specific to all root types; Query, Mutation and\n   * Subscription that exist within the schema.\n   *\n   * @see #forEachOf\n   *\n   * @param {Function} fn a function with a signature defined above\n   * @param {mixed} context usually an object but any mixed value the denotes\n   * some shared context as is used with the schema during normal runtime.\n   * @param {GraphQLSchema} suppliedSchema an optional schema to use rather\n   * than the one created or stored internally generated from this SDL\n   * @return {GraphQLSchema} a new schema is generated from this SDL, iterated\n   * over and returned.\n   */\n  forEachRootType(\n    fn: ForEachOfResolver,\n    context: mixed,\n    suppliedSchema: ?GraphQLSchema\n  ): Class<GraphQLSchema> {\n    return this.forEachOf(fn, context, ROOT_TYPES, suppliedSchema)\n  }\n\n  /**\n   * An extension of `forEachOf` that targets the fields of the types in the\n   * schema's typeMap. This function provides more detail and allows greater\n   * access to any associated `context` than the function of the same name\n   * provided by the `graphql-tools` library.\n   *\n   * The signature for the callback function is as follows\n   *\n   * (\n   *   type: mixed,\n   *   typeName: string,\n   *   typeDirectives: Array<GraphQLDirective>,\n   *   field: mixed,\n   *   fieldName: string,\n   *   fieldArgs: Array<GraphQLArgument>,\n   *   fieldDirectives: Array<GraphQLDirective>,\n   *   schema: Class<GraphQLSchema>,\n   *   context: mixed\n   * ) => void\n   *\n   * Where\n   *\n   * Where:\n   *   `type`           - the object instance from within the `GraphQLSchema`\n   *   `typeName`       - the name of the object; \"Query\" for type Query and\n   *                      so on\n   *   `typeDirectives` - an array of directives applied to the object or an\n   *                      empty array if there are none applied.\n   *   `field`          - the field in question from the type\n   *   `fieldName`      - the name of the field as a string\n   *   `fieldArgs`      - an array of arguments for the field in question\n   *   `fieldDirectives`- an array of directives applied to the field or an\n   *                      empty array should there be no applied directives\n   *   `schema`         - an instance of `GraphQLSchema` over which to iterate\n   *   `context`        - usually an object, and usually the same object, passed\n   *                      to the call to `makeExecutableSchema()` or `graphql()`\n   *\n   * @param {Function} fn a function with a signature defined above\n   * @param {mixed} context usually an object but any mixed value the denotes\n   * some shared context as is used with the schema during normal runtime.\n   * @param {GraphQLSchema} suppliedSchema an optional schema to use rather\n   * than the one created or stored internally generated from this SDL\n   * @return {GraphQLSchema} a new schema is generated from this SDL, iterated\n   * over and returned.\n   */\n  forEachField(\n    fn: ForEachFieldResolver,\n    context: mixed,\n    types: number = ALL,\n    suppliedSchema: ?GraphQLSchema = null\n  ): Class<GraphQLSchema> {\n    let schema = suppliedSchema || this.schema\n\n    forEachField(schema, fn, context, types)\n\n    return schema\n  }\n\n  /**\n   * `forEachField()` shortcut focusing on GraphQLObjectTypes specifically.\n   *\n   * @param {ForEachFieldResolver} fn a callback function that is invoked for\n   * each field of any GraphQLObjectType found\n   * @param {mixed} context usually an object but any mixed value the denotes\n   * some shared context as is used with the schema during normal runtime.\n   * @param {GraphQLSchema} suppliedSchema an optional schema to use rather\n   * than the one created or stored internally generated from this SDL\n   * @return {GraphQLSchema} either the supplied GraphQLSchema or one generated\n   * to facilitate the task\n   */\n  forEachTypeField(\n    fn: ForEachFieldResolver,\n    context: mixed,\n    suppliedSchema: ?GraphQLSchema = null\n  ): Class<GraphQLSchema> {\n    let schema = suppliedSchema || this.schema\n\n    forEachField(schema, fn, context, TYPES)\n\n    return schema\n  }\n\n  /**\n   * `forEachField()` shortcut focusing on GraphQLInterfaceType specifically.\n   *\n   * @param {ForEachFieldResolver} fn a callback function that is invoked for\n   * each field of any GraphQLObjectType found\n   * @param {mixed} context usually an object but any mixed value the denotes\n   * some shared context as is used with the schema during normal runtime.\n   * @param {GraphQLSchema} suppliedSchema an optional schema to use rather\n   * than the one created or stored internally generated from this SDL\n   * @return {GraphQLSchema} either the supplied GraphQLSchema or one generated\n   * to facilitate the task\n   */\n  forEachInterfaceField(\n    fn: ForEachFieldResolver,\n    context: mixed,\n    suppliedSchema: ?GraphQLSchema = null\n  ): Class<GraphQLSchema> {\n    let schema = suppliedSchema || this.schema\n\n    forEachField(schema, fn, context, INTERFACES)\n\n    return schema\n  }\n\n  /**\n   * `forEachField()` shortcut focusing on GraphQLInputObjectType specifically.\n   *\n   * @param {ForEachFieldResolver} fn a callback function that is invoked for\n   * each field of any GraphQLObjectType found\n   * @param {mixed} context usually an object but any mixed value the denotes\n   * some shared context as is used with the schema during normal runtime.\n   * @param {GraphQLSchema} suppliedSchema an optional schema to use rather\n   * than the one created or stored internally generated from this SDL\n   * @return {GraphQLSchema} either the supplied GraphQLSchema or one generated\n   * to facilitate the task\n   */\n  forEachInputObjectField(\n    fn: ForEachFieldResolver,\n    context: mixed,\n    suppliedSchema: ?GraphQLSchema = null\n  ): Class<GraphQLSchema> {\n    let schema = suppliedSchema || this.schema\n\n    forEachField(schema, fn, context, INPUT_TYPES)\n\n    return schema\n  }\n\n  /**\n   * Wrapper for `require('graphql').graphqlSync()` that automatically passes\n   * in the internal `.schema` reference as the first parameter.\n   *\n   * @param {string|Source} query A GraphQL language formatted string\n   * representing the requested operation.\n   * @param {mixed} contextValue a bit of shared context to pass to resolvers\n   * @param {Object} variableValues A mapping of variable name to runtime value\n   * to use for all variables defined in the requestString.\n   * @param {ResolverMap|null} rootValue provided as the first argument to\n   * resolver functions on the top level type (e.g. the query object type).\n   * @param {string} operationName The name of the operation to use if\n   * requestString contains multiple possible operations. Can be omitted if\n   * requestString contains only one operation.\n   * @param {GraphQLFieldResolver<any, any>} fieldResolver A resolver function\n   * to use when one is not provided by the schema. If not provided, the\n   * default field resolver is used (which looks for a value or method on the\n   * source value with the field's name).\n   * @return {ExecutionResult} the requested results. An error is thrown if\n   * the results could not be fulfilled or invalid input/output was specified.\n   */\n  run(\n    query: string | Class<Source>,\n    contextValue?: mixed,\n    variableValues?: ?ObjMap<mixed>,\n    rootValue?: mixed,\n    operationName?: ?string,\n    fieldResolver?: ?GraphQLFieldResolver<any,any>\n  ): ExecutionResult {\n    return this.constructor.gql.graphqlSync(\n      this.schema,\n      query,\n      this.resolvers || rootValue,\n      contextValue,\n      variableValues,\n      operationName,\n      fieldResolver,\n    )\n  }\n\n  /**\n   * Wrapper for `require('graphql').graphql()` that automatically passes\n   * in the internal `.schema` reference as the first parameter.\n   *\n   * @param {string|Source} query A GraphQL language formatted string\n   * representing the requested operation.\n   * @param {mixed} contextValue a bit of shared context to pass to resolvers\n   * @param {Object} variableValues A mapping of variable name to runtime value\n   * to use for all variables defined in the requestString.\n   * @param {ResolverMap|null} The value provided as the first argument to\n   * resolver functions on the top level type (e.g. the query object type).\n   * @param {string} operationName The name of the operation to use if\n   * requestString contains multiple possible operations. Can be omitted if\n   * requestString contains only one operation.\n   * @param {GraphQLFieldResolver<any, any>} fieldResolver A resolver function\n   * to use when one is not provided by the schema. If not provided, the\n   * default field resolver is used (which looks for a value or method on the\n   * source value with the field's name).\n   * @return {Promise<ExecutionResult>} a Promise contianing the requested\n   * results\n   */\n  async runAsync(\n    query: string | Class<Source>,\n    contextValue?: mixed,\n    variableValues?: ?ObjMap<mixed>,\n    rootValue?: mixed,\n    operationName?: ?string,\n    fieldResolver?: ?GraphQLFieldResolver<any,any>\n  ): Promise<ExecutionResult> {\n    return this.constructor.gql.graphql(\n      this.schema,\n      query,\n      this.resolvers || rootValue,\n      contextValue,\n      variableValues,\n      operationName,\n      fieldResolver,\n    )\n  }\n\n  /**\n   * A little wrapper used to catch any errors thrown when building a schema\n   * from the string SDL representation of a given instance.\n   *\n   * @param {string|Schemata|Source|Class<GraphQLSchema>|ASTNode} sdl an\n   * instance of Schemata, a string of SDL, a Source instance of SDL, a\n   * GraphQLSchema or ASTNode that can be printed as an SDL string\n   * @param {boolean} showError true if the error should be thrown, false if\n   * the error should be silently suppressed\n   * @param {BuildSchemaOptions&ParseOptions} schemaOpts for advanced users,\n   * passing through additional buildSchema() options can be done here\n   * @return {GraphQLSchema|null} null if an error occurs and errors are not\n   * surfaced or a valid GraphQLSchema object otherwise\n   */\n  static buildSchema(\n    sdl: string\n      | Class<Source>\n      | Class<Schemata>\n      | Class<GraphQLSchema>\n      | ASTNode,\n    showError: boolean = false,\n    schemaOpts: BuildSchemaOptions & ParseOptions = undefined\n  ): ?GraphQLSchema {\n    try {\n      debug_log('[static buildSchema()] normalizing source')\n      let source = normalizeSource(sdl)\n\n      debug_log('[static buildSchema()] building schema')\n      return this.gql.buildSchema(source, schemaOpts)\n    }\n    catch (e) {\n      debug_log('[static buildSchema()] failed to build!')\n      debug_trace('[static buildSchema()] ', e)\n      if (showError) { throw e }\n      return null\n    }\n  }\n\n  /**\n   * A little wrapper used to catch any errors thrown when parsing Schemata for\n   * ASTNodes. If showError is true, any caught errors are thrown once again.\n   *\n   * @param {string|Schemata|Source|Class<GraphQLSchema>|ASTNode} sdl an\n   * instance of Schemata, a string of SDL, a Source instance of SDL, a\n   * GraphQLSchema or ASTNode that can be printed as an SDL string\n   * @param {boolean} showError if true, any caught errors will be thrown once\n   * again\n   * @param {boolean} enhance a generator keyed with `Symbol.iterator` is set\n   * on the resulting astNode object allowing the resulting `.ast` value to\n   * be iterable. The code iterates over each definition of the resulting\n   * DocumentNode. This behavior defaults to true and should not have any ill\n   * effects on code expecting vanilla ASTNode objects\n   * @return {ASTNode|null} null if an error occurs and errors are suppressed,\n   * a top level Document ASTNode otherwise\n   */\n  static parse(\n    sdl: string | Class<Schemata> | Class<Source> | Class<GraphQLSchema>,\n    showError: boolean = false,\n    enhance: boolean = true\n  ): ?ASTNode {\n    try {\n      debug_log('[static parse()] normalizing source')\n      let source = normalizeSource(sdl)\n\n      debug_log('[static parse()] parsing')\n      let node = this.gql.parse(source)\n\n      if (enhance) {\n        debug_log('[static parse()] enhancing')\n        node[Symbol.iterator] = function *() {\n          for (let node of this.definitions) {\n            yield node\n          }\n        }\n      }\n\n      return node\n    }\n    catch (e) {\n      debug_log('[static parse()] failed to parse')\n      debug_trace('[static parse()] ', e)\n      if (showError) { throw e }\n      return null\n    }\n  }\n\n  /**\n   * A little wrapper used to catch any errors thrown when printing an ASTNode\n   * to string form using `require('graphql').print()`. If `showError` is true\n   * any thrown errors will be rethrown, otherwise null is returned instead.\n   *\n   * Should all go as planned, an instance of Schemata wrapped with the printed\n   * SDL will be returned.\n   *\n   * @since 1.7\n   *\n   * @param {ASTNode|Class<GraphQLSchema>} ast an ASTNode, usually a\n   * DocumentNode generated with some version of `require('graphql').parse()`.\n   * If an instance of GraphQLSchema is supplied, `printSchema()` is used\n   * instead of `print()`\n   * @param {boolean} showError if true, any caught errors will be thrown once\n   * again\n   * @return {Schemata|null} null if an error occurs (and showError is false)\n   * or an instance of Schemata wrapping the resulting SDL string from the\n   * print operation\n   */\n  static print(\n    ast: ASTNode | Class<GraphQLSchema>,\n    showError: boolean = false\n  ): ?Schemata {\n    try {\n      let source\n\n      if (ast instanceof GraphQLSchema) {\n        debug_log('[static print()] printing schema')\n        source = this.gql.printSchema(ast)\n      }\n      else {\n        debug_log('[static print()] printing ASTNode')\n        source = this.gql.print(ast)\n      }\n\n      debug_log('[static print()] creating new Schemata from print')\n      return Schemata.from(source)\n    }\n    catch (e) {\n      debug_log('[static print()] failed to print')\n      debug_trace('[static print()] ', e)\n      if (showError) { throw e }\n      return null\n    }\n  }\n\n  /**\n   * A simple pass thru used within the class to reference graphql methods\n   * and classes.\n   *\n   * @return {mixed} the results of `require('graphql')`\n   */\n  static get gql(): mixed { return require('graphql') }\n\n  /**\n   * Shorthand way of invoking `new Schemata()`\n   *\n   * @param {string|Schemata|Source|Class<GraphQLSchema>|ASTNode} typeDefs an\n   * instance of Schemata, a string of SDL, a Source instance of SDL, a\n   * GraphQLSchema or ASTNode that can be printed as an SDL string\n   * @param {ResolverMap} resolvers an object containing field resolvers for\n   * for the schema represented with this string. [Optional]\n   * @param {boolean} buildResolvers if this flag is set to true, build a set\n   * of resolvers after the rest of the instance is initialized and set the\n   * results on the `.resolvers` property of the newly created instance. If\n   * buildResolvers is the string \"all\", then a resolver for each field not\n   * defined will be returned with a `defaultFieldResolver` as its value\n   * @param {boolean} flattenResolvers if true, and if `buildResolvers` is true,\n   * then make an attempt to flatten the root types to the base of the\n   * resolver map object.\n   * @return {Schemata} an instance of Schemata\n   */\n  static from(\n    typeDefs: string\n      | Class<Source>\n      | Class<Schemata>\n      | Class<GraphQLSchema>\n      | ASTNode,\n    resolvers: ?ResolverMap = null,\n    buildResolvers: boolean | string = false,\n    flattenResolvers: boolean = false,\n  ): Class<Schemata> {\n    return new this(typeDefs, resolvers, buildResolvers, flattenResolvers)\n  }\n\n  /**\n   * Constant used with `forEachOf()` that signifies you wish to iterate\n   * over every available type within the schema.\n   *\n   * @type {number}\n   */\n  static get ALL(): number { return ALL }\n\n  /**\n   * Constant used with `forEachOf()` that signifies you wish to iterate\n   * over every available type within the schema.\n   *\n   * @type {number}\n   */\n  static get TYPES(): number { return TYPES }\n\n  /**\n   * Constant used with `forEachOf()` that signifies you wish to iterate\n   * over every available interface within the schema.\n   *\n   * @type {number}\n   */\n  static get INTERFACES(): number { return INTERFACES }\n\n  /**\n   * Constant used with `forEachOf()` that signifies you wish to iterate\n   * over every available enum within the schema.\n   *\n   * @type {number}\n   */\n  static get ENUMS(): number { return ENUMS }\n\n  /**\n   * Constant used with `forEachOf()` that signifies you wish to iterate\n   * over every available union within the schema.\n   *\n   * @type {number}\n   */\n  static get UNIONS(): number { return UNIONS }\n\n  /**\n   * Constant used with `forEachOf()` that signifies you wish to iterate\n   * over every available scalar within the schema.\n   *\n   * @type {number}\n   */\n  static get SCALARS(): number { return SCALARS }\n\n  /**\n   * Constant used with `forEachOf()` that signifies you wish to iterate\n   * over every available root type; Query, Mutation and Subscription\n   *\n   * @type {number}\n   */\n  static get ROOT_TYPES(): number { return ROOT_TYPES }\n\n  /**\n   * Constant used with `forEachOf()` that signifies you wish to iterate\n   * over every available GraphQLInputObjectType within the schema.\n   *\n   * @type {number}\n   */\n  static get INPUT_TYPES(): number { return INPUT_TYPES }\n\n  /**\n   * Constant used with `forEachOf()` that signifies you also wish to\n   * iterate over the meta types. These are denoted by a leading double\n   * underscore.\n   *\n   * Can be OR'ed together such as `Schemata.TYPES | Schemata.HIDDEN`\n   *\n   * @type {number}\n   */\n  static get HIDDEN(): number { return HIDDEN }\n}\n\n/**\n * To complete the ResolverMap type, we define a string key mapped to either\n * a function or a nested `ResolverMap`.\n *\n * @type {ResolverMap}\n */\nexport type ResolverMap = { [string]: Function | ResolverMap }\n\n/**\n * All resolvers are passed four parameters. This object contains all four\n * of those parameters.\n *\n * @type {ResolverArgs}\n */\nexport type ResolverArgs = {\n  source: mixed,\n  args: mixed,\n  context: mixed,\n  info: GraphQLResolveInfo\n}\n\n/**\n * A function that takes an option that conforms to `ResolverArgs`. The values\n * passed in must be passed back, or variations of the same type. The idea is\n * to allow the values to be modified, viewed or parsed before merged resolvers\n * are bound with these values.\n *\n * @param  {ResolverArgs} args an object with the four arguments passed to each\n * resolver so that they can be modified before used to wrap existing resolvers\n * after a merge.\n * @return {ResolverArgs} see above\n */\nexport type ResolverArgsTransformer = (args: ResolverArgs) => ResolverArgs\n\n/**\n * A flow type definition of an object containing one or more resolver\n * injector functions\n *\n * @see ResolverArgsTransformer\n * @type {MergeOptionsConfig}\n */\nexport type MergeOptionsConfig = {\n  resolverInjectors: ResolverArgsTransformer | Array<ResolverArgsTransformer>\n}\n\n/**\n * A `MergeOptionsConfig` object with an empty array of\n * `ResolverArgsTransformer` instances\n *\n * @type {MergeOptionsConfig}\n */\nexport const DefaultMergeOptions: MergeOptionsConfig = {\n  resolverInjectors: []\n}\n\n/**\n * Loops over the `resolverInjectors` in the supplied config object and\n * lets each supplied function have a pass to inspect or modify the parameters\n * that will be used to bind future resolver functions.\n *\n * @param {MergeOptionsConfig} config a config object with an array of\n * `ResolverArgsTransformer` functions\n * @param {ResolverArgs} args an object with `source`, `args`, `context`\n * and `info`\n * @return {ResolverArgs} a resulting object with `source`, `args`,\n * `context` and `info`\n */\nexport function runInjectors(\n  config: MergeOptionsConfig,\n  resolverArgs: ResolverArgs\n): ResolverArgs {\n  let args: ResolverArgs\n\n  if (!Array.isArray(config.resolverInjectors)) {\n    config.resolverInjectors = [config.resolverInjectors]\n  }\n\n  for (let injector of config.resolverInjectors) {\n    args = injector(resolverArgs)\n  }\n\n  return args\n}\n\n/**\n * The merge options config takes the arguments passed into a given `resolve()`\n * function, allowing the implementor to modify the values before passing them\n * back out.\n *\n * This function takes a schema to inject into the info object, or fourth\n * parameter, passed to any resolver. Any `extraConfig` object added in will\n * have its resolverInjectors added to the list to be processed.\n *\n * @param {GraphQLSchema} schema the GraphQLSchema object being inserted\n * @param {MergeOptionsConfig} extraConfig an optional extraConfig option to\n * merge with the resulting output\n * @return {MergeOptionsConfig} a MergeOptionsConfig object that contains at\n * least a single `ResolverArgsTransformer` which injects the supplied `schema`\n * into the `info` object.\n */\nexport function SchemaInjectorConfig(\n  schema: Class<GraphQLSchema>,\n  extraConfig?: MergeOptionsConfig\n): MergeOptionsConfig {\n  let baseConfig = {\n    resolverInjectors: [\n      function __schema_injector__({source, args, context, info}) {\n        info.schema = schema || info.schema\n        return { source, args, context, info }\n      }\n    ]\n  }\n\n  if (extraConfig) {\n    if (extraConfig.resolverInjectors) {\n      if (!Array.isArray(extraConfig.resolverInjectors)) {\n        baseConfig.resolverInjectors.push(extraConfig.resolverInjectors)\n      }\n      else {\n        baseConfig.resolverInjectors = baseConfig.resolverInjectors.concat(\n          extraConfig.resolverInjectors\n        )\n      }\n    }\n  }\n\n  return baseConfig\n}\n\n\n/**\n * Walk the supplied GraphQLSchema instance and retrieve the resolvers stored\n * on it. These values are then returned with a [typeName][fieldName] pathing\n *\n * @param {GraphQLSchema} schema an instance of GraphQLSchema\n * @return {ResolverMap} an object containing a mapping of typeName.fieldName\n * that links to the resolve() function it is associated within the supplied\n * schema\n */\nexport function stripResolversFromSchema(\n  schema: Class<GraphQLSchema>\n): ?ResolverMap {\n  let resolvers = {}\n\n  if (!schema) {\n    return null\n  }\n\n  forEachField(schema, (\n    type,\n    typeName,\n    typeDirectives,\n    field,\n    fieldName,\n    fieldArgs,\n    fieldDirectives,\n    _schema,\n    context\n  ) => {\n    if (field.resolve) {\n      resolvers[typeName] = resolvers[typeName] || {}\n      resolvers[typeName][fieldName] = resolvers[typeName][fieldName] || {}\n      resolvers[typeName][fieldName] = field.resolve\n    }\n  })\n\n  return resolvers\n}\n\n/**\n * The callback for collision when a field is trying to be merged with an\n * existing field.\n *\n * @param {ASTNode} leftType the ASTNode, usually denoting a type, that will\n * receive the merged type's field from the right\n * @param {FieldNode} leftField the FieldNode denoting the value that should\n * be modified or replaced\n * @param {ASTNode} rightType the ASTNode containing the field to be merged\n * @param {FieldNode} rightField the FieldNode requesting to be merged and\n * finding a conflicting value already present\n * @return {FieldNode} the field to merge into the existing schema layout. To\n * ignore changes, returning the leftField is sufficient enough. The default\n * behavior is to always take the right hand value, overwriting new with old\n */\nexport type FieldMergeResolver = (\n  leftType: ASTNode,\n  leftField: FieldNode,\n  rightType: ASTNode,\n  rightField: FieldNode\n) => FieldNode\n\n/**\n * The callback for collision when a directive is trying to be merged with an\n * existing directive.\n *\n * @param {ASTNode} leftType the ASTNode, usually denoting a type, that will\n * receive the merged type's directive from the right\n * @param {DirectiveNode} leftDirective the DirectiveNode denoting the value\n * that should be modified or replaced\n * @param {ASTNode} rightType the ASTNode containing the directive to be merged\n * @param {DirectiveNode} rightDirective the DirectiveNode requesting to be\n * merged and finding a conflicting value already present\n * @return {DirectiveNode} the directive to merge into the existing schema\n * layout. To ignore changes, returning the leftDirective is sufficient enough.\n * The default behavior is to always take the right hand value, overwriting\n * new with old\n */\nexport type DirectiveMergeResolver = (\n  leftType: ASTNode,\n  leftDirective: DirectiveNode,\n  rightType: ASTNode,\n  rightDirective: DirectiveNode\n) => DirectiveNode\n\n/**\n * The callback for collision when a enum value is trying to be merged with an\n * existing enum value of the same name.\n *\n * @param {ASTNode} leftType the ASTNode, usually denoting a type, that will\n * receive the merged type's enum value from the right\n * @param {EnumValueNode} leftValue the EnumValueNode denoting the value\n * that should be modified or replaced\n * @param {ASTNode} rightType the ASTNode containing the enum value to be\n * merged\n * @param {EnumValueNode} rightValue the EnumValueNode requesting to be\n * merged and finding a conflicting value already present\n * @return {EnumValueNode} the enum value to merge into the existing schema\n * layout. To ignore changes, returning the leftValue is sufficient enough.\n * The default behavior is to always take the right hand value, overwriting\n * new with old\n */\nexport type EnumMergeResolver = (\n  leftType: ASTNode,\n  leftValue: EnumValueNode,\n  rightType: ASTNode,\n  rightValue: EnumValueNode\n) => EnumValueNode\n\n/**\n * The callback for collision when a union type is trying to be merged with an\n * existing union type of the same name.\n *\n * @param {ASTNode} leftType the ASTNode, usually denoting a type, that will\n * receive the merged type's union type from the right\n * @param {NamedTypeNode} leftValue the NamedTypeNode denoting the value\n * that should be modified or replaced\n * @param {ASTNode} rightType the ASTNode containing the union type to be\n * merged\n * @param {NamedTypeNode} rightValue the NamedTypeNode requesting to be\n * merged and finding a conflicting value already present\n * @return {NamedTypeNode} the union type to merge into the existing schema\n * layout. To ignore changes, returning the leftUnion is sufficient enough.\n * The default behavior is to always take the right hand value, overwriting\n * new with old\n */\nexport type UnionMergeResolver = (\n  leftType: ASTNode,\n  leftUnion: NamedTypeNode,\n  rightType: ASTNode,\n  rightUnion: NamedTypeNode\n) => NamedTypeNode\n\n/**\n * A callback for to resolve merge conflicts with custom scalar types defined\n * by the user.\n *\n * @param {ScalarTypeDefinitionNode} leftScalar the definition node found when\n * parsing ASTNodes. This is the existing value that conflicts with the to be\n * merged value\n * @param {GraphQLScalarTypeConfig} leftConfig *if* there is a resolver defined\n * for the existing ScalarTypeDefinitionNode it will be provided here. If this\n * value is null, there is no availabe config with serialize(), parseValue() or\n * parseLiteral() to work with.\n * @param {ScalarTypeDefinitionNode} rightScalar the definition node found when\n * parsing ASTNodes. This is to be merged value that conflicts with the\n * existing value\n * @param {GraphQLScalarTypeConfig} rightConfig *if* there is a resolver\n * defined for the existing ScalarTypeDefinitionNode it will be provided here.\n * If this value is null, there is no availabe config with serialize(),\n * parseValue() or parseLiteral() to work with.\n * @return {GraphQLScalarTypeConfig} whichever type config or resolver was\n * desired should be returned here.\n *\n * @see https://www.apollographql.com/docs/graphql-tools/scalars.html\n * @see http://graphql.org/graphql-js/type/#graphqlscalartype\n */\nexport type ScalarMergeResolver = (\n  leftScalar: ScalarTypeDefinitionNode,\n  leftConfig: GraphQLScalarTypeConfig,\n  rightScalar: ScalarTypeDefinitionNode,\n  rightConfig: GraphQLScalarTypeConfig\n) => GraphQLScalarTypeConfig\n\n/**\n * An object that specifies the various types of resolvers that might occur\n * during a given conflict resolution\n */\nexport type ConflictResolvers = {\n  /** A handler for resolving fields in matching types */\n  fieldMergeResolver?: FieldMergeResolver,\n\n  /** A handler for resolving directives in matching types */\n  directiveMergeResolver?: DirectiveMergeResolver,\n\n  /** A handler for resolving conflicting enum values */\n  enumValueMergeResolver?: EnumMergeResolver,\n\n  /** A handler for resolving type values in unions */\n  typeValueMergeResolver?: UnionMergeResolver,\n\n  /** A handler for resolving scalar config conflicts in custom scalars */\n  scalarMergeResolver?: ScalarMergeResolver\n}\n\n/** @type {Symbol} a unique symbol used as a key to all instance sdl strings */\nexport const TYPEDEFS_KEY = Symbol()\n\n/** @type {Symbol} a constant symbol used as a key to a flag for express-gql */\nexport const GRAPHIQL_FLAG = Symbol.for('superfluous graphiql flag')\n\n/** @type {Symbol} a unique symbol used as a key to all instance `WeakMap`s */\nexport const MAP = Symbol()\n\n/** @type {Symbol} a key used to store the __executable__ flag on a schema */\nexport const EXE = Symbol()\n\n/** @type {Object} a key used to store a resolver object in a WeakMap */\nconst wmkResolvers = Object(Symbol('GraphQL Resolvers storage key'))\n\n/** @type {Object} a key used to store an internal schema in a WeakMap */\nconst wmkSchema = Object(Symbol('GraphQLSchema storage key'))\n\n/**\n * This is a `Symbol` key to a `WeakSet` of `ExtendedResolverMap` instances,\n * each of which have at least three properties:\n *\n *  - schema\n *  - sdl\n *  - resolvers\n *\n * One of these are created and added to the set whenever a mergeSchema is\n * performed. On each subsequent mergeSDL/Schema a new instance is added such\n * that new versions exist to be wrapped anew\n *\n * @type {[type]}\n */\nconst wmkPreboundResolvers = Object(Symbol('Resolvers pre-merge-wrapped'))\n\n/**\n * The default field resolver blindly takes returns the right field. This\n * resolver is used when one is not specified.\n *\n * @param {ASTNode} leftType The matching left type indicating conflict\n * @param {FieldNode} leftField The field causing the conflict\n * @param {ASTNode} rightType The matching right type indicating conflict\n * @param {FieldNode} rightField the field cause the conflict\n *\n * @return {FieldNode} the field that should be used after resolution\n */\nexport function DefaultFieldMergeResolver(\n  leftType: ASTNode,\n  leftField: FieldNode,\n  rightType: ASTNode,\n  rightField: FieldNode\n): FieldNode {\n  return rightField\n}\n\n/**\n * The default directive resolver blindly takes returns the right field. This\n * resolver is used when one is not specified.\n *\n * @param {ASTNode} leftType The matching left type indicating conflict\n * @param {DirectiveNode} leftDirective The field causing the conflict\n * @param {ASTNode} rightType The matching right type indicating conflict\n * @param {DirectiveNode} rightDirective the field cause the conflict\n *\n * @return {DirectiveNode} the directive that should be used after resolution\n */\nexport function DefaultDirectiveMergeResolver(\n  leftType: ASTNode,\n  leftDirective: DirectiveNode,\n  rightType: ASTNode,\n  rightDirective: DirectiveNode\n): DirectiveNode {\n  return rightDirective\n}\n\n/**\n * The default field resolver blindly takes returns the right field. This\n * resolver is used when one is not specified.\n *\n * @param {ASTNode} leftType The matching left type indicating conflict\n * @param {DirectiveNode} leftDirective The field causing the conflict\n * @param {ASTNode} rightType The matching right type indicating conflict\n * @param {DirectiveNode} rightDirective the field cause the conflict\n *\n * @return {DirectiveNode} the directive that should be used after resolution\n */\nexport function DefaultEnumMergeResolver(\n  leftType: ASTNode,\n  leftValue: EnumValueNode,\n  rightType: ASTNode,\n  rightValue: EnumValueNode\n): EnumValueNode {\n  return rightValue\n}\n\n/**\n * The default union resolver blindly takes returns the right type. This\n * resolver is used when one is not specified.\n *\n * @param {ASTNode} leftType The matching left type indicating conflict\n * @param {NamedTypeNode} leftUnion The named node causing the conflict\n * @param {ASTNode} rightType The matching right type indicating conflict\n * @param {NamedTypeNode} rightUnion the named node cause the conflict\n *\n * @return {NamedTypeNode} the directive that should be used after resolution\n */\nexport function DefaultUnionMergeResolver(\n  leftType: ASTNode,\n  leftUnion: NamedTypeNode,\n  rightType: ASTNode,\n  rightUnion: NamedTypeNode\n): NamedTypeNode {\n  return rightUnion\n}\n\n/**\n * The default scalar merge resolver returns the right config when there is\n * one, otherwise the left one or null will be the default result. This is\n * slightly different behavior since resolvers for scalars are not always\n * available.\n *\n * @param {GraphQLScalarTypeConfig} leftConfig *if* there is a resolver defined\n * for the existing ScalarTypeDefinitionNode it will be provided here. If this\n * value is null, there is no availabe config with serialize(), parseValue() or\n * parseLiteral() to work with.\n * @param {ScalarTypeDefinitionNode} rightScalar the definition node found when\n * parsing ASTNodes. This is to be merged value that conflicts with the\n * existing value\n * @param {GraphQLScalarTypeConfig} rightConfig *if* there is a resolver\n * defined for the existing ScalarTypeDefinitionNode it will be provided here.\n * If this value is null, there is no availabe config with serialize(),\n * parseValue() or parseLiteral() to work with.\n * @return {GraphQLScalarTypeConfig} whichever type config or resolver was\n * desired should be returned here.\n *\n * @see https://www.apollographql.com/docs/graphql-tools/scalars.html\n * @see http://graphql.org/graphql-js/type/#graphqlscalartype\n */\nexport function DefaultScalarMergeResolver(\n  leftScalar: ScalarTypeDefinitionNode,\n  leftConfig: GraphQLScalarTypeConfig,\n  rightScalar: ScalarTypeDefinitionNode,\n  rightConfig: GraphQLScalarTypeConfig\n): GraphQLScalarTypeConfig {\n  return rightConfig ? rightConfig : (leftConfig || null)\n}\n\n/**\n * In order to facilitate merging, there needs to be some contingency plan\n * for what to do when conflicts arise. This object specifies one of each\n * type of resolver. Each simply takes the right-hand value.\n *\n * @type {Object}\n */\nexport const DefaultConflictResolvers: ConflictResolvers = {\n  /** A handler for resolving fields in matching types */\n  fieldMergeResolver: DefaultFieldMergeResolver,\n\n  /** A handler for resolving directives in matching types */\n  directiveMergeResolver: DefaultDirectiveMergeResolver,\n\n  /** A handler for resolving conflicting enum values */\n  enumValueMergeResolver: DefaultEnumMergeResolver,\n\n  /** A handler for resolving type values in unions */\n  typeValueMergeResolver: DefaultUnionMergeResolver,\n\n  /** A handler for resolving scalar configs in custom scalars */\n  scalarMergeResolver: DefaultScalarMergeResolver\n};\n\nconst subTypeResolverMap: Map<string, Function> = new Map()\nsubTypeResolverMap.set('fields', 'fieldMergeResolver')\nsubTypeResolverMap.set('directives', 'directiveMergeResolver')\nsubTypeResolverMap.set('values', 'enumValueMergeResolver')\nsubTypeResolverMap.set('types', 'typeValueMergeResolver')\nsubTypeResolverMap.set('scalars', 'scalarMergeResolver')\n\n/**\n * Compares and combines a subset of ASTNode fields. Designed to work on all\n * the various types that might have a merge conflict.\n *\n * @param {string} subTypeName the name of the field type; one of the following\n * values: 'fields', 'directives', 'values', 'types'\n * @param {ASTNode} lType the lefthand type containing the subtype to compare\n * @param {ASTNode} lSubType the lefthand subtype; fields, directive, value or\n * named union type\n * @param {ASTNode} rType the righthand type containing the subtype to compare\n * @param {ASTNode} rSubType the righthand subtype; fields, directive, value or\n * named union type\n */\nfunction combineTypeAndSubType(\n  subTypeName: string,\n  lType: ASTNode,\n  rType: ASTNode,\n  conflictResolvers: ConflictResolvers = DefaultConflictResolvers\n): void {\n  if (rType[subTypeName]) {\n    for (let rSubType of rType[subTypeName]) {\n      let lSubType = lType[subTypeName].find(\n        f => f.name.value == rSubType.name.value\n      )\n\n      if (!lSubType) {\n        lType[subTypeName].push(rSubType)\n        continue\n      }\n\n      let resolver = subTypeResolverMap.get(subTypeName) || 'fieldMergeResolver'\n      let resultingSubType = conflictResolvers[resolver](\n        lType, lSubType, rType, rSubType\n      )\n      let index = lType.fields.indexOf(lSubType)\n\n      lType[subTypeName].splice(index, 1, resultingSubType)\n    }\n  }\n}\n\n/**\n * Compares a subset of ASTNode fields. Designed to work on all the various\n * types that might have a merge conflict.\n *\n * @param {string} subTypeName the name of the field type; one of the following\n * values: 'fields', 'directives', 'values', 'types'\n * @param {ASTNode} lType the lefthand type containing the subtype to compare\n * @param {ASTNode} lSubType the lefthand subtype; fields, directive, value or\n * named union type\n * @param {ASTNode} rType the righthand type containing the subtype to compare\n * @param {ASTNode} rSubType the righthand subtype; fields, directive, value or\n * named union type\n */\nfunction pareTypeAndSubType(\n  subTypeName: string,\n  lType: ASTNode,\n  rType: ASTNode,\n  resolvers: ResolverMap = {}\n): void {\n  for (let rSubType of rType[subTypeName]) {\n    let lSubType = lType[subTypeName].find(\n      f => f.name.value == rSubType.name.value\n    )\n\n    if (!lSubType) {\n      continue\n    }\n\n    let index = lType.fields.indexOf(lSubType)\n    lType[subTypeName].splice(index, 1)\n\n    if (\n      resolvers[lType.name.value]\n      && resolvers[lType.name.value][lSubType.name.value]\n    ) {\n      delete resolvers[lType.name.value][lSubType.name.value]\n    }\n    else if (resolvers[lSubType.name.value]) {\n      delete resolvers[lSubType.name.value]\n    }\n  }\n}\n\n/**\n * Small function that sorts through the typeDefs value supplied which can be\n * any one of a Schemata instance, GraphQLSchema instance, Source instance or a\n * string.\n *\n * @param {string|Source|Schemata|Class<GraphQLSchema>|ASTNode} typeDefs an\n * instance of Schemata, a string of SDL, a Source instance of SDL, a\n * GraphQLSchema or ASTNode that can be printed as an SDL string\n * @return {string} a string representing the thing supplied as typeDefs\n */\nexport function normalizeSource(\n  typeDefs: string\n    | Class<Source>\n    | Class<Schemata>\n    | Class<GraphQLSchema>\n    | ASTNode,\n  wrap: boolean = false\n): (string | Class<Schemata>) {\n  if (!typeDefs) {\n    throw new Error(inline`\n      normalizeSource(typeDefs): typeDefs was invalid when passed to the\n      function \\`normalizeSource\\`. Please check your code and try again.\n\n      (received: ${typeDefs})\n    `)\n  }\n\n  let source =\n    (typeDefs.body\n      || typeDefs.sdl\n      || (typeof typeDefs === 'string' && typeDefs)\n      || (typeof typeDefs === 'object' && Schemata.print(typeDefs))\n      || (typeDefs instanceof GraphQLSchema\n        ? printSchema(typeDefs)\n        : typeDefs.toString())\n    ).toString()\n\n  return wrap ? Schemata.from(source) : source;\n}\n\nexport default Schemata"]}