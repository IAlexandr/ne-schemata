{"version":3,"sources":["../src/Schemata.js"],"names":["stripResolversFromSchema","DefaultFieldMergeResolver","DefaultDirectiveMergeResolver","DefaultEnumMergeResolver","DefaultUnionMergeResolver","normalizeSource","schema","resolvers","type","typeName","typeDirectives","field","fieldName","fieldArgs","fieldDirectives","_schema","context","resolve","TYPEDEFS_KEY","Symbol","GRAPHIQL_FLAG","for","MAP","EXE","wmkResolvers","Object","wmkSchema","leftType","leftField","rightType","rightField","leftDirective","rightDirective","leftValue","rightValue","leftUnion","rightUnion","DefaultConflictResolvers","fieldMergeResolver","directiveMergeResolver","enumValueMergeResolver","typeValueMergeResolver","subTypeResolverMap","Map","set","combineTypeAndSubType","subTypeName","lType","rType","conflictResolvers","rSubType","lSubType","find","f","name","value","push","resolver","get","resultingSubType","index","fields","indexOf","splice","pareTypeAndSubType","typeDefs","wrap","Error","source","body","sdl","toString","Schemata","from","String","constructor","WeakMap","species","toStringTag","ast","parse","graphiql","keys","length","executableSchema","buildSchema","error","isRootType","t","undefined","Class","forEachField","astNode","rootValue","schemaResolverFor","valid","_type","getType","_field","getFields","schemaFieldByName","validSchema","astTypeByName","validSDL","definitions","astFieldByName","hasFlattenedResolvers","asts","query","mutation","subscription","mergeSDL","schemaLanguage","lAST","rAST","a","kind","endsWith","assign","substring","gql","print","pareSDL","resolverMap","len","values","types","result","mergeSchema","buildResolvers","mergeResolvers","schemata","flattenRootResolversOrFirstParam","extendWith","rootType","hasAnExecutableSchema","e","clearResolvers","clearSchema","inspect","valueOf","forEachOf","fn","suppliedSchema","forEachType","forEachInputObjectType","INPUT_TYPES","forEachUnion","forEachEnum","forEachInterface","forEachScalar","forEachRootType","forEachTypeField","forEachInterfaceField","forEachInputObjectField","run","contextValue","variableValues","operationName","fieldResolver","graphqlSync","runAsync","graphql","showError","schemaOpts","require","ALL","TYPES","INTERFACES","ENUMS","UNIONS","SCALARS","ROOT_TYPES","HIDDEN"],"mappings":"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","file":"Schemata.js","sourceRoot":"src","sourcesContent":["// @flow\n\nimport type {\n  ASTNode,\n  BuildSchemaOptions,\n  DirectiveNode,\n  EnumValueNode,\n  ExecutionResult,\n  FieldNode,\n  GraphQLFieldResolver,\n  NamedTypeNode,\n  ObjMap,\n  ParseOptions,\n  Source,\n} from 'graphql'\n\nimport { GraphQLSchema, GraphQLObjectType, printSchema } from 'graphql'\nimport { inline } from 'ne-tag-fns'\nimport merge from 'deepmerge'\n\nimport {\n  forEachOf,\n  forEachField,\n\n  ALL,\n  TYPES,\n  INTERFACES,\n  ENUMS,\n  UNIONS,\n  SCALARS,\n  ROOT_TYPES,\n  HIDDEN\n} from './forEachOf'\n\nimport type { ForEachOfResolver, ForEachFieldResolver } from './forEachOf'\n\n/**\n * Walk the supplied GraphQLSchema instance and retrieve the resolvers stored\n * on it. These values are then returned with a [typeName][fieldName] pathing\n *\n * @param {GraphQLSchema} schema an instance of GraphQLSchema\n * @return {Object} an object containing a mapping of typeName.fieldName that\n * links to the resolve() function it is associated within the supplied schema\n */\nexport function stripResolversFromSchema(\n  schema: GraphQLSchema\n): ?Object {\n  let resolvers = {}\n\n  if (!schema) {\n    return null\n  }\n\n  forEachField(schema, (\n    type,\n    typeName,\n    typeDirectives,\n    field,\n    fieldName,\n    fieldArgs,\n    fieldDirectives,\n    _schema,\n    context\n  ) => {\n    if (field.resolve) {\n      resolvers[typeName] = resolvers[typeName] || {}\n      resolvers[typeName][fieldName] = resolvers[typeName][fieldName] || {}\n      resolvers[typeName][fieldName] = field.resolve\n    }\n  })\n\n  return resolvers\n}\n\n/**\n * The callback for collision when a field is trying to be merged with an\n * existing field.\n *\n * @param {ASTNode} leftType the ASTNode, usually denoting a type, that will\n * receive the merged type's field from the right\n * @param {FieldNode} leftField the FieldNode denoting the value that should\n * be modified or replaced\n * @param {ASTNode} rightType the ASTNode containing the field to be merged\n * @param {FieldNode} rightField the FieldNode requesting to be merged and\n * finding a conflicting value already present\n * @return {FieldNode} the field to merge into the existing schema layout. To\n * ignore changes, returning the leftField is sufficient enough. The default\n * behavior is to always take the right hand value, overwriting new with old\n */\nexport type FieldMergeResolver = (\n  leftType: ASTNode,\n  leftField: FieldNode,\n  rightType: ASTNode,\n  rightField: FieldNode\n) => FieldNode\n\n/**\n * The callback for collision when a directive is trying to be merged with an\n * existing directive.\n *\n * @param {ASTNode} leftType the ASTNode, usually denoting a type, that will\n * receive the merged type's directive from the right\n * @param {DirectiveNode} leftDirective the DirectiveNode denoting the value\n * that should be modified or replaced\n * @param {ASTNode} rightType the ASTNode containing the directive to be merged\n * @param {DirectiveNode} rightDirective the DirectiveNode requesting to be\n * merged and finding a conflicting value already present\n * @return {DirectiveNode} the directive to merge into the existing schema\n * layout. To ignore changes, returning the leftDirective is sufficient enough.\n * The default behavior is to always take the right hand value, overwriting\n * new with old\n */\nexport type DirectiveMergeResolver = (\n  leftType: ASTNode,\n  leftDirective: DirectiveNode,\n  rightType: ASTNode,\n  rightDirective: DirectiveNode\n) => DirectiveNode\n\n/**\n * The callback for collision when a enum value is trying to be merged with an\n * existing enum value of the same name.\n *\n * @param {ASTNode} leftType the ASTNode, usually denoting a type, that will\n * receive the merged type's enum value from the right\n * @param {EnumValueNode} leftValue the EnumValueNode denoting the value\n * that should be modified or replaced\n * @param {ASTNode} rightType the ASTNode containing the enum value to be\n * merged\n * @param {EnumValueNode} rightValue the EnumValueNode requesting to be\n * merged and finding a conflicting value already present\n * @return {EnumValueNode} the enum value to merge into the existing schema\n * layout. To ignore changes, returning the leftValue is sufficient enough.\n * The default behavior is to always take the right hand value, overwriting\n * new with old\n */\nexport type EnumMergeResolver = (\n  leftType: ASTNode,\n  leftValue: EnumValueNode,\n  rightType: ASTNode,\n  rightValue: EnumValueNode\n) => EnumValueNode\n\n/**\n * The callback for collision when a union type is trying to be merged with an\n * existing union type of the same name.\n *\n * @param {ASTNode} leftType the ASTNode, usually denoting a type, that will\n * receive the merged type's union type from the right\n * @param {NamedTypeNode} leftValue the NamedTypeNode denoting the value\n * that should be modified or replaced\n * @param {ASTNode} rightType the ASTNode containing the union type to be\n * merged\n * @param {NamedTypeNode} rightValue the NamedTypeNode requesting to be\n * merged and finding a conflicting value already present\n * @return {NamedTypeNode} the union type to merge into the existing schema\n * layout. To ignore changes, returning the leftUnion is sufficient enough.\n * The default behavior is to always take the right hand value, overwriting\n * new with old\n */\nexport type UnionMergeResolver = (\n  leftType: ASTNode,\n  leftUnion: NamedTypeNode,\n  rightType: ASTNode,\n  rightUnion: NamedTypeNode\n) => NamedTypeNode\n\n/**\n * An object that specifies the various types of resolvers that might occur\n * during a given conflict resolution\n */\nexport type ConflictResolvers = {\n  /** A handler for resolving fields in matching types */\n  fieldMergeResolver?: FieldMergeResolver,\n\n  /** A handler for resolving directives in matching types */\n  directiveMergeResolver?: DirectiveMergeResolver,\n\n  /** A handler for resolving conflicting enum values */\n  enumValueMergeResolver?: EnumMergeResolver,\n\n  /** A handler for resolving type values in unions */\n  typeValueMergeResolver?: UnionMergeResolver\n}\n\n/** @type {Symbol} a unique symbol used as a key to all instance sdl strings */\nexport const TYPEDEFS_KEY = Symbol()\n\n/** @type {Symbol} a constant symbol used as a key to a flag for express-gql */\nexport const GRAPHIQL_FLAG = Symbol.for('superfluous graphiql flag')\n\n/** @type {Symbol} a unique symbol used as a key to all instance `WeakMap`s */\nexport const MAP = Symbol()\n\n/** @type {Symbol} a key used to store the __executable__ flag on a schema */\nexport const EXE = Symbol()\n\n/** @type {Object} a key used to store a resolver object in a WeakMap */\nconst wmkResolvers = Object(Symbol())\n\n/** @type {Object} a key used to store an internal schema in a WeakMap */\nconst wmkSchema = Object(Symbol())\n\n/**\n * The default field resolver blindly takes returns the right field. This\n * resolver is used when one is not specified.\n *\n * @param {ASTNode} leftType The matching left type indicating conflict\n * @param {FieldNode} leftField The field causing the conflict\n * @param {ASTNode} rightType The matching right type indicating conflict\n * @param {FieldNode} rightField the field cause the conflict\n *\n * @return {FieldNode} the field that should be used after resolution\n */\nexport function DefaultFieldMergeResolver(\n  leftType: ASTNode,\n  leftField: FieldNode,\n  rightType: ASTNode,\n  rightField: FieldNode\n): FieldNode {\n  return rightField\n}\n\n/**\n * The default directive resolver blindly takes returns the right field. This\n * resolver is used when one is not specified.\n *\n * @param {ASTNode} leftType The matching left type indicating conflict\n * @param {DirectiveNode} leftDirective The field causing the conflict\n * @param {ASTNode} rightType The matching right type indicating conflict\n * @param {DirectiveNode} rightDirective the field cause the conflict\n *\n * @return {DirectiveNode} the directive that should be used after resolution\n */\nexport function DefaultDirectiveMergeResolver(\n  leftType: ASTNode,\n  leftDirective: DirectiveNode,\n  rightType: ASTNode,\n  rightDirective: DirectiveNode\n): DirectiveNode {\n  return rightDirective\n}\n\n/**\n * The default field resolver blindly takes returns the right field. This\n * resolver is used when one is not specified.\n *\n * @param {ASTNode} leftType The matching left type indicating conflict\n * @param {DirectiveNode} leftDirective The field causing the conflict\n * @param {ASTNode} rightType The matching right type indicating conflict\n * @param {DirectiveNode} rightDirective the field cause the conflict\n *\n * @return {DirectiveNode} the directive that should be used after resolution\n */\nexport function DefaultEnumMergeResolver(\n  leftType: ASTNode,\n  leftValue: EnumValueNode,\n  rightType: ASTNode,\n  rightValue: EnumValueNode\n): EnumValueNode {\n  return rightValue\n}\n\n/**\n * The default union resolver blindly takes returns the right type. This\n * resolver is used when one is not specified.\n *\n * @param {ASTNode} leftType The matching left type indicating conflict\n * @param {NamedTypeNode} leftUnion The named node causing the conflict\n * @param {ASTNode} rightType The matching right type indicating conflict\n * @param {NamedTypeNode} rightUnion the named node cause the conflict\n *\n * @return {NamedTypeNode} the directive that should be used after resolution\n */\nexport function DefaultUnionMergeResolver(\n  leftType: ASTNode,\n  leftUnion: NamedTypeNode,\n  rightType: ASTNode,\n  rightUnion: NamedTypeNode\n): NamedTypeNode {\n  return rightUnion\n}\n\n/**\n * In order to facilitate merging, there needs to be some contingency plan\n * for what to do when conflicts arise. This object specifies one of each\n * type of resolver. Each simply takes the right-hand value.\n *\n * @type {Object}\n */\nexport const DefaultConflictResolvers: ConflictResolvers = {\n  /** A handler for resolving fields in matching types */\n  fieldMergeResolver: DefaultFieldMergeResolver,\n\n  /** A handler for resolving directives in matching types */\n  directiveMergeResolver: DefaultDirectiveMergeResolver,\n\n  /** A handler for resolving conflicting enum values */\n  enumValueMergeResolver: DefaultEnumMergeResolver,\n\n  /** A handler for resolving type values in unions */\n  typeValueMergeResolver: DefaultUnionMergeResolver\n};\n\nconst subTypeResolverMap: Map<string, Function> = new Map()\nsubTypeResolverMap.set('fields', 'fieldMergeResolver')\nsubTypeResolverMap.set('directives', 'directiveMergeResolver')\nsubTypeResolverMap.set('values', 'enumValueMergeResolver')\nsubTypeResolverMap.set('types', 'typeValueMergeResolver')\n\n/**\n * Compares and combines a subset of ASTNode fields. Designed to work on all\n * the various types that might have a merge conflict.\n *\n * @param {string} subTypeName the name of the field type; one of the following\n * values: 'fields', 'directives', 'values', 'types'\n * @param {ASTNode} lType the lefthand type containing the subtype to compare\n * @param {ASTNode} lSubType the lefthand subtype; fields, directive, value or\n * named union type\n * @param {ASTNode} rType the righthand type containing the subtype to compare\n * @param {ASTNode} rSubType the righthand subtype; fields, directive, value or\n * named union type\n */\nfunction combineTypeAndSubType(\n  subTypeName: string,\n  lType: ASTNode,\n  rType: ASTNode,\n  conflictResolvers: ConflictResolvers = DefaultConflictResolvers\n): void {\n  for (let rSubType of rType[subTypeName]) {\n    let lSubType = lType[subTypeName].find(\n      f => f.name.value == rSubType.name.value\n    )\n\n    if (!lSubType) {\n      lType[subTypeName].push(rSubType)\n      continue\n    }\n\n    let resolver = subTypeResolverMap.get(subTypeName) || 'fieldMergeResolver'\n    let resultingSubType = conflictResolvers[resolver](\n      lType, lSubType, rType, rSubType\n    )\n    let index = lType.fields.indexOf(lSubType)\n\n    lType[subTypeName].splice(index, 1, resultingSubType)\n  }\n}\n\n/**\n * Compares a subset of ASTNode fields. Designed to work on all the various\n * types that might have a merge conflict.\n *\n * @param {string} subTypeName the name of the field type; one of the following\n * values: 'fields', 'directives', 'values', 'types'\n * @param {ASTNode} lType the lefthand type containing the subtype to compare\n * @param {ASTNode} lSubType the lefthand subtype; fields, directive, value or\n * named union type\n * @param {ASTNode} rType the righthand type containing the subtype to compare\n * @param {ASTNode} rSubType the righthand subtype; fields, directive, value or\n * named union type\n */\nfunction pareTypeAndSubType(\n  subTypeName: string,\n  lType: ASTNode,\n  rType: ASTNode,\n  resolvers: Object = {}\n): void {\n  for (let rSubType of rType[subTypeName]) {\n    let lSubType = lType[subTypeName].find(\n      f => f.name.value == rSubType.name.value\n    )\n\n    if (!lSubType) {\n      continue\n    }\n\n    let index = lType.fields.indexOf(lSubType)\n    lType[subTypeName].splice(index, 1)\n\n    if (\n      resolvers[lType.name.value]\n      && resolvers[lType.name.value][lSubType.name.value]\n    ) {\n      delete resolvers[lType.name.value][lSubType.name.value]\n    }\n    else if (resolvers[lSubType.name.value]) {\n      delete resolvers[lSubType.name.value]\n    }\n  }\n}\n\n/**\n * Small function that sorts through the typeDefs value supplied which can be\n * any one of a Schemata instance, GraphQLSchema instance, Source instance or a\n * string.\n *\n * @param {string|Source|Schemata|GraphQLSchema} typeDefs the input source from\n * which to create a Schemata string\n * @return {string} a string representing the thing supplied as typeDefs\n */\nexport function normalizeSource(\n  typeDefs: string | Source | Schemata | GraphQLSchema,\n  wrap: boolean = false\n): (string | Schemata) {\n  if (!typeDefs) {\n    throw new Error(inline`\n      normalizeSource(typeDefs): typeDefs was invalid when passed to the\n      function \\`normalizeSource\\`. Please check your code and try again.\n\n      (received: ${typeDefs})\n    `)\n  }\n\n  let source = typeDefs.body\n    || typeDefs.sdl\n    || (typeof typeDefs === 'string' && typeDefs)\n    || (typeDefs instanceof GraphQLSchema\n      ? printSchema(typeDefs)\n      : typeDefs.toString())\n\n  return wrap ? Schemata.from(source) : source;\n}\n\n/**\n * A small `String` extension that makes working with SDL/IDL text far easier\n * in both your own libraries as well as in a nodeJS REPL. Built-in to what\n * appears to be a normal String for all intents and purposes, are the ability\n * to transform the string into a set of AST nodes, a built schema or back to\n * the SDL string.\n *\n * @class  Schemata\n */\nexport class Schemata extends String {\n  /**\n   * Creates a new `String`, presumably of SDL or IDL. The getter `.valid`\n   * will provide some indication as to whether or not the code is valid.\n   *\n   * @constructor\n   * @memberOf Schemata\n   *\n   * @param {string|Schemata|Source|GraphQLSchema} typeDefs an instance\n   * of Schemata, a string of SDL, a Source instance of SDL or a GraphQLSchema\n   * that can be printed as an SDL string\n   * @param {Object} resolvers an object containing field resolvers for\n   * for the schema represented with this string. [Optional]\n   */\n  constructor(\n    typeDefs: string | Source | Schemata | GraphQLSchema,\n    resolvers: ?Object = null\n  ) {\n    super(normalizeSource(typeDefs))\n\n    resolvers = (\n      resolvers\n      || typeDefs instanceof Schemata && typeDefs.resolvers\n      || typeDefs instanceof GraphQLSchema && stripResolversFromSchema(typeDefs)\n      || null\n    )\n\n    this[GRAPHIQL_FLAG] = true\n    this[TYPEDEFS_KEY] = normalizeSource(typeDefs)\n    this[MAP] = new WeakMap()\n    this[MAP].set(\n      wmkSchema,\n      typeDefs instanceof GraphQLSchema ? typeDefs : null\n    )\n    this[MAP].set(wmkResolvers, resolvers)\n\n    // Mark a schema passed to use in the constructor as an executable schema\n    // to prevent any replacement of the value by getters that generate a\n    // schema from the SDL\n    if (this[MAP].get(wmkSchema)) {\n      this[MAP].get(wmkSchema)[EXE] = true\n      this[MAP].get(wmkSchema)[Symbol.for('constructor-supplied-schema')] = true\n    }\n  }\n\n  /**\n   * Symbol.species ensures that any String methods used on this instance will\n   * result in a Schemata instance rather than a String. NOTE: this does not\n   * work as expected in current versions of node. This bit of code here is\n   * basically a bit of future proofing for when Symbol.species starts working\n   * with String extended classes\n   *\n   * @type {Function}\n   */\n  static get [Symbol.species](): Function { return Schemata }\n\n  /**\n   * Ensures that instances of Schemata report internally as Schemata object.\n   * Specifically using things like `Object.prototype.toString`.\n   *\n   * @type {string}\n   */\n  get [Symbol.toStringTag](): string { return this.constructor.name }\n\n  /**\n   * Returns the AST nodes for this snippet of SDL. It will throw an error\n   * if the string is not valid SDL/IDL.\n   *\n   * @return {ASTNode} any valid ASTNode supported by GraphQL\n   */\n  get ast(): ASTNode { return this.constructor.parse(this.sdl, false) }\n\n  /**\n   * Retrieves the `graphiql` flag, which defaults to true. This flag can\n   * make setting up an endpoint from a Schemata instance easier with express-graphql\n   *\n   * @type {boolean}\n   */\n  get graphiql(): boolean { return this[GRAPHIQL_FLAG] }\n\n  /**\n   * Setter to alter the default 'true' flag to make an Schemata instance a\n   * valid single argument to functions like `graphqlHTTP()` from express\n   * GraphQL.\n   *\n   * NOTE: this flag means nothing to the Schemata class but might be useful in\n   * your project.\n   *\n   * @type {boolean} true if graphiql should be started; false otherwise\n   */\n  set graphiql(value: boolean): void { this[GRAPHIQL_FLAG] = value }\n\n  /**\n   * Returns a GraphQLSchema object. Note this will fail and throw an error\n   * if there is not at least one Query, Subscription or Mutation type defined.\n   * If there is no stored schema, and there are resolvers, an executable\n   * schema is returned instead.\n   *\n   * @return {GraphQLSchema} an instance of GraphQLSchema if valid SDL\n   */\n  get schema(): GraphQLSchema {\n    if (this[MAP].get(wmkSchema)) {\n      return this[MAP].get(wmkSchema)\n    }\n\n    try {\n      if (this.resolvers && Object.keys(this.resolvers).length) {\n        return this.executableSchema\n      }\n      else {\n        this[MAP].set(wmkSchema, this.constructor.buildSchema(this.sdl, true))\n        this[MAP].get(wmkSchema)[EXE] = false\n      }\n    }\n    catch (error) {\n      return null\n    }\n\n    return this[MAP].get(wmkSchema)\n  }\n\n  /**\n   * Sets a GraphQLSchema object on the internal weak map store.\n   *\n   * @param {GraphQLSchema} schema an instance of GraphQLSchema instance to\n   * store on the internal weak map. Any schema stored here will be modified\n   * by methods that do so.\n   */\n  set schema(schema: ?GraphQLSchema): void {\n    this[MAP].set(wmkSchema, schema)\n  }\n\n  /**\n   * Returns a GraphQLSchema object, pre-bound, to the associated resolvers\n   * methods in `.resolvers`. If `.resolvers` is falsey, an error will be\n   * thrown.\n   *\n   * @return {GraphQLSchema} an instance of GraphQLSchema with pre-bound\n   * resolvers\n   */\n  get executableSchema(): GraphQLSchema {\n    const isRootType = (t) => {\n      if (t === undefined || t === null || !t) {\n        return false;\n      }\n\n      let name = (typeof t.name === 'string') ? t.name : t.name.value\n\n      return ((t instanceof GraphQLObjectType) &&\n        (t.name === 'Query'\n        || t.name === 'Mutation'\n        || t.name === 'Subscription')\n      )\n    }\n    const Class = this.constructor\n    const resolvers = this.resolvers\n    let schema\n\n    if (this[MAP].get(wmkSchema) && this.resolvers) {\n      schema = this[MAP].get(wmkSchema)\n\n      if (schema && schema[EXE]) {\n        return schema\n      }\n    }\n\n    try {\n      this[MAP].set(wmkSchema, (schema = Class.buildSchema(this.sdl, true)))\n    }\n    catch (error) {\n      return null\n    }\n\n    this.forEachField((\n      type, typeName, typeDirectives,\n      field, fieldName, fieldArgs, fieldDirectives,\n      schema, context\n    ) => {\n      if (!resolvers) { return }\n\n      if (isRootType(type) && resolvers[fieldName]) {\n        field.resolve = resolvers[fieldName]\n        field.astNode.resolve = resolvers[fieldName]\n      }\n\n      if (resolvers[typeName] && resolvers[typeName][fieldName]) {\n        field.resolve = resolvers[typeName][fieldName]\n        field.astNode.resolve = resolvers[typeName][fieldName]\n      }\n    })\n\n    schema[EXE] = true\n    this[MAP].set(wmkSchema, schema)\n\n    return schema;\n  }\n\n  /**\n   * Returns the string this instance was generated with.\n   *\n   * @return {string} the string this class instance represents\n   */\n  get sdl(): string { return this[TYPEDEFS_KEY] }\n\n  /**\n   * A synonym or alias for `.sdl`. Placed here for the express purpose of\n   * destructuing when used with Apollo's makeExecutableSchema or other\n   * libraries expecting values of the same name\n   *\n   * i.e.\n   *   // sdl.typeDefs and sdl.resolvers will be where the function expects\n   *   let schema = require('graphql-tools').makeExecutableSchema(sdl)\n   *\n   * @return {string} a string of SDL/IDL for use with graphql\n   */\n  get typeDefs(): string { return this.sdl }\n\n  /**\n   * A synonym or alias for `.resolvers`. Placed here for the express purpose\n   * of destructuing when used with express-graphql or other libraries\n   * expecting values of the same name to map to the resolvers function\n   *\n   * @return {Object} an object of functions or null if one is not set\n   */\n  get rootValue(): Object { return this.resolvers }\n\n  /**\n   * Returns any resolvers function object associated with this instance.\n   *\n   * @return {Object} an object containing field resolvers or null if none\n   * are stored within\n   */\n  get resolvers(): Object { return this[MAP].get(wmkResolvers) }\n\n  /**\n   * A method to fetch a particular field resolver from the schema represented\n   * by this Schemata instance.\n   *\n   * @param {string} type the name of the type desired\n   * @param {string} field the name of the field containing the resolver\n   * @return {Function} the function resolver for the type and field in\n   * question\n   */\n  schemaResolverFor(type: string, field: string): ?Function {\n    if (\n      !this.resolvers\n      || !Object.keys(this.resolvers).length\n      || !this.valid\n    ) {\n      return null\n    }\n\n    let _type = this.executableSchema.getType(type)\n    let _field = _type.getFields() && _type.getFields()[field] || null\n    let resolve = _field && _field.resolve || null\n\n    return resolve\n  }\n\n  /**\n   * Builds a schema based on the SDL in the instance and then parses it to\n   * fetch a named field in a named type. If either the type or field are\n   * missing or if the SDL cannot be built as a schema, null is returned.\n   *\n   * @param {string} type the name of a type\n   * @param {string} field the name of a field contained in the above type\n   * @return {FieldNode} the field reference in the type and field supplied\n   */\n  schemaFieldByName(type: string, field: string): FieldNode {\n    if (!this.validSchema) { return null }\n\n    let _type = this.schema.getType(type)\n    let _field = _type.getFields() && _type.getFields()[field] || null\n\n    return _field\n  }\n\n  /**\n   * For SDL that doesn't properly build into a GraphQLSchema, it can still be\n   * parsed and searched for a type by name.\n   *\n   * @param {string} type the name of a type\n   * @return {FieldNode} the field reference in the type and field supplied\n   */\n  astTypeByName(type: string): ASTNode {\n    if (!this.validSDL) { return null }\n\n    let _type = this.ast.definitions.find(f => f.name.value === type)\n\n    return _type\n  }\n\n  /**\n   * For SDL that doesn't properly build into a GraphQLSchema, it can still be\n   * searched for a type and field.\n   *\n   * @param {string} type the name of a type\n   * @param {string} field the name of a field contained in the above type\n   * @return {FieldNode} the field reference in the type and field supplied\n   */\n  astFieldByName(type: string, field: string): FieldNode {\n    if (!this.validSDL) { return null }\n\n    let _type = this.ast.definitions.find(f => f.name.value === type)\n    let _field = _type && _type.fields.find(f => f.name.value === field) || null\n\n    return _field\n  }\n\n  /**\n   * Walks the AST for this SDL string and checks for the names of the fields\n   * of each of the root types; Query, Mutation and Subscription. If there are\n   * no root types defined, false is returned.\n   *\n   * If there is at least one root type *and* some resolvers *and* at least one\n   * of the fields of at least one root type is present in the root of the\n   * resolvers map, true is returned. Otherwise, false.\n   *\n   * @return {boolean} true if the defined resolvers have at least one root\n   * type field as a resolver on the root of the resolver map; false otherwise.\n   */\n  get hasFlattenedResolvers(): boolean {\n    let asts = this.validSDL && this.ast.definitions || null\n\n    if (!asts || !this.resolvers) { return false }\n\n    let query = asts.find(f => f.name.value == 'Query')\n    let mutation = asts.find(f => f.name.value == 'Mutation')\n    let subscription = asts.find(f => f.name.value == 'Subscription')\n    let resolvers = this.resolvers\n\n    if (!query && !mutation && !subscription) {\n      return false\n    }\n\n    for (let type of [query, mutation, subscription]) {\n      if (!type || !type.fields) { continue }\n\n      for (let field of type.fields) {\n        if (field.name.value in resolvers) {\n          return true\n        }\n      }\n    }\n\n    return false\n  }\n\n  /**\n   * Merging Schematas are a common feature in the modern world of GraphQL.\n   * Especially when there are multiple teams working in tandem. This feature\n   * supports merging of types, extended types, interfaces, enums, unions,\n   * input object types and directives for all of the above.\n   *\n   * @param {string|Schemata|Source|GraphQLSchema} schemaLanguage an instance\n   * of Schemata, a string of SDL, a Source instance of SDL or a GraphQLSchema\n   * that can be printed as an SDL string to define what to merge with the\n   * values in this object instance\n   * @param {ConflictResolvers} conflictResolvers an object containing up to\n   * four methods, each describing how to handle a conflict when an associated\n   * type of conflict occurs. If no object or method are supplied, the right\n   * hande value always takes precedence over the existing value; replacing it\n   * @return {Schemata} a new instance of Schemata\n   */\n  mergeSDL(\n    schemaLanguage: string | Schemata | Source | GraphQLSchema,\n    conflictResolvers: ?ConflictResolvers = DefaultConflictResolvers\n  ): Schemata {\n    let source = normalizeSource(schemaLanguage, true)\n\n    if (!source) {\n      throw new Error(inline`\n        The call to mergeSDL(schemaLanguage, conflictResolvers) received an\n        invalid value for schemaLanguage. Please check your code and try again.\n        Received ${schemaLanguage}.\n      `)\n    }\n\n    let lAST = this.ast\n    let rAST = source.ast\n\n    for (let rType of rAST.definitions) {\n      let lType = lAST.definitions.find(a => a.name.value == rType.name.value)\n\n      if (\n        rType.kind\n        && rType.kind.endsWith\n        && rType.kind.endsWith('Extension')\n      ) {\n        rType = Object.assign({}, rType)\n        rType.kind =\n          rType.kind.substring(0, rType.kind.length - 9) + 'Definition'\n      }\n\n      if (!lType) {\n        lAST.definitions.push(rType)\n        continue\n      }\n\n      switch (lType.kind) {\n        default:\n        case 'ObjectTypeDefinition':\n        case 'ObjectTypeDefinitionExtension':\n        case 'InterfaceTypeDefinition':\n        case 'InterfaceTypeDefinitionExtension':\n        case 'InputObjectTypeDefinition':\n        case 'InputObjectTypeDefinitionExtension':\n          combineTypeAndSubType('directives', lType, rType, conflictResolvers)\n          combineTypeAndSubType('fields', lType, rType, conflictResolvers)\n          break;\n\n        case 'EnumTypeDefinition':\n          combineTypeAndSubType('directives', lType, rType, conflictResolvers)\n          combineTypeAndSubType('values', lType, rType, conflictResolvers)\n          break;\n\n        case 'UnionTypeDefinition':\n          combineTypeAndSubType('directives', lType, rType, conflictResolvers)\n          combineTypeAndSubType('types', lType, rType, conflictResolvers)\n          break;\n      }\n    }\n\n    return Schemata.from(this.constructor.gql.print(lAST))\n  }\n\n  /**\n   * Paring down Schematas can be handy for certain types of schema stitching.\n   * The SDL passed in and any associated resolvers will be removed from\n   * a copy of the SDL in this Schemata instance represents and the resolver\n   * map passed in.\n   *\n   * @param {string|Schemata|Source|GraphQLSchema} schemaLanguage an instance\n   * of Schemata, a string of SDL, a Source instance of SDL or a GraphQLSchema\n   * that can be printed as an SDL string to define what to pare with the\n   * values in this object instance\n   * @param {Object} resolverMap an object containing resolver functions, from\n   * either those set on this instance or those in the resolverMap added in\n   * @return {Schemata} a new Schemata instance with the changed values set\n   * on it\n   */\n  pareSDL(\n    schemaLanguage: string | Schemata | Source | GraphQLSchema,\n    resolverMap: ?Object = null\n  ): Schemata {\n    let source = normalizeSource(schemaLanguage, true)\n    if (!source) {\n      throw new Error(inline`\n        In the call to pareSDL(schemaLanguage), the supplied value for\n        \\`schemaLanguage\\` could not be parsed.\n      `)\n    }\n\n    if (schemaLanguage instanceof GraphQLSchema && !resolverMap) {\n      resolverMap = stripResolversFromSchema(schemaLanguage)\n    }\n\n    let resolvers = Object.assign({}, resolverMap || this.resolvers || {})\n    let lAST = this.ast\n    let rAST = source.ast\n\n    for (let rType of rAST.definitions) {\n      let lType = lAST.definitions.find(a => a.name.value == rType.name.value)\n\n      if (\n        rType.kind\n        && rType.kind.endsWith\n        && rType.kind.endsWith('Extension')\n      ) {\n        let len = 'Extension'.length\n\n        rType = Object.assign({}, rType)\n        rType.kind =\n          rType.kind.substring(0, rType.kind.length - len) + 'Definition'\n      }\n\n      if (!lType) {\n        lAST.definitions.push(rType)\n        continue\n      }\n\n      switch (lType.kind) {\n        default:\n        case 'ObjectTypeDefinition':\n        case 'ObjectTypeDefinitionExtension':\n        case 'InterfaceTypeDefinition':\n        case 'InterfaceTypeDefinitionExtension':\n        case 'InputObjectTypeDefinition':\n        case 'InputObjectTypeDefinitionExtension':\n          pareTypeAndSubType('directives', lType, rType, resolvers)\n          pareTypeAndSubType('fields', lType, rType, resolvers)\n          if (!lType.fields.length) {\n            let index = lAST.definitions.indexOf(lType)\n            if (index !== -1) {\n              lAST.definitions.splice(index, 1)\n            }\n          }\n          break;\n\n        case 'EnumTypeDefinition':\n          pareTypeAndSubType('directives', lType, rType, resolvers)\n          pareTypeAndSubType('values', lType, rType, resolvers)\n          if (!lType.values.length) {\n            let index = lAST.definitions.indexOf(lType)\n            if (index !== -1) {\n              lAST.definitions.splice(index, 1)\n            }\n          }\n          break;\n\n        case 'UnionTypeDefinition':\n          pareTypeAndSubType('directives', lType, rType, resolvers)\n          pareTypeAndSubType('types', lType, rType, resolvers)\n          if (!lType.types.length) {\n            let index = lAST.definitions.indexOf(lType)\n            if (index !== -1) {\n              lAST.definitions.splice(index, 1)\n            }\n          }\n          break;\n      }\n    }\n\n    let result = Schemata.from(this.constructor.gql.print(lAST), resolvers)\n    result.executableSchema\n\n    return result\n  }\n\n  /**\n   * A new Schemata object instance with merged schema definitions as its\n   * contents as well as merged resolvers and newly bound executable schema are\n   * all created in this step and passed back. The object instance itself is\n   * not modified\n   *\n   * Post merge, the previously stored and merged resolvers map are are applied\n   * and a new executable schema is built from the ashes of the old.\n   *\n   * @param {GraphQLSchema} schema an instance of GraphQLSchema to merge\n   * @param {ConflictResolvers} conflictResolvers an object containing up to\n   * four methods, each describing how to handle a conflict when an associated\n   * type of conflict occurs. If no object or method are supplied, the right\n   * hande value always takes precedence over the existing value; replacing it\n   * @return {Schemata} a new instance of Schemata with a merged schema string,\n   * merged resolver map and newly bound executable schema attached are all\n   * initiated\n   */\n  mergeSchema(\n    schema: GraphQLSchema,\n    conflictResolvers: ?ConflictResolvers = DefaultConflictResolvers\n  ): Schemata {\n    if (!schema) {\n      throw new Error(inline`\n        In the call to mergeSchema(schema), ${schema} was received as a value\n        and the code could not proceed because of it. Please check your code\n        and try again\n      `)\n    }\n\n    let resolvers = this.buildResolvers()\n    let mergeResolvers = stripResolversFromSchema(schema)\n\n    resolvers = merge(this.buildResolvers(), mergeResolvers)\n\n    let schemata = this.mergeSDL(schema)\n\n    // Set the resolvers\n    schemata.resolvers = resolvers\n\n    // Trigger a new schema creation\n    schemata.executableSchema\n\n    return schemata\n  }\n\n  /**\n   * Given a schema, based on the Schemata this object is based on, walk it and\n   * build up a resolver map. This function will always return a non-null\n   * object. It will be empty if there are either no resolvers to be found\n   * in the schema or if a valid schema cannot be created.\n   *\n   * @param {boolean|Object} flattenRootResolversOrFirstParam if this value is\n   * boolean, and if this value is true, the resolvers from Query, Mutation\n   * and Subscription types will be flattened to the root of the object. If\n   * the first parametr is an Object, it will be merged in normally with\n   * Object.assign.\n   * @param {Array<Object>} ...extendWith an unlimited array of objects that\n   * can be used to extend the built resolver map.\n   * @return {Object} a resolver map; i.e. an object of resolver functions\n   */\n  buildResolvers(\n    flattenRootResolversOrFirstParam: boolean|Object,\n    ...extendWith: Array<Object>\n  ): Object {\n    let schemata = Schemata.from(this.sdl, this.resolvers)\n    let resolvers = Object.assign({},\n      (stripResolversFromSchema(schemata.executableSchema)\n        || schemata.resolvers\n        || {}\n      )\n    )\n\n    // Next check to see if we are flattening or simply extending\n    if (typeof flattenRootResolversOrFirstParam === 'boolean') {\n      for (let rootType of ['Query', 'Mutation', 'Subscription']) {\n        if (flattenRootResolversOrFirstParam) {\n          if (resolvers[rootType]) {\n            for (let field of Object.keys(resolvers[rootType])) {\n              resolvers[field] = resolvers[rootType][field]\n              delete resolvers[rootType][field]\n            }\n\n            delete resolvers[rootType]\n          }\n        }\n        else {\n          for (let field of Object.keys(resolvers)) {\n            if (schemata.schemaFieldByName(rootType, field)) {\n              resolvers[rootType] = resolvers[rootType] || {}\n              resolvers[rootType][field] = resolvers[field]\n              delete resolvers[field]\n            }\n          }\n        }\n      }\n    }\n    else {\n      Object.assign(resolvers, flattenRootResolversOrFirstParam)\n    }\n\n    // Finally extend with any remaining arguments\n    if (extendWith.length) {\n      Object.assign(resolvers, ...extendWith)\n    }\n\n    return resolvers\n  }\n\n  /**\n   * A method to determine if an executable schema is attached to this Schemata\n   * instance. It does so by walking the schema fields via `buildResolvers()`\n   * and reporting whether there is anything inside the results or not.\n   *\n   * @return {boolean} true if there is at least one resolver on at least one\n   * field of a type in this Schemata instance's schema.\n   */\n  get hasAnExecutableSchema(): boolean {\n    return Object.keys(this.buildResolvers()).length > 0;\n  }\n\n  /**\n   * If the `.sdl` property is valid SDL/IDL and can generate valid AST nodes\n   * this function will return true. It will return false otherwise.\n   *\n   * @return {boolean} true if the string can be parsed; false otherwise\n   */\n  get validSDL(): boolean {\n    try {\n      this.constructor.gql.parse(this.sdl)\n      return true\n    }\n    catch(e) {\n      return false\n    }\n  }\n\n  /**\n   * If the `.schema` property is valid SDL/IDL and can generate a valid\n   * GraphQLSchema, this function will return true. It will return false\n   * otherwise.\n   *\n   * @return {boolean} true if the string can be parsed into a schema; false\n   * otherwise\n   */\n  get validSchema(): boolean {\n    try {\n      this.schema;\n      return true\n    }\n    catch (e) {\n      return false\n    }\n  }\n\n  /**\n   * Returns true if the string underlying this instance represents valid SDL\n   * that can be both converted to AST nodes or a valid GraphQLSchema instance\n   *\n   * @return {boolean} true if it is valid for both `parse()` as well as the\n   * `buildSchema()` function\n   */\n  get valid(): boolean { return this.validSDL && this.validSchema }\n\n\n  /**\n   * If the internal resolvers object needs to be changed after creation, this\n   * method allows a way to do so. Setting the value to `null` is equivalent\n   * to removing any stored value. Finally the contents are stored in a weak\n   * map so its contents are not guaranteed over a long period of time.\n   *\n   * @param {Object} resolvers an object containing field resolvers for this\n   * string instance.\n   */\n  set resolvers(resolvers: ?Object): void {\n    this[MAP].set(wmkResolvers, resolvers)\n  }\n\n  /**\n   * Removes the resolver map associated with this Schemata instance\n   */\n  clearResolvers(): void {\n    this.resolvers = null\n  }\n\n  /**\n   * Removes the schema stored with this Schemata instance\n   */\n  clearSchema(): void {\n    this.schema = null\n  }\n\n  /**\n   * Returns the underlying string passed or generated in the constructor when\n   * inspected in the nodeJS REPL.\n   *\n   * @return {string} the SDL/IDL string this class was created on\n   */\n  inspect(): string { return this.sdl }\n\n  /**\n   * The same as `inspect()`, `toString()`, and `valueOf()`. This method\n   * returns the underlying string this class instance was created on.\n   *\n   * @return {string} [description]\n   */\n  toString(): string { return this.sdl }\n\n  /**\n   * The same as `inspect()`, `toString()`, and `valueOf()`. This method\n   * returns the underlying string this class instance was created on.\n   *\n   * @return {string} [description]\n   */\n  valueOf(): string { return this.sdl }\n\n  /**\n   * Iterates over the values contained in a Schema's typeMap. If a desired\n   * value is encountered, the supplied callback will be invoked. The values are\n   * the constants ALL, TYPES, INTERFACES, ENUMS, UNIONS and SCALARS. Optionally\n   * HIDDEN is another value that can be bitmasked together for a varied result.\n   * HIDDEN exposes the values in the schema typemap that begin with a double\n   * underscore.\n   *\n   * The signature for the function callback is as follows:\n   * (\n   *   type: mixed,\n   *   typeName: string,\n   *   typeDirectives: Array<GraphQLDirective>\n   *   schema: GraphQLSchema,\n   *   context: mixed,\n   * ) => void\n   *\n   * Where:\n   *   `type`           - the object instance from within the `GraphQLSchema`\n   *   `typeName`       - the name of the object; \"Query\" for type Query and\n   *                      so on.\n   *   `typeDirectives` - an array of directives applied to the object or an\n   *                      empty array if there are none applied.\n   *   `schema`         - an instance of `GraphQLSchema` over which to iterate\n   *   `context`        - usually an object, and usually the same object,\n   *                      passed to the call to `makeExecutableSchema()`\n   *                      or `graphql()`\n   *\n   * @param {Function} fn a function with a signature defined above\n   * @param {mixed} context usually an object but any mixed value the denotes\n   * some shared context as is used with the schema during normal runtime.\n   * @param {Number} types a bitmask of one or more of the constants defined\n   * above. These can be OR'ed together and default to TYPES.\n   * @param {GraphQLSchema} suppliedSchema an optional schema to use rather\n   * than the one created or stored internally generated from this SDL\n   * @return {GraphQLSchema} a new schema is generated from this SDL, iterated\n   * over and returned.\n   */\n  forEachOf(\n    fn: ForEachOfResolver,\n    context: mixed,\n    types: number = TYPES,\n    suppliedSchema: ?GraphQLSchema = null\n  ): GraphQLSchema {\n    let schema = suppliedSchema || this.schema\n\n    forEachOf(schema, fn, context, types)\n\n    return schema\n  }\n\n  /**\n   * Shortcut to `forEachOf()` specific to types.\n   *\n   * @see #forEachOf\n   *\n   * @param {Function} fn a function with a signature defined above\n   * @param {mixed} context usually an object but any mixed value the denotes\n   * some shared context as is used with the schema during normal runtime.\n   * @param {GraphQLSchema} suppliedSchema an optional schema to use rather\n   * than the one created or stored internally generated from this Schemata\n   * @return {GraphQLSchema} a new schema is generated from this Schemata, iterated\n   * over and returned.\n   */\n  forEachType(\n    fn: ForEachOfResolver,\n    context: mixed,\n    suppliedSchema: ?GraphQLSchema\n  ): GraphQLSchema {\n    return this.forEachOf(fn, context, TYPES, suppliedSchema)\n  }\n\n  /**\n   * Shortcut to `forEachOf()` specific to input object types.\n   *\n   * @see #forEachOf\n   *\n   * @param {Function} fn a function with a signature defined above\n   * @param {mixed} context usually an object but any mixed value the denotes\n   * some shared context as is used with the schema during normal runtime.\n   * @param {GraphQLSchema} suppliedSchema an optional schema to use rather\n   * than the one created or stored internally generated from this Schemata\n   * @return {GraphQLSchema} a new schema is generated from this Schemata, iterated\n   * over and returned.\n   */\n  forEachInputObjectType(\n    fn: ForEachOfResolver,\n    context: mixed,\n    suppliedSchema: ?GraphQLSchema\n  ): GraphQLSchema {\n    return this.forEachOf(fn, context, INPUT_TYPES, suppliedSchema)\n  }\n\n  /**\n   * Shortcut to `forEachOf()` specific to unions.\n   *\n   * @see #forEachOf\n   *\n   * @param {Function} fn a function with a signature defined above\n   * @param {mixed} context usually an object but any mixed value the denotes\n   * some shared context as is used with the schema during normal runtime.\n   * @param {GraphQLSchema} suppliedSchema an optional schema to use rather\n   * than the one created or stored internally generated from this SDL\n   * @return {GraphQLSchema} a new schema is generated from this SDL, iterated\n   * over and returned.\n   */\n  forEachUnion(\n    fn: ForEachOfResolver,\n    context: mixed,\n    suppliedSchema: ?GraphQLSchema\n  ): GraphQLSchema {\n    return this.forEachOf(fn, context, UNIONS, suppliedSchema)\n  }\n\n  /**\n   * Shortcut to `forEachOf()` specific to enums.\n   *\n   * @see #forEachOf\n   *\n   * @param {Function} fn a function with a signature defined above\n   * @param {mixed} context usually an object but any mixed value the denotes\n   * some shared context as is used with the schema during normal runtime.\n   * @param {GraphQLSchema} suppliedSchema an optional schema to use rather\n   * than the one created or stored internally generated from this SDL\n   * @return {GraphQLSchema} a new schema is generated from this SDL, iterated\n   * over and returned.\n   */\n  forEachEnum(\n    fn: ForEachOfResolver,\n    context: mixed,\n    suppliedSchema: ?GraphQLSchema\n  ): GraphQLSchema {\n    return this.forEachOf(fn, context, ENUMS, suppliedSchema)\n  }\n\n  /**\n   * Shortcut to `forEachOf()` specific to interfaces.\n   *\n   * @see #forEachOf\n   *\n   * @param {Function} fn a function with a signature defined above\n   * @param {mixed} context usually an object but any mixed value the denotes\n   * some shared context as is used with the schema during normal runtime.\n   * @param {GraphQLSchema} suppliedSchema an optional schema to use rather\n   * than the one created or stored internally generated from this SDL\n   * @return {GraphQLSchema} a new schema is generated from this SDL, iterated\n   * over and returned.\n   */\n  forEachInterface(\n    fn: ForEachOfResolver,\n    context: mixed,\n    suppliedSchema: ?GraphQLSchema\n  ): GraphQLSchema {\n    return this.forEachOf(fn, context, INTERFACES, suppliedSchema)\n  }\n\n  /**\n   * Shortcut to `forEachOf()` specific to types.\n   *\n   * @see #forEachOf\n   *\n   * @param {Function} fn a function with a signature defined above\n   * @param {mixed} context usually an object but any mixed value the denotes\n   * some shared context as is used with the schema during normal runtime.\n   * @param {GraphQLSchema} suppliedSchema an optional schema to use rather\n   * than the one created or stored internally generated from this SDL\n   * @return {GraphQLSchema} a new schema is generated from this SDL,\n   * iterated over and returned.\n   */\n  forEachScalar(\n    fn: ForEachOfResolver,\n    context: mixed,\n    suppliedSchema: ?GraphQLSchema\n  ): GraphQLSchema {\n    return this.forEachOf(fn, context, SCALARS, suppliedSchema)\n  }\n\n  /**\n   * Shortcut to `forEachOf()` specific to all root types; Query, Mutation and\n   * Subscription that exist within the schema.\n   *\n   * @see #forEachOf\n   *\n   * @param {Function} fn a function with a signature defined above\n   * @param {mixed} context usually an object but any mixed value the denotes\n   * some shared context as is used with the schema during normal runtime.\n   * @param {GraphQLSchema} suppliedSchema an optional schema to use rather\n   * than the one created or stored internally generated from this SDL\n   * @return {GraphQLSchema} a new schema is generated from this SDL, iterated\n   * over and returned.\n   */\n  forEachRootType(\n    fn: ForEachOfResolver,\n    context: mixed,\n    suppliedSchema: ?GraphQLSchema\n  ): GraphQLSchema {\n    return this.forEachOf(fn, context, ROOT_TYPES, suppliedSchema)\n  }\n\n  /**\n   * An extension of `forEachOf` that targets the fields of the types in the\n   * schema's typeMap. This function provides more detail and allows greater\n   * access to any associated `context` than the function of the same name\n   * provided by the `graphql-tools` library.\n   *\n   * The signature for the callback function is as follows\n   *\n   * (\n   *   type: mixed,\n   *   typeName: string,\n   *   typeDirectives: Array<GraphQLDirective>,\n   *   field: mixed,\n   *   fieldName: string,\n   *   fieldArgs: Array<GraphQLArgument>,\n   *   fieldDirectives: Array<GraphQLDirective>,\n   *   schema: GraphQLSchema,\n   *   context: mixed\n   * ) => void\n   *\n   * Where\n   *\n   * Where:\n   *   `type`           - the object instance from within the `GraphQLSchema`\n   *   `typeName`       - the name of the object; \"Query\" for type Query and\n   *                      so on\n   *   `typeDirectives` - an array of directives applied to the object or an\n   *                      empty array if there are none applied.\n   *   `field`          - the field in question from the type\n   *   `fieldName`      - the name of the field as a string\n   *   `fieldArgs`      - an array of arguments for the field in question\n   *   `fieldDirectives`- an array of directives applied to the field or an\n   *                      empty array should there be no applied directives\n   *   `schema`         - an instance of `GraphQLSchema` over which to iterate\n   *   `context`        - usually an object, and usually the same object, passed\n   *                      to the call to `makeExecutableSchema()` or `graphql()`\n   *\n   * @param {Function} fn a function with a signature defined above\n   * @param {mixed} context usually an object but any mixed value the denotes\n   * some shared context as is used with the schema during normal runtime.\n   * @param {GraphQLSchema} suppliedSchema an optional schema to use rather\n   * than the one created or stored internally generated from this SDL\n   * @return {GraphQLSchema} a new schema is generated from this SDL, iterated\n   * over and returned.\n   */\n  forEachField(\n    fn: ForEachFieldResolver,\n    context: mixed,\n    types: number = ALL,\n    suppliedSchema: ?GraphQLSchema = null\n  ): GraphQLSchema {\n    let schema = suppliedSchema || this.schema\n\n    forEachField(schema, fn, context, types)\n\n    return schema\n  }\n\n  /**\n   * `forEachField()` shortcut focusing on GraphQLObjectTypes specifically.\n   *\n   * @param {ForEachFieldResolver} fn a callback function that is invoked for\n   * each field of any GraphQLObjectType found\n   * @param {mixed} context usually an object but any mixed value the denotes\n   * some shared context as is used with the schema during normal runtime.\n   * @param {GraphQLSchema} suppliedSchema an optional schema to use rather\n   * than the one created or stored internally generated from this SDL\n   * @return {GraphQLSchema} either the supplied GraphQLSchema or one generated\n   * to facilitate the task\n   */\n  forEachTypeField(\n    fn: ForEachFieldResolver,\n    context: mixed,\n    suppliedSchema: ?GraphQLSchema = null\n  ): GraphQLSchema {\n    let schema = suppliedSchema || this.schema\n\n    forEachField(schema, fn, context, TYPES)\n\n    return schema\n  }\n\n  /**\n   * `forEachField()` shortcut focusing on GraphQLInterfaceType specifically.\n   *\n   * @param {ForEachFieldResolver} fn a callback function that is invoked for\n   * each field of any GraphQLObjectType found\n   * @param {mixed} context usually an object but any mixed value the denotes\n   * some shared context as is used with the schema during normal runtime.\n   * @param {GraphQLSchema} suppliedSchema an optional schema to use rather\n   * than the one created or stored internally generated from this SDL\n   * @return {GraphQLSchema} either the supplied GraphQLSchema or one generated\n   * to facilitate the task\n   */\n  forEachInterfaceField(\n    fn: ForEachFieldResolver,\n    context: mixed,\n    suppliedSchema: ?GraphQLSchema = null\n  ): GraphQLSchema {\n    let schema = suppliedSchema || this.schema\n\n    forEachField(schema, fn, context, INTERFACES)\n\n    return schema\n  }\n\n  /**\n   * `forEachField()` shortcut focusing on GraphQLInputObjectType specifically.\n   *\n   * @param {ForEachFieldResolver} fn a callback function that is invoked for\n   * each field of any GraphQLObjectType found\n   * @param {mixed} context usually an object but any mixed value the denotes\n   * some shared context as is used with the schema during normal runtime.\n   * @param {GraphQLSchema} suppliedSchema an optional schema to use rather\n   * than the one created or stored internally generated from this SDL\n   * @return {GraphQLSchema} either the supplied GraphQLSchema or one generated\n   * to facilitate the task\n   */\n  forEachInputObjectField(\n    fn: ForEachFieldResolver,\n    context: mixed,\n    suppliedSchema: ?GraphQLSchema = null\n  ): GraphQLSchema {\n    let schema = suppliedSchema || this.schema\n\n    forEachField(schema, fn, context, INPUT_TYPES)\n\n    return schema\n  }\n\n  /**\n   * Wrapper for `require('graphql').graphqlSync()` that automatically passes\n   * in the internal `.schema` reference as the first parameter.\n   *\n   * @param {string|Source} query A GraphQL language formatted string\n   * representing the requested operation.\n   * @param {mixed} contextValue a bit of shared context to pass to resolvers\n   * @param {Object} variableValues A mapping of variable name to runtime value\n   * to use for all variables defined in the requestString.\n   * @param {Object|null} The value provided as the first argument to resolver\n   * functions on the top level type (e.g. the query object type).\n   * @param {string} operationName The name of the operation to use if\n   * requestString contains multiple possible operations. Can be omitted if\n   * requestString contains only one operation.\n   * @param {GraphQLFieldResolver<any, any>} fieldResolver A resolver function\n   * to use when one is not provided by the schema. If not provided, the\n   * default field resolver is used (which looks for a value or method on the\n   * source value with the field's name).\n   * @return {ExecutionResult} the requested results. An error is thrown if\n   * the results could not be fulfilled or invalid input/output was specified.\n   */\n  run(\n    query: string | Source,\n    contextValue?: mixed,\n    variableValues?: ?ObjMap<mixed>,\n    rootValue?: mixed,\n    operationName?: ?string,\n    fieldResolver?: ?GraphQLFieldResolver<any,any>\n  ): ExecutionResult {\n    return this.constructor.gql.graphqlSync(\n      this.schema,\n      query,\n      this.resolvers || rootValue,\n      contextValue,\n      variableValues,\n      operationName,\n      fieldResolver,\n    )\n  }\n\n  /**\n   * Wrapper for `require('graphql').graphql()` that automatically passes\n   * in the internal `.schema` reference as the first parameter.\n   *\n   * @param {string|Source} query A GraphQL language formatted string\n   * representing the requested operation.\n   * @param {mixed} contextValue a bit of shared context to pass to resolvers\n   * @param {Object} variableValues A mapping of variable name to runtime value\n   * to use for all variables defined in the requestString.\n   * @param {Object|null} The value provided as the first argument to resolver\n   * functions on the top level type (e.g. the query object type).\n   * @param {string} operationName The name of the operation to use if\n   * requestString contains multiple possible operations. Can be omitted if\n   * requestString contains only one operation.\n   * @param {GraphQLFieldResolver<any, any>} fieldResolver A resolver function\n   * to use when one is not provided by the schema. If not provided, the\n   * default field resolver is used (which looks for a value or method on the\n   * source value with the field's name).\n   * @return {Promise<ExecutionResult>} a Promise contianing the requested\n   * results\n   */\n  async runAsync(\n    query: string | Source,\n    contextValue?: mixed,\n    variableValues?: ?ObjMap<mixed>,\n    rootValue?: mixed,\n    operationName?: ?string,\n    fieldResolver?: ?GraphQLFieldResolver<any,any>\n  ): Promise<ExecutionResult> {\n    return this.constructor.gql.graphql(\n      this.schema,\n      query,\n      this.resolvers || rootValue,\n      contextValue,\n      variableValues,\n      operationName,\n      fieldResolver,\n    )\n  }\n\n  /**\n   * A little wrapper used to catch any errors thrown when building a schema\n   * from the string SDL representation of a given instance.\n   *\n   * @param {string|Schemata|Source|GraphQLSchema} sdl an instance\n   * of Schemata, a string of SDL, a Source instance of SDL or a GraphQLSchema\n   * that can be printed as an SDL string\n   * @param {boolean} showError true if the error should be thrown, false if\n   * the error should be silently suppressed\n   * @param {BuildSchemaOptions&ParseOptions} schemaOpts for advanced users,\n   * passing through additional buildSchema() options can be done here\n   * @return {GraphQLSchema|null} null if an error occurs and errors are not\n   * surfaced or a valid GraphQLSchema object otherwise\n   */\n  static buildSchema(\n    sdl: string | Source | Schemata | GraphQLSchema,\n    showError: boolean = false,\n    schemaOpts: BuildSchemaOptions & ParseOptions = undefined\n  ): GraphQLSchema {\n    try {\n      let source = normalizeSource(sdl)\n\n      return this.gql.buildSchema(source, schemaOpts)\n    }\n    catch (e) {\n      if (showError) { throw e }\n      return null\n    }\n  }\n\n  /**\n   * A little wrapper used to catch any errors thrown when parsing Schemata for\n   * ASTNodes. If showError is true, any caught errors are thrown once again.\n   *\n   * @param {string|Schemata|Source|GraphQLSchema} sdl an instance\n   * of Schemata, a string of SDL, a Source instance of SDL or a GraphQLSchema\n   * that can be printed as an SDL string\n   * @param {boolean} showError if true, any caught errors will be thrown once\n   * again\n   * @return {ASTNode|null} null if an error occurs and errors are suppressed,\n   * a top level Document ASTNode otherwise\n   */\n  static parse(\n    sdl: string | Schemata | Source | GraphQLSchema,\n    showError: boolean = false\n  ) {\n    try {\n      let source = normalizeSource(sdl)\n\n      return this.gql.parse(source)\n    }\n    catch (e) {\n      if (showError) { throw e }\n      return null\n    }\n  }\n\n  /**\n   * A simple pass thru used within the class to reference graphql methods\n   * and classes.\n   *\n   * @return {mixed} the results of `require('graphql')`\n   */\n  static get gql(): mixed { return require('graphql') }\n\n  /**\n   * Shorthand way of invoking `new Schemata(typeDefs, resolvers)`\n   *\n   * @param {string|Source|Schemata|GraphQLSchema} typeDefs usually a String or\n   * other `toString`'able item\n   * @param {Object} resolvers an object containing field resolvers for\n   * for the schema represented with this string. [Optional]\n   * @return {Schemata} an instance of Schemata\n   */\n  static from(\n    typeDefs: string | Source | Schemata | GraphQLSchema,\n    resolvers: ?Object\n  ): Schemata {\n    return new this(typeDefs, resolvers)\n  }\n\n  /**\n   * Constant used with `forEachOf()` that signifies you wish to iterate\n   * over every available type within the schema.\n   *\n   * @type {number}\n   */\n  static get ALL(): number { return ALL }\n\n  /**\n   * Constant used with `forEachOf()` that signifies you wish to iterate\n   * over every available type within the schema.\n   *\n   * @type {number}\n   */\n  static get TYPES(): number { return TYPES }\n\n  /**\n   * Constant used with `forEachOf()` that signifies you wish to iterate\n   * over every available interface within the schema.\n   *\n   * @type {number}\n   */\n  static get INTERFACES(): number { return INTERFACES }\n\n  /**\n   * Constant used with `forEachOf()` that signifies you wish to iterate\n   * over every available enum within the schema.\n   *\n   * @type {number}\n   */\n  static get ENUMS(): number { return ENUMS }\n\n  /**\n   * Constant used with `forEachOf()` that signifies you wish to iterate\n   * over every available union within the schema.\n   *\n   * @type {number}\n   */\n  static get UNIONS(): number { return UNIONS }\n\n  /**\n   * Constant used with `forEachOf()` that signifies you wish to iterate\n   * over every available scalar within the schema.\n   *\n   * @type {number}\n   */\n  static get SCALARS(): number { return SCALARS }\n\n  /**\n   * Constant used with `forEachOf()` that signifies you wish to iterate\n   * over every available root type; Query, Mutation and Subscription\n   *\n   * @type {number}\n   */\n  static get ROOT_TYPES(): number { return ROOT_TYPES }\n\n  /**\n   * Constant used with `forEachOf()` that signifies you wish to iterate\n   * over every available GraphQLInputObjectType within the schema.\n   *\n   * @type {number}\n   */\n  static get INPUT_TYPES(): number { return INPUT_TYPES }\n\n  /**\n   * Constant used with `forEachOf()` that signifies you also wish to\n   * iterate over the meta types. These are denoted by a leading double\n   * underscore.\n   *\n   * Can be OR'ed together such as `Schemata.TYPES | Schemata.HIDDEN`\n   *\n   * @type {number}\n   */\n  static get HIDDEN(): number { return HIDDEN }\n}\n\nexport default Schemata"]}