{"version":3,"sources":["../src/Schemata.js"],"names":["stripResolversFromSchema","DefaultFieldMergeResolver","DefaultDirectiveMergeResolver","DefaultEnumMergeResolver","DefaultUnionMergeResolver","DefaultScalarMergeResolver","normalizeSource","schema","resolvers","type","typeName","typeDirectives","field","fieldName","fieldArgs","fieldDirectives","_schema","context","resolve","TYPEDEFS_KEY","GRAPHIQL_FLAG","MAP","EXE","wmkResolvers","Object","wmkSchema","leftType","leftField","rightType","rightField","leftDirective","rightDirective","leftValue","rightValue","leftUnion","rightUnion","leftScalar","leftConfig","rightScalar","rightConfig","DefaultConflictResolvers","fieldMergeResolver","directiveMergeResolver","enumValueMergeResolver","typeValueMergeResolver","scalarMergeResolver","subTypeResolverMap","set","combineTypeAndSubType","subTypeName","lType","rType","conflictResolvers","rSubType","lSubType","find","f","name","value","push","resolver","get","resultingSubType","index","fields","indexOf","splice","pareTypeAndSubType","typeDefs","wrap","Error","source","body","sdl","toString","Schemata","from","String","constructor","ast","parse","graphiql","length","executableSchema","buildSchema","error","isRootType","t","undefined","Class","forEachField","astNode","rootValue","buildResolvers","schemaResolverFor","valid","_type","getType","_field","getFields","schemaFieldByName","validSchema","astTypeByName","validSDL","definitions","astFieldByName","hasFlattenedResolvers","asts","query","mutation","subscription","mergeSDL","schemaLanguage","lAST","rAST","_scalarFns","a","kind","endsWith","substring","lScalar","lScalarConfig","rScalar","rScalarConfig","_scalarConfig","merged","gql","print","pareSDL","resolverMap","len","values","types","result","mergeSchema","mergeResolvers","schemata","flattenRootResolversOrFirstParam","extendWith","rootType","hasAnExecutableSchema","e","clearResolvers","clearSchema","inspect","valueOf","forEachOf","fn","suppliedSchema","forEachType","forEachInputObjectType","INPUT_TYPES","forEachUnion","forEachEnum","forEachInterface","forEachScalar","forEachRootType","forEachTypeField","forEachInterfaceField","forEachInputObjectField","run","contextValue","variableValues","operationName","fieldResolver","graphqlSync","runAsync","graphql","showError","schemaOpts","require","ALL","TYPES","INTERFACES","ENUMS","UNIONS","SCALARS","ROOT_TYPES","HIDDEN"],"mappings":"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","file":"Schemata.js","sourceRoot":"src","sourcesContent":["// @flow\n\nimport type {\n  ASTNode,\n  BuildSchemaOptions,\n  DirectiveNode,\n  EnumValueNode,\n  ExecutionResult,\n  FieldNode,\n  GraphQLFieldResolver,\n  GraphQLScalarTypeConfig,\n  NamedTypeNode,\n  ObjMap,\n  ParseOptions,\n  ScalarTypeDefinitionNode,\n  Source,\n} from 'graphql'\n\nimport { GraphQLSchema, GraphQLObjectType, printSchema } from 'graphql'\nimport { inline } from 'ne-tag-fns'\nimport merge from 'deepmerge'\n\nimport {\n  forEachOf,\n  forEachField,\n\n  ALL,\n  TYPES,\n  INTERFACES,\n  ENUMS,\n  UNIONS,\n  SCALARS,\n  ROOT_TYPES,\n  HIDDEN\n} from './forEachOf'\n\nimport type { ForEachOfResolver, ForEachFieldResolver } from './forEachOf'\n\n/**\n * Walk the supplied GraphQLSchema instance and retrieve the resolvers stored\n * on it. These values are then returned with a [typeName][fieldName] pathing\n *\n * @param {GraphQLSchema} schema an instance of GraphQLSchema\n * @return {Object} an object containing a mapping of typeName.fieldName that\n * links to the resolve() function it is associated within the supplied schema\n */\nexport function stripResolversFromSchema(\n  schema: GraphQLSchema\n): ?Object {\n  let resolvers = {}\n\n  if (!schema) {\n    return null\n  }\n\n  forEachField(schema, (\n    type,\n    typeName,\n    typeDirectives,\n    field,\n    fieldName,\n    fieldArgs,\n    fieldDirectives,\n    _schema,\n    context\n  ) => {\n    if (field.resolve) {\n      resolvers[typeName] = resolvers[typeName] || {}\n      resolvers[typeName][fieldName] = resolvers[typeName][fieldName] || {}\n      resolvers[typeName][fieldName] = field.resolve\n    }\n  })\n\n  return resolvers\n}\n\n/**\n * The callback for collision when a field is trying to be merged with an\n * existing field.\n *\n * @param {ASTNode} leftType the ASTNode, usually denoting a type, that will\n * receive the merged type's field from the right\n * @param {FieldNode} leftField the FieldNode denoting the value that should\n * be modified or replaced\n * @param {ASTNode} rightType the ASTNode containing the field to be merged\n * @param {FieldNode} rightField the FieldNode requesting to be merged and\n * finding a conflicting value already present\n * @return {FieldNode} the field to merge into the existing schema layout. To\n * ignore changes, returning the leftField is sufficient enough. The default\n * behavior is to always take the right hand value, overwriting new with old\n */\nexport type FieldMergeResolver = (\n  leftType: ASTNode,\n  leftField: FieldNode,\n  rightType: ASTNode,\n  rightField: FieldNode\n) => FieldNode\n\n/**\n * The callback for collision when a directive is trying to be merged with an\n * existing directive.\n *\n * @param {ASTNode} leftType the ASTNode, usually denoting a type, that will\n * receive the merged type's directive from the right\n * @param {DirectiveNode} leftDirective the DirectiveNode denoting the value\n * that should be modified or replaced\n * @param {ASTNode} rightType the ASTNode containing the directive to be merged\n * @param {DirectiveNode} rightDirective the DirectiveNode requesting to be\n * merged and finding a conflicting value already present\n * @return {DirectiveNode} the directive to merge into the existing schema\n * layout. To ignore changes, returning the leftDirective is sufficient enough.\n * The default behavior is to always take the right hand value, overwriting\n * new with old\n */\nexport type DirectiveMergeResolver = (\n  leftType: ASTNode,\n  leftDirective: DirectiveNode,\n  rightType: ASTNode,\n  rightDirective: DirectiveNode\n) => DirectiveNode\n\n/**\n * The callback for collision when a enum value is trying to be merged with an\n * existing enum value of the same name.\n *\n * @param {ASTNode} leftType the ASTNode, usually denoting a type, that will\n * receive the merged type's enum value from the right\n * @param {EnumValueNode} leftValue the EnumValueNode denoting the value\n * that should be modified or replaced\n * @param {ASTNode} rightType the ASTNode containing the enum value to be\n * merged\n * @param {EnumValueNode} rightValue the EnumValueNode requesting to be\n * merged and finding a conflicting value already present\n * @return {EnumValueNode} the enum value to merge into the existing schema\n * layout. To ignore changes, returning the leftValue is sufficient enough.\n * The default behavior is to always take the right hand value, overwriting\n * new with old\n */\nexport type EnumMergeResolver = (\n  leftType: ASTNode,\n  leftValue: EnumValueNode,\n  rightType: ASTNode,\n  rightValue: EnumValueNode\n) => EnumValueNode\n\n/**\n * The callback for collision when a union type is trying to be merged with an\n * existing union type of the same name.\n *\n * @param {ASTNode} leftType the ASTNode, usually denoting a type, that will\n * receive the merged type's union type from the right\n * @param {NamedTypeNode} leftValue the NamedTypeNode denoting the value\n * that should be modified or replaced\n * @param {ASTNode} rightType the ASTNode containing the union type to be\n * merged\n * @param {NamedTypeNode} rightValue the NamedTypeNode requesting to be\n * merged and finding a conflicting value already present\n * @return {NamedTypeNode} the union type to merge into the existing schema\n * layout. To ignore changes, returning the leftUnion is sufficient enough.\n * The default behavior is to always take the right hand value, overwriting\n * new with old\n */\nexport type UnionMergeResolver = (\n  leftType: ASTNode,\n  leftUnion: NamedTypeNode,\n  rightType: ASTNode,\n  rightUnion: NamedTypeNode\n) => NamedTypeNode\n\n/**\n * A callback for to resolve merge conflicts with custom scalar types defined\n * by the user.\n *\n * @param {ScalarTypeDefinitionNode} leftScalar the definition node found when\n * parsing ASTNodes. This is the existing value that conflicts with the to be\n * merged value\n * @param {GraphQLScalarTypeConfig} leftConfig *if* there is a resolver defined\n * for the existing ScalarTypeDefinitionNode it will be provided here. If this\n * value is null, there is no availabe config with serialize(), parseValue() or\n * parseLiteral() to work with.\n * @param {ScalarTypeDefinitionNode} rightScalar the definition node found when\n * parsing ASTNodes. This is to be merged value that conflicts with the\n * existing value\n * @param {GraphQLScalarTypeConfig} rightConfig *if* there is a resolver\n * defined for the existing ScalarTypeDefinitionNode it will be provided here.\n * If this value is null, there is no availabe config with serialize(),\n * parseValue() or parseLiteral() to work with.\n * @return {GraphQLScalarTypeConfig} whichever type config or resolver was\n * desired should be returned here.\n *\n * @see https://www.apollographql.com/docs/graphql-tools/scalars.html\n * @see http://graphql.org/graphql-js/type/#graphqlscalartype\n */\nexport type ScalarMergeResolver = (\n  leftScalar: ScalarTypeDefinitionNode,\n  leftConfig: GraphQLScalarTypeConfig,\n  rightScalar: ScalarTypeDefinitionNode,\n  rightConfig: GraphQLScalarTypeConfig\n) => GraphQLScalarTypeConfig\n\n/**\n * An object that specifies the various types of resolvers that might occur\n * during a given conflict resolution\n */\nexport type ConflictResolvers = {\n  /** A handler for resolving fields in matching types */\n  fieldMergeResolver?: FieldMergeResolver,\n\n  /** A handler for resolving directives in matching types */\n  directiveMergeResolver?: DirectiveMergeResolver,\n\n  /** A handler for resolving conflicting enum values */\n  enumValueMergeResolver?: EnumMergeResolver,\n\n  /** A handler for resolving type values in unions */\n  typeValueMergeResolver?: UnionMergeResolver,\n\n  /** A handler for resolving scalar config conflicts in custom scalars */\n  scalarMergeResolver?: ScalarMergeResolver\n}\n\n/** @type {Symbol} a unique symbol used as a key to all instance sdl strings */\nexport const TYPEDEFS_KEY = Symbol()\n\n/** @type {Symbol} a constant symbol used as a key to a flag for express-gql */\nexport const GRAPHIQL_FLAG = Symbol.for('superfluous graphiql flag')\n\n/** @type {Symbol} a unique symbol used as a key to all instance `WeakMap`s */\nexport const MAP = Symbol()\n\n/** @type {Symbol} a key used to store the __executable__ flag on a schema */\nexport const EXE = Symbol()\n\n/** @type {Object} a key used to store a resolver object in a WeakMap */\nconst wmkResolvers = Object(Symbol())\n\n/** @type {Object} a key used to store an internal schema in a WeakMap */\nconst wmkSchema = Object(Symbol())\n\n/**\n * The default field resolver blindly takes returns the right field. This\n * resolver is used when one is not specified.\n *\n * @param {ASTNode} leftType The matching left type indicating conflict\n * @param {FieldNode} leftField The field causing the conflict\n * @param {ASTNode} rightType The matching right type indicating conflict\n * @param {FieldNode} rightField the field cause the conflict\n *\n * @return {FieldNode} the field that should be used after resolution\n */\nexport function DefaultFieldMergeResolver(\n  leftType: ASTNode,\n  leftField: FieldNode,\n  rightType: ASTNode,\n  rightField: FieldNode\n): FieldNode {\n  return rightField\n}\n\n/**\n * The default directive resolver blindly takes returns the right field. This\n * resolver is used when one is not specified.\n *\n * @param {ASTNode} leftType The matching left type indicating conflict\n * @param {DirectiveNode} leftDirective The field causing the conflict\n * @param {ASTNode} rightType The matching right type indicating conflict\n * @param {DirectiveNode} rightDirective the field cause the conflict\n *\n * @return {DirectiveNode} the directive that should be used after resolution\n */\nexport function DefaultDirectiveMergeResolver(\n  leftType: ASTNode,\n  leftDirective: DirectiveNode,\n  rightType: ASTNode,\n  rightDirective: DirectiveNode\n): DirectiveNode {\n  return rightDirective\n}\n\n/**\n * The default field resolver blindly takes returns the right field. This\n * resolver is used when one is not specified.\n *\n * @param {ASTNode} leftType The matching left type indicating conflict\n * @param {DirectiveNode} leftDirective The field causing the conflict\n * @param {ASTNode} rightType The matching right type indicating conflict\n * @param {DirectiveNode} rightDirective the field cause the conflict\n *\n * @return {DirectiveNode} the directive that should be used after resolution\n */\nexport function DefaultEnumMergeResolver(\n  leftType: ASTNode,\n  leftValue: EnumValueNode,\n  rightType: ASTNode,\n  rightValue: EnumValueNode\n): EnumValueNode {\n  return rightValue\n}\n\n/**\n * The default union resolver blindly takes returns the right type. This\n * resolver is used when one is not specified.\n *\n * @param {ASTNode} leftType The matching left type indicating conflict\n * @param {NamedTypeNode} leftUnion The named node causing the conflict\n * @param {ASTNode} rightType The matching right type indicating conflict\n * @param {NamedTypeNode} rightUnion the named node cause the conflict\n *\n * @return {NamedTypeNode} the directive that should be used after resolution\n */\nexport function DefaultUnionMergeResolver(\n  leftType: ASTNode,\n  leftUnion: NamedTypeNode,\n  rightType: ASTNode,\n  rightUnion: NamedTypeNode\n): NamedTypeNode {\n  return rightUnion\n}\n\n/**\n * The default scalar merge resolver returns the right config when there is\n * one, otherwise the left one or null will be the default result. This is\n * slightly different behavior since resolvers for scalars are not always\n * available.\n *\n * @param {GraphQLScalarTypeConfig} leftConfig *if* there is a resolver defined\n * for the existing ScalarTypeDefinitionNode it will be provided here. If this\n * value is null, there is no availabe config with serialize(), parseValue() or\n * parseLiteral() to work with.\n * @param {ScalarTypeDefinitionNode} rightScalar the definition node found when\n * parsing ASTNodes. This is to be merged value that conflicts with the\n * existing value\n * @param {GraphQLScalarTypeConfig} rightConfig *if* there is a resolver\n * defined for the existing ScalarTypeDefinitionNode it will be provided here.\n * If this value is null, there is no availabe config with serialize(),\n * parseValue() or parseLiteral() to work with.\n * @return {GraphQLScalarTypeConfig} whichever type config or resolver was\n * desired should be returned here.\n *\n * @see https://www.apollographql.com/docs/graphql-tools/scalars.html\n * @see http://graphql.org/graphql-js/type/#graphqlscalartype\n */\nexport function DefaultScalarMergeResolver(\n  leftScalar: ScalarTypeDefinitionNode,\n  leftConfig: GraphQLScalarTypeConfig,\n  rightScalar: ScalarTypeDefinitionNode,\n  rightConfig: GraphQLScalarTypeConfig\n): GraphQLScalarTypeConfig {\n  return rightConfig ? rightConfig : (leftConfig || null)\n}\n\n/**\n * In order to facilitate merging, there needs to be some contingency plan\n * for what to do when conflicts arise. This object specifies one of each\n * type of resolver. Each simply takes the right-hand value.\n *\n * @type {Object}\n */\nexport const DefaultConflictResolvers: ConflictResolvers = {\n  /** A handler for resolving fields in matching types */\n  fieldMergeResolver: DefaultFieldMergeResolver,\n\n  /** A handler for resolving directives in matching types */\n  directiveMergeResolver: DefaultDirectiveMergeResolver,\n\n  /** A handler for resolving conflicting enum values */\n  enumValueMergeResolver: DefaultEnumMergeResolver,\n\n  /** A handler for resolving type values in unions */\n  typeValueMergeResolver: DefaultUnionMergeResolver,\n\n  /** A handler for resolving scalar configs in custom scalars */\n  scalarMergeResolver: DefaultScalarMergeResolver\n};\n\nconst subTypeResolverMap: Map<string, Function> = new Map()\nsubTypeResolverMap.set('fields', 'fieldMergeResolver')\nsubTypeResolverMap.set('directives', 'directiveMergeResolver')\nsubTypeResolverMap.set('values', 'enumValueMergeResolver')\nsubTypeResolverMap.set('types', 'typeValueMergeResolver')\nsubTypeResolverMap.set('scalars', 'scalarMergeResolver')\n\n/**\n * Compares and combines a subset of ASTNode fields. Designed to work on all\n * the various types that might have a merge conflict.\n *\n * @param {string} subTypeName the name of the field type; one of the following\n * values: 'fields', 'directives', 'values', 'types'\n * @param {ASTNode} lType the lefthand type containing the subtype to compare\n * @param {ASTNode} lSubType the lefthand subtype; fields, directive, value or\n * named union type\n * @param {ASTNode} rType the righthand type containing the subtype to compare\n * @param {ASTNode} rSubType the righthand subtype; fields, directive, value or\n * named union type\n */\nfunction combineTypeAndSubType(\n  subTypeName: string,\n  lType: ASTNode,\n  rType: ASTNode,\n  conflictResolvers: ConflictResolvers = DefaultConflictResolvers\n): void {\n  if (rType[subTypeName]) {\n    for (let rSubType of rType[subTypeName]) {\n      let lSubType = lType[subTypeName].find(\n        f => f.name.value == rSubType.name.value\n      )\n\n      if (!lSubType) {\n        lType[subTypeName].push(rSubType)\n        continue\n      }\n\n      let resolver = subTypeResolverMap.get(subTypeName) || 'fieldMergeResolver'\n      let resultingSubType = conflictResolvers[resolver](\n        lType, lSubType, rType, rSubType\n      )\n      let index = lType.fields.indexOf(lSubType)\n\n      lType[subTypeName].splice(index, 1, resultingSubType)\n    }\n  }\n}\n\n/**\n * Compares a subset of ASTNode fields. Designed to work on all the various\n * types that might have a merge conflict.\n *\n * @param {string} subTypeName the name of the field type; one of the following\n * values: 'fields', 'directives', 'values', 'types'\n * @param {ASTNode} lType the lefthand type containing the subtype to compare\n * @param {ASTNode} lSubType the lefthand subtype; fields, directive, value or\n * named union type\n * @param {ASTNode} rType the righthand type containing the subtype to compare\n * @param {ASTNode} rSubType the righthand subtype; fields, directive, value or\n * named union type\n */\nfunction pareTypeAndSubType(\n  subTypeName: string,\n  lType: ASTNode,\n  rType: ASTNode,\n  resolvers: Object = {}\n): void {\n  for (let rSubType of rType[subTypeName]) {\n    let lSubType = lType[subTypeName].find(\n      f => f.name.value == rSubType.name.value\n    )\n\n    if (!lSubType) {\n      continue\n    }\n\n    let index = lType.fields.indexOf(lSubType)\n    lType[subTypeName].splice(index, 1)\n\n    if (\n      resolvers[lType.name.value]\n      && resolvers[lType.name.value][lSubType.name.value]\n    ) {\n      delete resolvers[lType.name.value][lSubType.name.value]\n    }\n    else if (resolvers[lSubType.name.value]) {\n      delete resolvers[lSubType.name.value]\n    }\n  }\n}\n\n/**\n * Small function that sorts through the typeDefs value supplied which can be\n * any one of a Schemata instance, GraphQLSchema instance, Source instance or a\n * string.\n *\n * @param {string|Source|Schemata|GraphQLSchema} typeDefs the input source from\n * which to create a Schemata string\n * @return {string} a string representing the thing supplied as typeDefs\n */\nexport function normalizeSource(\n  typeDefs: string | Source | Schemata | GraphQLSchema,\n  wrap: boolean = false\n): (string | Schemata) {\n  if (!typeDefs) {\n    throw new Error(inline`\n      normalizeSource(typeDefs): typeDefs was invalid when passed to the\n      function \\`normalizeSource\\`. Please check your code and try again.\n\n      (received: ${typeDefs})\n    `)\n  }\n\n  let source = typeDefs.body\n    || typeDefs.sdl\n    || (typeof typeDefs === 'string' && typeDefs)\n    || (typeDefs instanceof GraphQLSchema\n      ? printSchema(typeDefs)\n      : typeDefs.toString())\n\n  return wrap ? Schemata.from(source) : source;\n}\n\n/**\n * A small `String` extension that makes working with SDL/IDL text far easier\n * in both your own libraries as well as in a nodeJS REPL. Built-in to what\n * appears to be a normal String for all intents and purposes, are the ability\n * to transform the string into a set of AST nodes, a built schema or back to\n * the SDL string.\n *\n * @class  Schemata\n */\nexport class Schemata extends String {\n  /**\n   * Creates a new `String`, presumably of SDL or IDL. The getter `.valid`\n   * will provide some indication as to whether or not the code is valid.\n   *\n   * @constructor\n   * @memberOf Schemata\n   *\n   * @param {string|Schemata|Source|GraphQLSchema} typeDefs an instance\n   * of Schemata, a string of SDL, a Source instance of SDL or a GraphQLSchema\n   * that can be printed as an SDL string\n   * @param {Object} resolvers an object containing field resolvers for\n   * for the schema represented with this string. [Optional]\n   */\n  constructor(\n    typeDefs: string | Source | Schemata | GraphQLSchema,\n    resolvers: ?Object = null\n  ) {\n    super(normalizeSource(typeDefs))\n\n    resolvers = (\n      resolvers\n      || typeDefs instanceof Schemata && typeDefs.resolvers\n      || typeDefs instanceof GraphQLSchema && stripResolversFromSchema(typeDefs)\n      || null\n    )\n\n    this[GRAPHIQL_FLAG] = true\n    this[TYPEDEFS_KEY] = normalizeSource(typeDefs)\n    this[MAP] = new WeakMap()\n    this[MAP].set(\n      wmkSchema,\n      typeDefs instanceof GraphQLSchema ? typeDefs : null\n    )\n    this[MAP].set(wmkResolvers, resolvers)\n\n    // Mark a schema passed to use in the constructor as an executable schema\n    // to prevent any replacement of the value by getters that generate a\n    // schema from the SDL\n    if (this[MAP].get(wmkSchema)) {\n      this[MAP].get(wmkSchema)[EXE] = true\n      this[MAP].get(wmkSchema)[Symbol.for('constructor-supplied-schema')] = true\n    }\n  }\n\n  /**\n   * Symbol.species ensures that any String methods used on this instance will\n   * result in a Schemata instance rather than a String. NOTE: this does not\n   * work as expected in current versions of node. This bit of code here is\n   * basically a bit of future proofing for when Symbol.species starts working\n   * with String extended classes\n   *\n   * @type {Function}\n   */\n  static get [Symbol.species](): Function { return Schemata }\n\n  /**\n   * Ensures that instances of Schemata report internally as Schemata object.\n   * Specifically using things like `Object.prototype.toString`.\n   *\n   * @type {string}\n   */\n  get [Symbol.toStringTag](): string { return this.constructor.name }\n\n  /**\n   * Returns the AST nodes for this snippet of SDL. It will throw an error\n   * if the string is not valid SDL/IDL.\n   *\n   * @return {ASTNode} any valid ASTNode supported by GraphQL\n   */\n  get ast(): ASTNode { return this.constructor.parse(this.sdl, false) }\n\n  /**\n   * Retrieves the `graphiql` flag, which defaults to true. This flag can\n   * make setting up an endpoint from a Schemata instance easier with express-graphql\n   *\n   * @type {boolean}\n   */\n  get graphiql(): boolean { return this[GRAPHIQL_FLAG] }\n\n  /**\n   * Setter to alter the default 'true' flag to make an Schemata instance a\n   * valid single argument to functions like `graphqlHTTP()` from express\n   * GraphQL.\n   *\n   * NOTE: this flag means nothing to the Schemata class but might be useful in\n   * your project.\n   *\n   * @type {boolean} true if graphiql should be started; false otherwise\n   */\n  set graphiql(value: boolean): void { this[GRAPHIQL_FLAG] = value }\n\n  /**\n   * Returns a GraphQLSchema object. Note this will fail and throw an error\n   * if there is not at least one Query, Subscription or Mutation type defined.\n   * If there is no stored schema, and there are resolvers, an executable\n   * schema is returned instead.\n   *\n   * @return {GraphQLSchema} an instance of GraphQLSchema if valid SDL\n   */\n  get schema(): GraphQLSchema {\n    if (this[MAP].get(wmkSchema)) {\n      return this[MAP].get(wmkSchema)\n    }\n\n    try {\n      if (this.resolvers && Object.keys(this.resolvers).length) {\n        return this.executableSchema\n      }\n      else {\n        this[MAP].set(wmkSchema, this.constructor.buildSchema(this.sdl, true))\n        this[MAP].get(wmkSchema)[EXE] = false\n      }\n    }\n    catch (error) {\n      return null\n    }\n\n    return this[MAP].get(wmkSchema)\n  }\n\n  /**\n   * Sets a GraphQLSchema object on the internal weak map store.\n   *\n   * @param {GraphQLSchema} schema an instance of GraphQLSchema instance to\n   * store on the internal weak map. Any schema stored here will be modified\n   * by methods that do so.\n   */\n  set schema(schema: ?GraphQLSchema): void {\n    this[MAP].set(wmkSchema, schema)\n  }\n\n  /**\n   * Returns a GraphQLSchema object, pre-bound, to the associated resolvers\n   * methods in `.resolvers`. If `.resolvers` is falsey, an error will be\n   * thrown.\n   *\n   * @return {GraphQLSchema} an instance of GraphQLSchema with pre-bound\n   * resolvers\n   */\n  get executableSchema(): GraphQLSchema {\n    const isRootType = (t) => {\n      if (t === undefined || t === null || !t) {\n        return false;\n      }\n\n      let name = (typeof t.name === 'string') ? t.name : t.name.value\n\n      return ((t instanceof GraphQLObjectType) &&\n        (t.name === 'Query'\n        || t.name === 'Mutation'\n        || t.name === 'Subscription')\n      )\n    }\n    const Class = this.constructor\n    const resolvers = this.resolvers\n    let schema\n\n    if (this[MAP].get(wmkSchema) && this.resolvers) {\n      schema = this[MAP].get(wmkSchema)\n\n      if (schema && schema[EXE]) {\n        return schema\n      }\n    }\n\n    try {\n      this[MAP].set(wmkSchema, (schema = Class.buildSchema(this.sdl, true)))\n    }\n    catch (error) {\n      return null\n    }\n\n    this.forEachField((\n      type, typeName, typeDirectives,\n      field, fieldName, fieldArgs, fieldDirectives,\n      schema, context\n    ) => {\n      if (!resolvers) { return }\n\n      if (isRootType(type) && resolvers[fieldName]) {\n        field.resolve = resolvers[fieldName]\n        field.astNode.resolve = resolvers[fieldName]\n      }\n\n      if (resolvers[typeName] && resolvers[typeName][fieldName]) {\n        field.resolve = resolvers[typeName][fieldName]\n        field.astNode.resolve = resolvers[typeName][fieldName]\n      }\n    })\n\n    schema[EXE] = true\n    this[MAP].set(wmkSchema, schema)\n\n    return schema;\n  }\n\n  /**\n   * Returns the string this instance was generated with.\n   *\n   * @return {string} the string this class instance represents\n   */\n  get sdl(): string { return this[TYPEDEFS_KEY] }\n\n  /**\n   * A synonym or alias for `.sdl`. Placed here for the express purpose of\n   * destructuing when used with Apollo's makeExecutableSchema or other\n   * libraries expecting values of the same name\n   *\n   * i.e.\n   *   // sdl.typeDefs and sdl.resolvers will be where the function expects\n   *   let schema = require('graphql-tools').makeExecutableSchema(sdl)\n   *\n   * @return {string} a string of SDL/IDL for use with graphql\n   */\n  get typeDefs(): string { return this.sdl }\n\n  /**\n   * An internal call to buildResolvers(true), thereby requesting a flattened\n   * resolver map with Query, Mutation and Subscription fields exposed as root\n   * objects the way the Facebook reference implementation expects\n   *\n   * @return {Object} an object of functions or an empty object otherwise\n   */\n  get rootValue(): Object { return this.buildResolvers(true) }\n\n  /**\n   * Returns any resolvers function object associated with this instance.\n   *\n   * @return {Object} an object containing field resolvers or null if none\n   * are stored within\n   */\n  get resolvers(): Object { return this[MAP].get(wmkResolvers) }\n\n  /**\n   * A method to fetch a particular field resolver from the schema represented\n   * by this Schemata instance.\n   *\n   * @param {string} type the name of the type desired\n   * @param {string} field the name of the field containing the resolver\n   * @return {Function} the function resolver for the type and field in\n   * question\n   */\n  schemaResolverFor(type: string, field: string): ?Function {\n    if (\n      !this.resolvers\n      || !Object.keys(this.resolvers).length\n      || !this.valid\n    ) {\n      return null\n    }\n\n    let _type = this.executableSchema.getType(type)\n    let _field = _type.getFields() && _type.getFields()[field] || null\n    let resolve = _field && _field.resolve || null\n\n    return resolve\n  }\n\n  /**\n   * Builds a schema based on the SDL in the instance and then parses it to\n   * fetch a named field in a named type. If either the type or field are\n   * missing or if the SDL cannot be built as a schema, null is returned.\n   *\n   * @param {string} type the name of a type\n   * @param {string} field the name of a field contained in the above type\n   * @return {FieldNode} the field reference in the type and field supplied\n   */\n  schemaFieldByName(type: string, field: string): FieldNode {\n    if (!this.validSchema) { return null }\n\n    let _type = this.schema.getType(type)\n    let _field = _type.getFields() && _type.getFields()[field] || null\n\n    return _field\n  }\n\n  /**\n   * For SDL that doesn't properly build into a GraphQLSchema, it can still be\n   * parsed and searched for a type by name.\n   *\n   * @param {string} type the name of a type\n   * @return {FieldNode} the field reference in the type and field supplied\n   */\n  astTypeByName(type: string): ASTNode {\n    if (!this.validSDL) { return null }\n\n    let _type = this.ast.definitions.find(f => f.name.value === type)\n\n    return _type\n  }\n\n  /**\n   * For SDL that doesn't properly build into a GraphQLSchema, it can still be\n   * searched for a type and field.\n   *\n   * @param {string} type the name of a type\n   * @param {string} field the name of a field contained in the above type\n   * @return {FieldNode} the field reference in the type and field supplied\n   */\n  astFieldByName(type: string, field: string): FieldNode {\n    if (!this.validSDL) { return null }\n\n    let _type = this.ast.definitions.find(f => f.name.value === type)\n    let _field = _type && _type.fields.find(f => f.name.value === field) || null\n\n    return _field\n  }\n\n  /**\n   * Walks the AST for this SDL string and checks for the names of the fields\n   * of each of the root types; Query, Mutation and Subscription. If there are\n   * no root types defined, false is returned.\n   *\n   * If there is at least one root type *and* some resolvers *and* at least one\n   * of the fields of at least one root type is present in the root of the\n   * resolvers map, true is returned. Otherwise, false.\n   *\n   * @return {boolean} true if the defined resolvers have at least one root\n   * type field as a resolver on the root of the resolver map; false otherwise.\n   */\n  get hasFlattenedResolvers(): boolean {\n    let asts = this.validSDL && this.ast.definitions || null\n\n    if (!asts || !this.resolvers) { return false }\n\n    let query = asts.find(f => f.name.value == 'Query')\n    let mutation = asts.find(f => f.name.value == 'Mutation')\n    let subscription = asts.find(f => f.name.value == 'Subscription')\n    let resolvers = this.resolvers\n\n    if (!query && !mutation && !subscription) {\n      return false\n    }\n\n    for (let type of [query, mutation, subscription]) {\n      if (!type || !type.fields) { continue }\n\n      for (let field of type.fields) {\n        if (field.name.value in resolvers) {\n          return true\n        }\n      }\n    }\n\n    return false\n  }\n\n  /**\n   * Merging Schematas are a common feature in the modern world of GraphQL.\n   * Especially when there are multiple teams working in tandem. This feature\n   * supports merging of types, extended types, interfaces, enums, unions,\n   * input object types and directives for all of the above.\n   *\n   * @param {string|Schemata|Source|GraphQLSchema} schemaLanguage an instance\n   * of Schemata, a string of SDL, a Source instance of SDL or a GraphQLSchema\n   * that can be printed as an SDL string to define what to merge with the\n   * values in this object instance\n   * @param {ConflictResolvers} conflictResolvers an object containing up to\n   * four methods, each describing how to handle a conflict when an associated\n   * type of conflict occurs. If no object or method are supplied, the right\n   * hande value always takes precedence over the existing value; replacing it\n   * @return {Schemata} a new instance of Schemata\n   */\n  mergeSDL(\n    schemaLanguage: string | Schemata | Source | GraphQLSchema,\n    conflictResolvers: ?ConflictResolvers = DefaultConflictResolvers\n  ): Schemata {\n    let source = normalizeSource(schemaLanguage, true)\n\n    if (!source) {\n      throw new Error(inline`\n        The call to mergeSDL(schemaLanguage, conflictResolvers) received an\n        invalid value for schemaLanguage. Please check your code and try again.\n        Received ${schemaLanguage}.\n      `)\n    }\n\n    let lAST = this.ast\n    let rAST = source.ast\n    let _scalarFns = {}\n\n    // Ensure we have default behavior with any custom behavior assigned\n    // atop the default ones should only a partial custom be supplied.\n    conflictResolvers = Object.assign(\n      DefaultConflictResolvers,\n      conflictResolvers\n    )\n\n    for (let rType of rAST.definitions) {\n      let lType = lAST.definitions.find(a => a.name.value == rType.name.value)\n\n      if (\n        rType.kind\n        && rType.kind.endsWith\n        && rType.kind.endsWith('Extension')\n      ) {\n        rType = Object.assign({}, rType)\n        rType.kind =\n          rType.kind.substring(0, rType.kind.length - 9) + 'Definition'\n      }\n\n      if (!lType) {\n        lAST.definitions.push(rType)\n        continue\n      }\n\n      switch (lType.kind) {\n        default:\n        case 'ObjectTypeDefinition':\n        case 'ObjectTypeDefinitionExtension':\n        case 'InterfaceTypeDefinition':\n        case 'InterfaceTypeDefinitionExtension':\n        case 'InputObjectTypeDefinition':\n        case 'InputObjectTypeDefinitionExtension':\n          combineTypeAndSubType('directives', lType, rType, conflictResolvers)\n          combineTypeAndSubType('fields', lType, rType, conflictResolvers)\n          break;\n\n        case 'EnumTypeDefinition':\n          combineTypeAndSubType('directives', lType, rType, conflictResolvers)\n          combineTypeAndSubType('values', lType, rType, conflictResolvers)\n          break;\n\n        case 'UnionTypeDefinition':\n          combineTypeAndSubType('directives', lType, rType, conflictResolvers)\n          combineTypeAndSubType('types', lType, rType, conflictResolvers)\n          break;\n\n        case 'ScalarTypeDefinitionNode':\n          let lScalar, lScalarConfig, rScalar, rScalarConfig, resolver\n\n          combineTypeAndSubType('directives', lType, rType, conflictResolvers)\n\n          if (this.schema) {\n            lScalar = this.schema.getType(lType.name.value)\n            lScalarConfig = lScalar && lScalar._scalarConfig || null\n          }\n\n          if (source.schema) {\n            rScalar = source.schema.getType(rType.name.value)\n            rScalarConfig = rScalar && rScalar._scalarConfig || null\n          }\n\n          resolver = (\n            conflictResolvers.scalarMergeResolver\n            || DefaultConflictResolvers.scalarMergeResolver\n          )(lType, lScalarConfig, rType, rScalarConfig)\n\n          if (resolver) {\n            _scalarFns[lType.name.value] = _scalarFns[lType.name.value] || {}\n            _scalarFns[lType.name.value] = resolver\n          }\n\n          break;\n      }\n    }\n\n    let merged = Schemata.from(this.constructor.gql.print(lAST))\n\n    if (Object.keys(_scalarFns).length) {\n      for (let typeName of Object.keys(_scalarFns)) {\n        merged.schema.getType(typeName)._scalarConfig = _scalarConfig[typeName]\n      }\n    }\n\n    return merged\n  }\n\n  /**\n   * Paring down Schematas can be handy for certain types of schema stitching.\n   * The SDL passed in and any associated resolvers will be removed from\n   * a copy of the SDL in this Schemata instance represents and the resolver\n   * map passed in.\n   *\n   * @param {string|Schemata|Source|GraphQLSchema} schemaLanguage an instance\n   * of Schemata, a string of SDL, a Source instance of SDL or a GraphQLSchema\n   * that can be printed as an SDL string to define what to pare with the\n   * values in this object instance\n   * @param {Object} resolverMap an object containing resolver functions, from\n   * either those set on this instance or those in the resolverMap added in\n   * @return {Schemata} a new Schemata instance with the changed values set\n   * on it\n   */\n  pareSDL(\n    schemaLanguage: string | Schemata | Source | GraphQLSchema,\n    resolverMap: ?Object = null\n  ): Schemata {\n    let source = normalizeSource(schemaLanguage, true)\n    if (!source) {\n      throw new Error(inline`\n        In the call to pareSDL(schemaLanguage), the supplied value for\n        \\`schemaLanguage\\` could not be parsed.\n      `)\n    }\n\n    if (schemaLanguage instanceof GraphQLSchema && !resolverMap) {\n      resolverMap = stripResolversFromSchema(schemaLanguage)\n    }\n\n    let resolvers = Object.assign({}, resolverMap || this.resolvers || {})\n    let lAST = this.ast\n    let rAST = source.ast\n\n    for (let rType of rAST.definitions) {\n      let lType = lAST.definitions.find(a => a.name.value == rType.name.value)\n\n      if (\n        rType.kind\n        && rType.kind.endsWith\n        && rType.kind.endsWith('Extension')\n      ) {\n        let len = 'Extension'.length\n\n        rType = Object.assign({}, rType)\n        rType.kind =\n          rType.kind.substring(0, rType.kind.length - len) + 'Definition'\n      }\n\n      if (!lType) {\n        lAST.definitions.push(rType)\n        continue\n      }\n\n      switch (lType.kind) {\n        default:\n        case 'ObjectTypeDefinition':\n        case 'ObjectTypeDefinitionExtension':\n        case 'InterfaceTypeDefinition':\n        case 'InterfaceTypeDefinitionExtension':\n        case 'InputObjectTypeDefinition':\n        case 'InputObjectTypeDefinitionExtension':\n          pareTypeAndSubType('directives', lType, rType, resolvers)\n          pareTypeAndSubType('fields', lType, rType, resolvers)\n\n          if (!lType.fields.length) {\n            let index = lAST.definitions.indexOf(lType)\n\n            if (index !== -1) {\n              lAST.definitions.splice(index, 1)\n            }\n          }\n          break;\n\n        case 'EnumTypeDefinition':\n          pareTypeAndSubType('directives', lType, rType, resolvers)\n          pareTypeAndSubType('values', lType, rType, resolvers)\n\n          if (!lType.values.length) {\n            let index = lAST.definitions.indexOf(lType)\n\n            if (index !== -1) {\n              lAST.definitions.splice(index, 1)\n            }\n          }\n          break;\n\n        case 'UnionTypeDefinition':\n          pareTypeAndSubType('directives', lType, rType, resolvers)\n          pareTypeAndSubType('types', lType, rType, resolvers)\n\n          if (!lType.types.length) {\n            let index = lAST.definitions.indexOf(lType)\n\n            if (index !== -1) {\n              lAST.definitions.splice(index, 1)\n            }\n          }\n          break;\n\n        case 'ScalarTypeDefinitionNode':\n          let index = lAST.definitions.indexOf(lType)\n\n          if (index !== -1) {\n            lAST.definitions.splice(index, 1)\n          }\n          break;\n      }\n    }\n\n    let result = Schemata.from(this.constructor.gql.print(lAST), resolvers)\n    result.executableSchema\n\n    return result\n  }\n\n  /**\n   * A new Schemata object instance with merged schema definitions as its\n   * contents as well as merged resolvers and newly bound executable schema are\n   * all created in this step and passed back. The object instance itself is\n   * not modified\n   *\n   * Post merge, the previously stored and merged resolvers map are are applied\n   * and a new executable schema is built from the ashes of the old.\n   *\n   * @param {GraphQLSchema} schema an instance of GraphQLSchema to merge\n   * @param {ConflictResolvers} conflictResolvers an object containing up to\n   * four methods, each describing how to handle a conflict when an associated\n   * type of conflict occurs. If no object or method are supplied, the right\n   * hande value always takes precedence over the existing value; replacing it\n   * @return {Schemata} a new instance of Schemata with a merged schema string,\n   * merged resolver map and newly bound executable schema attached are all\n   * initiated\n   */\n  mergeSchema(\n    schema: GraphQLSchema,\n    conflictResolvers: ?ConflictResolvers = DefaultConflictResolvers\n  ): Schemata {\n    if (!schema) {\n      throw new Error(inline`\n        In the call to mergeSchema(schema), ${schema} was received as a value\n        and the code could not proceed because of it. Please check your code\n        and try again\n      `)\n    }\n\n    let resolvers = this.buildResolvers()\n    let mergeResolvers = stripResolversFromSchema(schema)\n\n    resolvers = merge(this.buildResolvers(), mergeResolvers)\n\n    let schemata = this.mergeSDL(schema)\n\n    // Set the resolvers\n    schemata.resolvers = resolvers\n\n    // Trigger a new schema creation\n    schemata.executableSchema\n\n    return schemata\n  }\n\n  /**\n   * Given a schema, based on the Schemata this object is based on, walk it and\n   * build up a resolver map. This function will always return a non-null\n   * object. It will be empty if there are either no resolvers to be found\n   * in the schema or if a valid schema cannot be created.\n   *\n   * @param {boolean|Object} flattenRootResolversOrFirstParam if this value is\n   * boolean, and if this value is true, the resolvers from Query, Mutation\n   * and Subscription types will be flattened to the root of the object. If\n   * the first parametr is an Object, it will be merged in normally with\n   * Object.assign.\n   * @param {Array<Object>} ...extendWith an unlimited array of objects that\n   * can be used to extend the built resolver map.\n   * @return {Object} a resolver map; i.e. an object of resolver functions\n   */\n  buildResolvers(\n    flattenRootResolversOrFirstParam: boolean|Object,\n    ...extendWith: Array<Object>\n  ): Object {\n    let schemata = Schemata.from(this.sdl, this.resolvers)\n    let resolvers = Object.assign({},\n      (stripResolversFromSchema(schemata.executableSchema)\n        || schemata.resolvers\n        || {}\n      )\n    )\n\n    // Next check to see if we are flattening or simply extending\n    if (typeof flattenRootResolversOrFirstParam === 'boolean') {\n      for (let rootType of ['Query', 'Mutation', 'Subscription']) {\n        if (flattenRootResolversOrFirstParam) {\n          if (resolvers[rootType]) {\n            for (let field of Object.keys(resolvers[rootType])) {\n              resolvers[field] = resolvers[rootType][field]\n              delete resolvers[rootType][field]\n            }\n\n            delete resolvers[rootType]\n          }\n        }\n        else {\n          for (let field of Object.keys(resolvers)) {\n            if (schemata.schemaFieldByName(rootType, field)) {\n              resolvers[rootType] = resolvers[rootType] || {}\n              resolvers[rootType][field] = resolvers[field]\n              delete resolvers[field]\n            }\n          }\n        }\n      }\n    }\n    else {\n      Object.assign(resolvers, flattenRootResolversOrFirstParam)\n    }\n\n    // Finally extend with any remaining arguments\n    if (extendWith.length) {\n      Object.assign(resolvers, ...extendWith)\n    }\n\n    return resolvers\n  }\n\n  /**\n   * A method to determine if an executable schema is attached to this Schemata\n   * instance. It does so by walking the schema fields via `buildResolvers()`\n   * and reporting whether there is anything inside the results or not.\n   *\n   * @return {boolean} true if there is at least one resolver on at least one\n   * field of a type in this Schemata instance's schema.\n   */\n  get hasAnExecutableSchema(): boolean {\n    return Object.keys(this.buildResolvers()).length > 0;\n  }\n\n  /**\n   * If the `.sdl` property is valid SDL/IDL and can generate valid AST nodes\n   * this function will return true. It will return false otherwise.\n   *\n   * @return {boolean} true if the string can be parsed; false otherwise\n   */\n  get validSDL(): boolean {\n    try {\n      this.constructor.gql.parse(this.sdl)\n      return true\n    }\n    catch(e) {\n      return false\n    }\n  }\n\n  /**\n   * If the `.schema` property is valid SDL/IDL and can generate a valid\n   * GraphQLSchema, this function will return true. It will return false\n   * otherwise.\n   *\n   * @return {boolean} true if the string can be parsed into a schema; false\n   * otherwise\n   */\n  get validSchema(): boolean {\n    try {\n      this.schema;\n      return true\n    }\n    catch (e) {\n      return false\n    }\n  }\n\n  /**\n   * Returns true if the string underlying this instance represents valid SDL\n   * that can be both converted to AST nodes or a valid GraphQLSchema instance\n   *\n   * @return {boolean} true if it is valid for both `parse()` as well as the\n   * `buildSchema()` function\n   */\n  get valid(): boolean { return this.validSDL && this.validSchema }\n\n\n  /**\n   * If the internal resolvers object needs to be changed after creation, this\n   * method allows a way to do so. Setting the value to `null` is equivalent\n   * to removing any stored value. Finally the contents are stored in a weak\n   * map so its contents are not guaranteed over a long period of time.\n   *\n   * @param {Object} resolvers an object containing field resolvers for this\n   * string instance.\n   */\n  set resolvers(resolvers: ?Object): void {\n    this[MAP].set(wmkResolvers, resolvers)\n  }\n\n  /**\n   * Removes the resolver map associated with this Schemata instance\n   */\n  clearResolvers(): void {\n    this.resolvers = null\n  }\n\n  /**\n   * Removes the schema stored with this Schemata instance\n   */\n  clearSchema(): void {\n    this.schema = null\n  }\n\n  /**\n   * Returns the underlying string passed or generated in the constructor when\n   * inspected in the nodeJS REPL.\n   *\n   * @return {string} the SDL/IDL string this class was created on\n   */\n  inspect(): string { return this.sdl }\n\n  /**\n   * The same as `inspect()`, `toString()`, and `valueOf()`. This method\n   * returns the underlying string this class instance was created on.\n   *\n   * @return {string} [description]\n   */\n  toString(): string { return this.sdl }\n\n  /**\n   * The same as `inspect()`, `toString()`, and `valueOf()`. This method\n   * returns the underlying string this class instance was created on.\n   *\n   * @return {string} [description]\n   */\n  valueOf(): string { return this.sdl }\n\n  /**\n   * Iterates over the values contained in a Schema's typeMap. If a desired\n   * value is encountered, the supplied callback will be invoked. The values are\n   * the constants ALL, TYPES, INTERFACES, ENUMS, UNIONS and SCALARS. Optionally\n   * HIDDEN is another value that can be bitmasked together for a varied result.\n   * HIDDEN exposes the values in the schema typemap that begin with a double\n   * underscore.\n   *\n   * The signature for the function callback is as follows:\n   * (\n   *   type: mixed,\n   *   typeName: string,\n   *   typeDirectives: Array<GraphQLDirective>\n   *   schema: GraphQLSchema,\n   *   context: mixed,\n   * ) => void\n   *\n   * Where:\n   *   `type`           - the object instance from within the `GraphQLSchema`\n   *   `typeName`       - the name of the object; \"Query\" for type Query and\n   *                      so on.\n   *   `typeDirectives` - an array of directives applied to the object or an\n   *                      empty array if there are none applied.\n   *   `schema`         - an instance of `GraphQLSchema` over which to iterate\n   *   `context`        - usually an object, and usually the same object,\n   *                      passed to the call to `makeExecutableSchema()`\n   *                      or `graphql()`\n   *\n   * @param {Function} fn a function with a signature defined above\n   * @param {mixed} context usually an object but any mixed value the denotes\n   * some shared context as is used with the schema during normal runtime.\n   * @param {Number} types a bitmask of one or more of the constants defined\n   * above. These can be OR'ed together and default to TYPES.\n   * @param {GraphQLSchema} suppliedSchema an optional schema to use rather\n   * than the one created or stored internally generated from this SDL\n   * @return {GraphQLSchema} a new schema is generated from this SDL, iterated\n   * over and returned.\n   */\n  forEachOf(\n    fn: ForEachOfResolver,\n    context: mixed,\n    types: number = TYPES,\n    suppliedSchema: ?GraphQLSchema = null\n  ): GraphQLSchema {\n    let schema = suppliedSchema || this.schema\n\n    forEachOf(schema, fn, context, types)\n\n    return schema\n  }\n\n  /**\n   * Shortcut to `forEachOf()` specific to types.\n   *\n   * @see #forEachOf\n   *\n   * @param {Function} fn a function with a signature defined above\n   * @param {mixed} context usually an object but any mixed value the denotes\n   * some shared context as is used with the schema during normal runtime.\n   * @param {GraphQLSchema} suppliedSchema an optional schema to use rather\n   * than the one created or stored internally generated from this Schemata\n   * @return {GraphQLSchema} a new schema is generated from this Schemata, iterated\n   * over and returned.\n   */\n  forEachType(\n    fn: ForEachOfResolver,\n    context: mixed,\n    suppliedSchema: ?GraphQLSchema\n  ): GraphQLSchema {\n    return this.forEachOf(fn, context, TYPES, suppliedSchema)\n  }\n\n  /**\n   * Shortcut to `forEachOf()` specific to input object types.\n   *\n   * @see #forEachOf\n   *\n   * @param {Function} fn a function with a signature defined above\n   * @param {mixed} context usually an object but any mixed value the denotes\n   * some shared context as is used with the schema during normal runtime.\n   * @param {GraphQLSchema} suppliedSchema an optional schema to use rather\n   * than the one created or stored internally generated from this Schemata\n   * @return {GraphQLSchema} a new schema is generated from this Schemata, iterated\n   * over and returned.\n   */\n  forEachInputObjectType(\n    fn: ForEachOfResolver,\n    context: mixed,\n    suppliedSchema: ?GraphQLSchema\n  ): GraphQLSchema {\n    return this.forEachOf(fn, context, INPUT_TYPES, suppliedSchema)\n  }\n\n  /**\n   * Shortcut to `forEachOf()` specific to unions.\n   *\n   * @see #forEachOf\n   *\n   * @param {Function} fn a function with a signature defined above\n   * @param {mixed} context usually an object but any mixed value the denotes\n   * some shared context as is used with the schema during normal runtime.\n   * @param {GraphQLSchema} suppliedSchema an optional schema to use rather\n   * than the one created or stored internally generated from this SDL\n   * @return {GraphQLSchema} a new schema is generated from this SDL, iterated\n   * over and returned.\n   */\n  forEachUnion(\n    fn: ForEachOfResolver,\n    context: mixed,\n    suppliedSchema: ?GraphQLSchema\n  ): GraphQLSchema {\n    return this.forEachOf(fn, context, UNIONS, suppliedSchema)\n  }\n\n  /**\n   * Shortcut to `forEachOf()` specific to enums.\n   *\n   * @see #forEachOf\n   *\n   * @param {Function} fn a function with a signature defined above\n   * @param {mixed} context usually an object but any mixed value the denotes\n   * some shared context as is used with the schema during normal runtime.\n   * @param {GraphQLSchema} suppliedSchema an optional schema to use rather\n   * than the one created or stored internally generated from this SDL\n   * @return {GraphQLSchema} a new schema is generated from this SDL, iterated\n   * over and returned.\n   */\n  forEachEnum(\n    fn: ForEachOfResolver,\n    context: mixed,\n    suppliedSchema: ?GraphQLSchema\n  ): GraphQLSchema {\n    return this.forEachOf(fn, context, ENUMS, suppliedSchema)\n  }\n\n  /**\n   * Shortcut to `forEachOf()` specific to interfaces.\n   *\n   * @see #forEachOf\n   *\n   * @param {Function} fn a function with a signature defined above\n   * @param {mixed} context usually an object but any mixed value the denotes\n   * some shared context as is used with the schema during normal runtime.\n   * @param {GraphQLSchema} suppliedSchema an optional schema to use rather\n   * than the one created or stored internally generated from this SDL\n   * @return {GraphQLSchema} a new schema is generated from this SDL, iterated\n   * over and returned.\n   */\n  forEachInterface(\n    fn: ForEachOfResolver,\n    context: mixed,\n    suppliedSchema: ?GraphQLSchema\n  ): GraphQLSchema {\n    return this.forEachOf(fn, context, INTERFACES, suppliedSchema)\n  }\n\n  /**\n   * Shortcut to `forEachOf()` specific to types.\n   *\n   * @see #forEachOf\n   *\n   * @param {Function} fn a function with a signature defined above\n   * @param {mixed} context usually an object but any mixed value the denotes\n   * some shared context as is used with the schema during normal runtime.\n   * @param {GraphQLSchema} suppliedSchema an optional schema to use rather\n   * than the one created or stored internally generated from this SDL\n   * @return {GraphQLSchema} a new schema is generated from this SDL,\n   * iterated over and returned.\n   */\n  forEachScalar(\n    fn: ForEachOfResolver,\n    context: mixed,\n    suppliedSchema: ?GraphQLSchema\n  ): GraphQLSchema {\n    return this.forEachOf(fn, context, SCALARS, suppliedSchema)\n  }\n\n  /**\n   * Shortcut to `forEachOf()` specific to all root types; Query, Mutation and\n   * Subscription that exist within the schema.\n   *\n   * @see #forEachOf\n   *\n   * @param {Function} fn a function with a signature defined above\n   * @param {mixed} context usually an object but any mixed value the denotes\n   * some shared context as is used with the schema during normal runtime.\n   * @param {GraphQLSchema} suppliedSchema an optional schema to use rather\n   * than the one created or stored internally generated from this SDL\n   * @return {GraphQLSchema} a new schema is generated from this SDL, iterated\n   * over and returned.\n   */\n  forEachRootType(\n    fn: ForEachOfResolver,\n    context: mixed,\n    suppliedSchema: ?GraphQLSchema\n  ): GraphQLSchema {\n    return this.forEachOf(fn, context, ROOT_TYPES, suppliedSchema)\n  }\n\n  /**\n   * An extension of `forEachOf` that targets the fields of the types in the\n   * schema's typeMap. This function provides more detail and allows greater\n   * access to any associated `context` than the function of the same name\n   * provided by the `graphql-tools` library.\n   *\n   * The signature for the callback function is as follows\n   *\n   * (\n   *   type: mixed,\n   *   typeName: string,\n   *   typeDirectives: Array<GraphQLDirective>,\n   *   field: mixed,\n   *   fieldName: string,\n   *   fieldArgs: Array<GraphQLArgument>,\n   *   fieldDirectives: Array<GraphQLDirective>,\n   *   schema: GraphQLSchema,\n   *   context: mixed\n   * ) => void\n   *\n   * Where\n   *\n   * Where:\n   *   `type`           - the object instance from within the `GraphQLSchema`\n   *   `typeName`       - the name of the object; \"Query\" for type Query and\n   *                      so on\n   *   `typeDirectives` - an array of directives applied to the object or an\n   *                      empty array if there are none applied.\n   *   `field`          - the field in question from the type\n   *   `fieldName`      - the name of the field as a string\n   *   `fieldArgs`      - an array of arguments for the field in question\n   *   `fieldDirectives`- an array of directives applied to the field or an\n   *                      empty array should there be no applied directives\n   *   `schema`         - an instance of `GraphQLSchema` over which to iterate\n   *   `context`        - usually an object, and usually the same object, passed\n   *                      to the call to `makeExecutableSchema()` or `graphql()`\n   *\n   * @param {Function} fn a function with a signature defined above\n   * @param {mixed} context usually an object but any mixed value the denotes\n   * some shared context as is used with the schema during normal runtime.\n   * @param {GraphQLSchema} suppliedSchema an optional schema to use rather\n   * than the one created or stored internally generated from this SDL\n   * @return {GraphQLSchema} a new schema is generated from this SDL, iterated\n   * over and returned.\n   */\n  forEachField(\n    fn: ForEachFieldResolver,\n    context: mixed,\n    types: number = ALL,\n    suppliedSchema: ?GraphQLSchema = null\n  ): GraphQLSchema {\n    let schema = suppliedSchema || this.schema\n\n    forEachField(schema, fn, context, types)\n\n    return schema\n  }\n\n  /**\n   * `forEachField()` shortcut focusing on GraphQLObjectTypes specifically.\n   *\n   * @param {ForEachFieldResolver} fn a callback function that is invoked for\n   * each field of any GraphQLObjectType found\n   * @param {mixed} context usually an object but any mixed value the denotes\n   * some shared context as is used with the schema during normal runtime.\n   * @param {GraphQLSchema} suppliedSchema an optional schema to use rather\n   * than the one created or stored internally generated from this SDL\n   * @return {GraphQLSchema} either the supplied GraphQLSchema or one generated\n   * to facilitate the task\n   */\n  forEachTypeField(\n    fn: ForEachFieldResolver,\n    context: mixed,\n    suppliedSchema: ?GraphQLSchema = null\n  ): GraphQLSchema {\n    let schema = suppliedSchema || this.schema\n\n    forEachField(schema, fn, context, TYPES)\n\n    return schema\n  }\n\n  /**\n   * `forEachField()` shortcut focusing on GraphQLInterfaceType specifically.\n   *\n   * @param {ForEachFieldResolver} fn a callback function that is invoked for\n   * each field of any GraphQLObjectType found\n   * @param {mixed} context usually an object but any mixed value the denotes\n   * some shared context as is used with the schema during normal runtime.\n   * @param {GraphQLSchema} suppliedSchema an optional schema to use rather\n   * than the one created or stored internally generated from this SDL\n   * @return {GraphQLSchema} either the supplied GraphQLSchema or one generated\n   * to facilitate the task\n   */\n  forEachInterfaceField(\n    fn: ForEachFieldResolver,\n    context: mixed,\n    suppliedSchema: ?GraphQLSchema = null\n  ): GraphQLSchema {\n    let schema = suppliedSchema || this.schema\n\n    forEachField(schema, fn, context, INTERFACES)\n\n    return schema\n  }\n\n  /**\n   * `forEachField()` shortcut focusing on GraphQLInputObjectType specifically.\n   *\n   * @param {ForEachFieldResolver} fn a callback function that is invoked for\n   * each field of any GraphQLObjectType found\n   * @param {mixed} context usually an object but any mixed value the denotes\n   * some shared context as is used with the schema during normal runtime.\n   * @param {GraphQLSchema} suppliedSchema an optional schema to use rather\n   * than the one created or stored internally generated from this SDL\n   * @return {GraphQLSchema} either the supplied GraphQLSchema or one generated\n   * to facilitate the task\n   */\n  forEachInputObjectField(\n    fn: ForEachFieldResolver,\n    context: mixed,\n    suppliedSchema: ?GraphQLSchema = null\n  ): GraphQLSchema {\n    let schema = suppliedSchema || this.schema\n\n    forEachField(schema, fn, context, INPUT_TYPES)\n\n    return schema\n  }\n\n  /**\n   * Wrapper for `require('graphql').graphqlSync()` that automatically passes\n   * in the internal `.schema` reference as the first parameter.\n   *\n   * @param {string|Source} query A GraphQL language formatted string\n   * representing the requested operation.\n   * @param {mixed} contextValue a bit of shared context to pass to resolvers\n   * @param {Object} variableValues A mapping of variable name to runtime value\n   * to use for all variables defined in the requestString.\n   * @param {Object|null} The value provided as the first argument to resolver\n   * functions on the top level type (e.g. the query object type).\n   * @param {string} operationName The name of the operation to use if\n   * requestString contains multiple possible operations. Can be omitted if\n   * requestString contains only one operation.\n   * @param {GraphQLFieldResolver<any, any>} fieldResolver A resolver function\n   * to use when one is not provided by the schema. If not provided, the\n   * default field resolver is used (which looks for a value or method on the\n   * source value with the field's name).\n   * @return {ExecutionResult} the requested results. An error is thrown if\n   * the results could not be fulfilled or invalid input/output was specified.\n   */\n  run(\n    query: string | Source,\n    contextValue?: mixed,\n    variableValues?: ?ObjMap<mixed>,\n    rootValue?: mixed,\n    operationName?: ?string,\n    fieldResolver?: ?GraphQLFieldResolver<any,any>\n  ): ExecutionResult {\n    return this.constructor.gql.graphqlSync(\n      this.schema,\n      query,\n      this.resolvers || rootValue,\n      contextValue,\n      variableValues,\n      operationName,\n      fieldResolver,\n    )\n  }\n\n  /**\n   * Wrapper for `require('graphql').graphql()` that automatically passes\n   * in the internal `.schema` reference as the first parameter.\n   *\n   * @param {string|Source} query A GraphQL language formatted string\n   * representing the requested operation.\n   * @param {mixed} contextValue a bit of shared context to pass to resolvers\n   * @param {Object} variableValues A mapping of variable name to runtime value\n   * to use for all variables defined in the requestString.\n   * @param {Object|null} The value provided as the first argument to resolver\n   * functions on the top level type (e.g. the query object type).\n   * @param {string} operationName The name of the operation to use if\n   * requestString contains multiple possible operations. Can be omitted if\n   * requestString contains only one operation.\n   * @param {GraphQLFieldResolver<any, any>} fieldResolver A resolver function\n   * to use when one is not provided by the schema. If not provided, the\n   * default field resolver is used (which looks for a value or method on the\n   * source value with the field's name).\n   * @return {Promise<ExecutionResult>} a Promise contianing the requested\n   * results\n   */\n  async runAsync(\n    query: string | Source,\n    contextValue?: mixed,\n    variableValues?: ?ObjMap<mixed>,\n    rootValue?: mixed,\n    operationName?: ?string,\n    fieldResolver?: ?GraphQLFieldResolver<any,any>\n  ): Promise<ExecutionResult> {\n    return this.constructor.gql.graphql(\n      this.schema,\n      query,\n      this.resolvers || rootValue,\n      contextValue,\n      variableValues,\n      operationName,\n      fieldResolver,\n    )\n  }\n\n  /**\n   * A little wrapper used to catch any errors thrown when building a schema\n   * from the string SDL representation of a given instance.\n   *\n   * @param {string|Schemata|Source|GraphQLSchema} sdl an instance\n   * of Schemata, a string of SDL, a Source instance of SDL or a GraphQLSchema\n   * that can be printed as an SDL string\n   * @param {boolean} showError true if the error should be thrown, false if\n   * the error should be silently suppressed\n   * @param {BuildSchemaOptions&ParseOptions} schemaOpts for advanced users,\n   * passing through additional buildSchema() options can be done here\n   * @return {GraphQLSchema|null} null if an error occurs and errors are not\n   * surfaced or a valid GraphQLSchema object otherwise\n   */\n  static buildSchema(\n    sdl: string | Source | Schemata | GraphQLSchema,\n    showError: boolean = false,\n    schemaOpts: BuildSchemaOptions & ParseOptions = undefined\n  ): ?GraphQLSchema {\n    try {\n      let source = normalizeSource(sdl)\n\n      return this.gql.buildSchema(source, schemaOpts)\n    }\n    catch (e) {\n      if (showError) { throw e }\n      return null\n    }\n  }\n\n  /**\n   * A little wrapper used to catch any errors thrown when parsing Schemata for\n   * ASTNodes. If showError is true, any caught errors are thrown once again.\n   *\n   * @param {string|Schemata|Source|GraphQLSchema} sdl an instance\n   * of Schemata, a string of SDL, a Source instance of SDL or a GraphQLSchema\n   * that can be printed as an SDL string\n   * @param {boolean} showError if true, any caught errors will be thrown once\n   * again\n   * @return {ASTNode|null} null if an error occurs and errors are suppressed,\n   * a top level Document ASTNode otherwise\n   */\n  static parse(\n    sdl: string | Schemata | Source | GraphQLSchema,\n    showError: boolean = false\n  ): ?ASTNode {\n    try {\n      let source = normalizeSource(sdl)\n\n      return this.gql.parse(source)\n    }\n    catch (e) {\n      if (showError) { throw e }\n      return null\n    }\n  }\n\n  /**\n   * A simple pass thru used within the class to reference graphql methods\n   * and classes.\n   *\n   * @return {mixed} the results of `require('graphql')`\n   */\n  static get gql(): mixed { return require('graphql') }\n\n  /**\n   * Shorthand way of invoking `new Schemata(typeDefs, resolvers)`\n   *\n   * @param {string|Source|Schemata|GraphQLSchema} typeDefs usually a String or\n   * other `toString`'able item\n   * @param {Object} resolvers an object containing field resolvers for\n   * for the schema represented with this string. [Optional]\n   * @return {Schemata} an instance of Schemata\n   */\n  static from(\n    typeDefs: string | Source | Schemata | GraphQLSchema,\n    resolvers: ?Object\n  ): Schemata {\n    return new this(typeDefs, resolvers)\n  }\n\n  /**\n   * Constant used with `forEachOf()` that signifies you wish to iterate\n   * over every available type within the schema.\n   *\n   * @type {number}\n   */\n  static get ALL(): number { return ALL }\n\n  /**\n   * Constant used with `forEachOf()` that signifies you wish to iterate\n   * over every available type within the schema.\n   *\n   * @type {number}\n   */\n  static get TYPES(): number { return TYPES }\n\n  /**\n   * Constant used with `forEachOf()` that signifies you wish to iterate\n   * over every available interface within the schema.\n   *\n   * @type {number}\n   */\n  static get INTERFACES(): number { return INTERFACES }\n\n  /**\n   * Constant used with `forEachOf()` that signifies you wish to iterate\n   * over every available enum within the schema.\n   *\n   * @type {number}\n   */\n  static get ENUMS(): number { return ENUMS }\n\n  /**\n   * Constant used with `forEachOf()` that signifies you wish to iterate\n   * over every available union within the schema.\n   *\n   * @type {number}\n   */\n  static get UNIONS(): number { return UNIONS }\n\n  /**\n   * Constant used with `forEachOf()` that signifies you wish to iterate\n   * over every available scalar within the schema.\n   *\n   * @type {number}\n   */\n  static get SCALARS(): number { return SCALARS }\n\n  /**\n   * Constant used with `forEachOf()` that signifies you wish to iterate\n   * over every available root type; Query, Mutation and Subscription\n   *\n   * @type {number}\n   */\n  static get ROOT_TYPES(): number { return ROOT_TYPES }\n\n  /**\n   * Constant used with `forEachOf()` that signifies you wish to iterate\n   * over every available GraphQLInputObjectType within the schema.\n   *\n   * @type {number}\n   */\n  static get INPUT_TYPES(): number { return INPUT_TYPES }\n\n  /**\n   * Constant used with `forEachOf()` that signifies you also wish to\n   * iterate over the meta types. These are denoted by a leading double\n   * underscore.\n   *\n   * Can be OR'ed together such as `Schemata.TYPES | Schemata.HIDDEN`\n   *\n   * @type {number}\n   */\n  static get HIDDEN(): number { return HIDDEN }\n}\n\nexport default Schemata"]}