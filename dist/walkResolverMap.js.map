{"version":3,"sources":["../src/walkResolverMap.js"],"names":["object","inspector","DefaultAsyncEntryInspector","wrap","path","product","reduce","prev","cur","index","concat","push","Object","entries","key","value","isObject","isFunction","Function","asyncWalkResolverMap","Error","entry","undefined","walkResolverMap","DefaultEntryInspector","map"],"mappings":"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","file":"walkResolverMap.js","sourceRoot":"src","sourcesContent":["// @flow\n\nimport type { ResolverMap } from './types'\nimport { ResolverMapStumble } from './errors'\nimport at from './propAt'\nimport merge from 'deepmerge'\n\n/**\n * An `EntryInspector` is a function passed to `walkResolverMap` that is\n * invoked for each encountered pair along the way as it traverses the\n * `ResolverMap` in question. The default behavior is to simply return the\n * supplied entry back.\n *\n * If false, null or undefined is returned instead of an object with a string\n * mapping to a Function, then that property will not be included in the final\n * results of `walkResolverMap`.\n *\n * @type {Function}\n *\n * @param {{[string]: Function}} entry the key value pair supplied on each call\n * @param {[string]} path an array of strings indicating the path currently\n * being executed\n * @param {ResolverMap} map the map in question should it be needed\n */\nexport type EntryInspector = (\n  key: string,\n  value: Function,\n  path: Array<string>,\n  map: ResolverMap\n) => ?{ [string]: Function }\n\n/**\n * An `AsyncEntryInspector` is a function passed to `asyncWalkResolverMap`\n * that is invoked for each encountered pair along the way as it traverses the\n * `ResolverMap` in question. The default behavior is to simply return the\n * supplied entry back.\n *\n * If false, null or undefined is returned instead of an object with a string\n * mapping to a Function, then that property will not be included in the final\n * results of `asyncWalkResolverMap`.\n *\n * @type {Function}\n *\n * @param {{[string]: Function}} entry the key value pair supplied on each call\n * @param {[string]} path an array of strings indicating the path currently\n * being executed\n * @param {ResolverMap} map the map in question should it be needed\n */\nexport type AsyncEntryInspector = (\n  key: string,\n  value: Function,\n  path: Array<string>,\n  map: ResolverMap\n) => ?Promise<{ [string]: Function }>\n\n/**\n * A default implementation of the EntryInspector type for use as a default\n * to `walkResolverMap`. While not immediately useful, a default implementation\n * causes `walkResolverMap` to wrap any non-function and non-object values\n * with a function that returns the non-compliant value and therefore has some\n * intrinsic value.\n *\n * @method DefaultEntryInspector\n * @type {Function}\n */\nexport const DefaultEntryInspector: EntryInspector = (\n  key,\n  value,\n  path,\n  map\n) => {\n  return { [key]: value }\n}\n\n/**\n * A default implementation of the EntryInspector type for use as a default\n * to `asyncWalkResolverMap`. While not immediately useful, a default\n * implementation causes `asyncWalkResolverMap` to wrap any non-function and\n * non-object values with a function that returns the non-compliant value and\n * therefore has some intrinsic value.\n *\n * @method DefaultEntryInspector\n * @type {Function}\n */\nexport const DefaultAsyncEntryInspector: EntryInspector = async (\n  key,\n  value,\n  path,\n  map\n) => {\n  return { [key]: value }\n}\n\n/**\n * Given a `ResolverMap` object, walk its properties and allow execution\n * with each key, value pair. If the supplied function for handling a given\n * entry returns null instead of an object with the format `{key: value}`\n * then that entry will not be included in the final output.\n *\n * @method walkResolverMap\n *\n * @param {ResolverMap} object an object conforming to type `ResolverMap`\n * @param {boolean} wrap defaults to true. An entry whose value is neither a\n * function nor an object will be wrapped in a function returning the value. If\n * false is supplied here, a `ResolverMapStumble` error will be thrown instead\n * @return {ResolverMap} upon successful completion, a `ResolverMap` object,\n * modified as specified, will be returned instead.\n */\nexport function walkResolverMap(\n  object: ResolverMap,\n  inspector: EntryInspector = DefaultEntryInspector,\n  wrap: boolean = true,\n  path: Array<string> = []\n): ResolverMap {\n  let product = {}\n\n  path.reduce((prev, cur, index) => {\n    if (!at(product, prev.concat(cur))) {\n      at(product, prev.concat(cur), {})\n    }\n    prev.push(cur)\n\n    return prev\n  }, [])\n\n  for (let [key, value] of Object.entries(object)) {\n    const isObject: boolean = value instanceof Object\n    const isFunction: boolean = isObject && value instanceof Function\n\n    if (isObject && !isFunction) {\n      at(\n        product,\n        path.concat(key),\n        walkResolverMap(value, inspector, wrap, path)\n      )\n    }\n    else {\n      if (!isObject && !isFunction) {\n        // In the case that we have a string mapping to a non-function and a\n        // non-object, we can do one of two things. Either we can throw an error\n        // or by default we simply wrap the value in a function that returns\n        // that value\n        if (!wrap) {\n          throw new ResolverMapStumble(new Error('Invalid ResolverMap'))\n        }\n        else {\n          value = () => value\n        }\n      }\n\n      let entry = inspector(key, value, path, object)\n\n      if (entry !== undefined) {\n        at(product, path.concat(key), entry[key])\n      }\n    }\n  }\n\n  return product\n}\n\n/**\n * Given a `ResolverMap` object, walk its properties and allow execution\n * with each key, value pair. If the supplied function for handling a given\n * entry returns null instead of an object with the format `{key: value}`\n * then that entry will not be included in the final output.\n *\n * @method asyncWalkResolverMap\n *\n * @param {ResolverMap} object an object conforming to type `ResolverMap`\n * @param {boolean} wrap defaults to true. An entry whose value is neither a\n * function nor an object will be wrapped in a function returning the value. If\n * false is supplied here, a `ResolverMapStumble` error will be thrown instead\n * @return {ResolverMap} upon successful completion, a `ResolverMap` object,\n * modified as specified, will be returned instead.\n */\nexport async function asyncWalkResolverMap(\n  object: ResolverMap,\n  inspector: AsyncEntryInspector = DefaultAsyncEntryInspector,\n  wrap: boolean = true,\n  path: Array<string> = []\n): ResolverMap {\n  let product = {}\n\n  path.reduce((prev, cur, index) => {\n    if (!at(product, prev.concat(cur))) {\n      at(product, prev.concat(cur), {})\n    }\n    prev.push(cur)\n\n    return prev\n  }, [])\n\n  for (let [key, value] of Object.entries(object)) {\n    const isObject: boolean = value instanceof Object\n    const isFunction: boolean = isObject && value instanceof Function\n\n    if (isObject && !isFunction) {\n      at(\n        product,\n        path.concat(key),\n        await asyncWalkResolverMap(value, inspector, wrap, path)\n      )\n    }\n    else {\n      if (!isObject && !isFunction) {\n        // In the case that we have a string mapping to a non-function and a\n        // non-object, we can do one of two things. Either we can throw an error\n        // or by default we simply wrap the value in a function that returns\n        // that value\n        if (!wrap) {\n          throw new ResolverMapStumble(new Error('Invalid ResolverMap'))\n        }\n        else {\n          value = () => value\n        }\n      }\n\n      let entry = await inspector(key, value, path, object)\n\n      if (entry !== undefined) {\n        at(product, path.concat(key), entry[key])\n      }\n    }\n  }\n\n  return product\n}\n\nexport default walkResolverMap\n"]}