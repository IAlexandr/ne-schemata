{"version":3,"sources":["../src/walkResolverMap.js"],"names":["walkResolverMap","DefaultEntryInspector","entry","path","map","object","inspector","wrap","Object","entries","reduce","product","key","value","isObject","isFunction","Function","concat","Error"],"mappings":";;;;;;QA2DgBA,e,GAAAA,e;;AAxDhB;;AACA;;;;AACA;;;;;;AAyBA;;;;;;;;;;;;AAvBA;;;;;;;;;;;;;;;;;AAiCO,MAAMC,wDAAwC,CAACC,KAAD,EAAQC,IAAR,EAAcC,GAAd,KAAsB;AACzE,SAAOF,KAAP;AACD,CAFM;;AAIP;;;;;;;;;;;;;;;AAeO,SAASF,eAAT,CACLK,MADK,EAELC,YAA4BL,qBAFvB,EAGLM,OAAgB,IAHX,EAILJ,OAAsB,EAJjB,EAKQ;AACb,SAAOK,OAAOC,OAAP,CAAeJ,MAAf,EAAuBK,MAAvB,CACL,CAACC,OAAD,EAAiB,CAACC,GAAD,EAAuBC,KAAvB,CAAjB,KAA0D;AACxD,UAAMC,WAAoBD,iBAAiBL,MAA3C;AACA,UAAMO,aAAsBD,YAAYD,iBAAiBG,QAAzD;;AAEA,QAAIF,QAAJ,EAAc;AACZ,aAAO,sBACLH,OADK,EAELR,KAAKc,MAAL,CAAY,KAAZ,CAFK,EAGLjB,gBAAgBa,KAAhB,EAAuBP,SAAvB,EAAkCC,IAAlC,EAAwCJ,KAAKc,MAAL,CAAYL,GAAZ,CAAxC,CAHK,CAAP;AAKD,KAND,MAOK;AACH;AACA;AACA;AACA;AACA,UAAI,CAACL,IAAL,EAAW;AACT,cAAM,+BAAuB,IAAIW,KAAJ,CAAU,qBAAV,CAAvB,CAAN;AACD,OAFD,MAGK;AACHL,gBAAQ,MAAMA,KAAd;AACD;;AAED,UAAIX,QAAQI,UAAU,EAAE,CAACM,GAAD,GAAOC,KAAT,EAAV,EAA4BV,IAA5B,EAAkCE,MAAlC,CAAZ;;AAEA,UAAIH,KAAJ,EAAW;AACT,eAAO,sBAAGS,OAAH,EAAYR,KAAKc,MAAL,CAAY,KAAZ,CAAZ,EAAgCf,KAAhC,CAAP;AACD,OAFD,MAGK;AACH,eAAOS,OAAP;AACD;AACF;AACF,GAjCI,EAkCL,EAlCK,CAAP;AAoCD;;kBAEcX,e","file":"walkResolverMap.js","sourceRoot":"src","sourcesContent":["// @flow\n\nimport type { ResolverMap } from './types'\nimport { ResolverMapStumble } from './errors'\nimport at from './propAt'\nimport merge from 'deepmerge'\n\n/**\n * An `EntryInspector` is a function passed to `walkResolverMap` that is\n * invoked for each encountered pair along the way as it traverses the\n * `ResolverMap` in question. The default behavior is to simply return the\n * supplied entry back.\n *\n * If false, null or undefined is returned instead of an object with a string\n * mapping to a Function, then that property will not be included in the final\n * results of `walkResolverMap`.\n *\n * @type {Function}\n *\n * @param {{[string]: Function}} entry the key value pair supplied on each call\n * @param {[string]} path an array of strings indicating the path currently\n * being executed\n * @param {ResolverMap} map the map in question should it be needed\n */\nexport type EntryInspector = (\n  entry: { [string]: Function },\n  path: Array<string>,\n  map: ResolverMap\n) => { [string]: Function | ResolverMap }\n\n/**\n * A default implementation of the EntryInspector type for use as a default\n * to `walkResolverMap`. While not immediately useful, a default implementation\n * causes `walkResolverMap` to wrap any non-function and non-object values\n * with a function that returns the non-compliant value and therefore has some\n * intrinsic value.\n *\n * @method DefaultEntryInspector\n * @type {Function}\n */\nexport const DefaultEntryInspector: EntryInspector = (entry, path, map) => {\n  return entry\n}\n\n/**\n * Given a `ResolverMap` object, walk its properties and allow execution\n * with each key, value pair. If the supplied function for handling a given\n * entry returns null instead of an object with the format `{key: value}`\n * then that entry will not be included in the final output.\n *\n * @method walkResolverMap\n *\n * @param {ResolverMap} object an object conforming to type `ResolverMap`\n * @param {boolean} wrap defaults to true. An entry whose value is neither a\n * function nor an object will be wrapped in a function returning the value. If\n * false is supplied here, a `ResolverMapStumble` error will be thrown instead\n * @return {ResolverMap} upon successful completion, a `ResolverMap` object,\n * modified as specified, will be returned instead.\n */\nexport function walkResolverMap(\n  object: ResolverMap,\n  inspector: EntryInspector = DefaultEntryInspector,\n  wrap: boolean = true,\n  path: Array<string> = []\n): ResolverMap {\n  return Object.entries(object).reduce(\n    (product: mixed, [key: string | Symbol, value: mixed]) => {\n      const isObject: boolean = value instanceof Object\n      const isFunction: boolean = isObject && value instanceof Function\n\n      if (isObject) {\n        return at(\n          product,\n          path.concat('key'),\n          walkResolverMap(value, inspector, wrap, path.concat(key))\n        )\n      }\n      else {\n        // In the case that we have a string mapping to a non-function and a\n        // non-object, we can do one of two things. Either we can throw an error\n        // or by default we simply wrap the value in a function that returns\n        // that value\n        if (!wrap) {\n          throw new ResolverMapStumble(new Error('Invalid ResolverMap'))\n        }\n        else {\n          value = () => value\n        }\n\n        let entry = inspector({ [key]: value }, path, object)\n\n        if (entry) {\n          return at(product, path.concat('key'), entry)\n        }\n        else {\n          return product\n        }\n      }\n    },\n    {}\n  )\n}\n\nexport default walkResolverMap\n"]}