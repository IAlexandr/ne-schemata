{"version":3,"sources":["../src/ExtendedResolver.js"],"names":["original","Symbol","listing","patcher","ExtendedResolver","Function","constructor","resolver","Array","from","Proxy","handler","order","value","resultPatcher","prepend","preresolver","index","indexOf","splice","append","postresolver","length","push","toString","strings","fn","name","repeat","join","show","console","log","toStringTag","newResolver","wrap","prepends","appends","isArray","forEach","SchemaInjector","originalResolver","newSchema","source","args","context","info","arguments","schema","apply","target","thisArg","myArgs","results","reduce","p","c","i","a","result","concat","Object","assign","call"],"mappings":"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","file":"ExtendedResolver.js","sourceRoot":"src","sourcesContent":["import { defaultFieldResolver } from 'graphql'\n\nimport type {\n  GraphQLFieldResolver,\n  GraphQLResolveInfo,\n  GraphQLSchema,\n} from 'graphql'\n\nconst original = Symbol('Original Resolver')\nconst listing = Symbol('List of Resolvers')\nconst patcher = Symbol('Resolver Result Patcher')\n\nexport type ResolverResultsPatcher = (results: mixed) => mixed\n\n/**\n * Higher order, or wrapped, GraphQL field resolvers are a technique that\n * is becoming increasingly common these days. This class attempts to wrap\n * that in such a manner that it allows a bit of extensibility.\n *\n * @extends Function\n */\nexport class ExtendedResolver extends Function {\n  /**\n   * Creates a new instance of `ExtendedResolver` for use with GraphQL. If\n   * the supplied resolver is already an instance of `ExtendedResolver`, its\n   * internal nested resolvers are copied, alongside the rest of the custom\n   * properties that make up an instance of `ExtendedResolver`\n   *\n   * @since 1.9\n   *\n   * @param {GraphQLFieldResolver} resolver a normal GraphQLFieldResolver\n   * function. By default, the `defaultFieldResolver` is used if no other\n   * value is supplied\n   */\n  constructor(resolver: GraphQLFieldResolver = defaultFieldResolver) {\n    super()\n\n    if (resolver instanceof ExtendedResolver) {\n      this[listing] = Array.from(resolver[listing])\n      this[original] = resolver[original]\n      this[patcher] = resolver[patcher]\n    }\n    else {\n      this[listing] = [resolver]\n      this[original] = resolver\n      this[patcher] = null\n    }\n\n    return new Proxy(this, ExtendedResolver.handler)\n  }\n\n  // Properties\n\n  /**\n   * Returns a handle to the internal array of ordered resolver\n   * functions, should indepth modification be necessary.\n   *\n   * @return  {Array<GraphQLFieldResolver>} the internal list of\n   * resolvers to execute in order as though it were a single resolver\n   */\n  get order(): Array<GraphQLFieldResolver> {\n    return this[listing]\n  }\n\n  /**\n   * An accessor that writes a new resolver to the internal list of\n   * resolvers that combine into a single resolver for inclusion elsewhere.\n   *\n   * TODO come up with some ideas on how to handle setting of this list\n   * when the list no longer contains the original. Throw error? Log? Add it\n   * to the end? Allow all in some configurable manner?\n   *\n   * @param  {Array<GraphQLFieldResolver>} value the new array\n   */\n  set order(value: Array<GraphQLFieldResolver>) {\n    this[listing] = value\n  }\n\n  /**\n   * Retrieve the internal result value patcher function. By default, this\n   * value is null and nonexistent. When present, it is a function that will\n   * be called after all internal resolvers have done their work but before\n   * those results are returned to the calling function.\n   *\n   * The function takes as its only parameter the culmination of results from\n   * the internal resolvers work. Whatever is returned from this function is\n   * returned as the final results.\n   *\n   * @return {ResolverResultsPatcher} a function or null\n   */\n  get resultPatcher(): ResolverResultsPatcher {\n    return this[patcher]\n  }\n\n  /**\n   * Sets the internal patcher function.\n   *\n   * @see resultPatcher getter above\n   * @param {ResolverResultsPatcher} value a new patcher function\n   */\n  set resultPatcher(value: ResolverResultsPatcher) {\n    this[patcher] = value\n  }\n\n  // Methods\n\n  /**\n   * Guaranteed to insert the supplied field resolver after any other prepended\n   * field resolvers and before the original internal field resolver.\n   *\n   * @param {GraphQLFieldResolver} preresolver a field resolver to run before\n   * the original field resolver executes.\n   */\n  prepend(preresolver: GraphQLFieldResolver) {\n    if (preresolver && preresolver instanceof Function) {\n      let index = this[listing].indexOf(this[original])\n\n      index = ~index ? index : 0\n\n      this[listing].splice(index, 0, preresolver)\n    }\n  }\n\n  /**\n   * Inserts the supplied field resolver function after the original resolver\n   * but before any previously added post resolvers. If you simply wish to\n   * push another entry to the list, use `.push`\n   *\n   * @param {GraphQLFieldResolver} postresolver a field resolver that should\n   * run after the original but before other postresolvers previously added.\n   */\n  append(postresolver: GraphQLFieldResolver) {\n    if (postresolver && postresolver instanceof Function) {\n      let index = this[listing].indexOf(this[original])\n\n      index = ~index ? index + 1 : this[listing].length\n\n      this[listing].splice(index, 0, postresolver)\n    }\n  }\n\n  /**\n   * Simply adds a field resolver to the end of the list rather than trying\n   * to put it as close to the original resolver as possible.\n   *\n   * @param {GraphQLFieldResolver} postresolver a field resolver that should\n   * run after the original\n   */\n  push(postresolver: GraphQLFieldResolver) {\n    if (postresolver && postresolver instanceof Function) {\n      this[listing].push(postresolver)\n    }\n  }\n\n  /**\n   * The `.toString()` functionality of the ExtendedResolver dutifily lists the\n   * source of each function to be executed in order.\n   *\n   * @method toString\n   *\n   * @return {string} a combined toString() functionality for each item in\n   * order\n   */\n  toString(): string {\n    let strings: Array<string> = []\n\n    for (let fn of this.order) {\n      strings.push(`Function: ${fn.name}`)\n      strings.push(\n        `---------${'-'.repeat(fn.name.length ? fn.name.length + 1 : 0)}`\n      )\n      strings.push(fn.toString())\n      strings.push('')\n    }\n\n    return strings.join('\\n')\n  }\n\n  /**\n   * After having to repeatedly console.log the toString output, this function\n   * now does that easier for me so I don't end up with carpal tunnel earlier\n   * than necessary.\n   *\n   * @method show\n   */\n  show(): void {\n    console.log(this.toString())\n  }\n\n  // Symbols\n\n  /**\n   * Ensure that when inspected with Object.prototype.toString.call/apply\n   * that instances of ExtendedResolver return `'[object ExtendedResolver]'`\n   *\n   * @type {Symbol}\n   */\n  get [Symbol.toStringTag]() {\n    return this.constructor.name\n  }\n\n  // Statics\n\n  /**\n   * Shorthand static initializer that allows the ExtendedResolver class to\n   * be instantiated using `ExtendedResolver.from()` rather than the normal\n   * `new ExtendedResolver()`. Additionally it offers a way to set a result\n   * patcher after initialization has occurred\n   *\n   * @param {GraphQLFieldResolver} resolver the resolver to initialize the\n   * class instance with.\n   * @param {ResolverResultsPatcher} patcher an optional function matching the\n   * `ResolverResultsPatcher` signature to set to the new instance after it is\n   * created.\n   * @return {ExtendedResolver} a newly minted instance of the class\n   * `ExtendedResolver`\n   */\n  static from(\n    resolver: GraphQLFieldResolver,\n    patcher?: ResolverResultsPatcher\n  ): ExtendedResolver {\n    let newResolver = new ExtendedResolver(resolver)\n\n    if (patcher) {\n      newResolver.resultPatcher = patcher\n    }\n\n    return newResolver\n  }\n\n  /**\n   * Similar to the `.from` static initializer, the `.wrap` initializer\n   * takes an original field resolver, an optional patcher as in `.from`\n   * as well as an array of `prepends` and `appends` field resolvers which\n   * will be slotted in the appropriate locations.\n   *\n   * @param  {GraphQLFieldResolver} original a field resolver function that\n   * is to be wrapped as the basis for the resulting `ExtendedResolver`\n   * @param {ResolverResultsPatcher} patcher an optional function that allows\n   * the user to patch the results of the total field resolver culmination\n   * before allowing the calling code to see them.\n   * @param {GraphQLFieldResolver|Array<GraphQLFieldResolver>} prepends either\n   * a single GraphQLFieldResolver or an array of them to prepend before the\n   * original field resolver executes\n   * @param {GraphQLFieldResolver|Array<GraphQLFieldResolver>} appends either\n   * a single GraphQLFieldResolver or an array of them to prepend after the\n   * original field resolver executes\n   * @return {[type]}          [description]\n   */\n  static wrap(\n    original: GraphQLFieldResolver,\n    patcher?: ResolverResultsPatcher = null,\n    prepends?: GraphQLFieldResolver | Array<GraphQLFieldResolver> = [],\n    appends?: GraphQLFieldResolver | Array<GraphQLFieldResolver> = []\n  ) {\n    let resolver = ExtendedResolver.from(original)\n\n    if (patcher && patcher instanceof Function) {\n      resolver.resultPatcher = patcher\n    }\n\n    if (prepends) {\n      if (!Array.isArray(prepends)) {\n        prepends = [prepends]\n      }\n\n      if (prepends.length) {\n        prepends.forEach(fn => resolver.prepend(fn))\n      }\n    }\n\n    if (appends) {\n      if (!Array.isArray(appends)) {\n        appends = [appends]\n      }\n\n      if (appends.length) {\n        appends.forEach(fn => resolver.append(fn))\n      }\n    }\n\n    return resolver\n  }\n\n  /**\n   * In the process of schema stitching, it is possible and likely that\n   * a given schema has been extended or enlarged during the merging process\n   * with another schema. Neither of the old schemas have any idea of the\n   * layout of the newer, grander, schema. Therefore it is necessary to\n   * inject the new GraphQLSchema as part of the info parameters received\n   * by the resolver for both sides of the stitched schema in order to\n   * prevent errors.\n   *\n   * This static method takes the original resolver, wraps it with a\n   * prepended resolver that injects the new schema; also supplied as the\n   * second parameter. The result is a newly minted `ExtendedResolver` that\n   * should do the job in question.\n   *\n   * @param {GraphQLFieldResolver} originalResolver the original resolver todo\n   * wrap.\n   * @param {GraphQLSchema} newSchema the new, grander, schema with all fields\n   */\n  static SchemaInjector(\n    originalResolver: GraphQLFieldResolver,\n    newSchema: GraphQLSchema\n  ) {\n    return ExtendedResolver.wrap(originalResolver, null, [\n      function(\n        source: any,\n        args: any,\n        context: { [argument: string]: any },\n        info: GraphQLResolveInfo\n      ) {\n        if (arguments.length === 3 && context.schema) {\n          context.schema = newSchema\n        }\n        else if (arguments.length === 4 && info.schema) {\n          info.schema = newSchema\n        }\n      },\n    ])\n  }\n\n  /**\n   * All instances of `ExtendedResolver` are Proxies to the instantiated\n   * class with a specially defined `.apply` handler to make their custom\n   * execution flow work.\n   *\n   * @type {Object}\n   */\n  static get handler(): Object {\n    return {\n      /**\n       * Reduce the results of each resolver in the list, including\n       * the original resolver. Calling each in order with the same\n       * parameters and returning the coalesced results\n       *\n       * @param {mixed} target this should always be the object context\n       * @param {mixed} thisArg the `this` object for the context of the\n       * function calls\n       * @param {Array<mixed>} args the arguments object as seen in all\n       * graphql resolvers\n       * @return {mixed} either null or some value as would have been returned\n       * from the call of a graphql field resolver\n       */\n      apply(target, thisArg, args) {\n        // Ensure we have arguments as an array so we can concat results in\n        // each pass of the reduction process\n        let myArgs = Array.isArray(args)\n          ? args\n          : Array.from((args && args) || [])\n\n        let results = target[listing].reduce(function(p, c, i, a) {\n          let result = c.apply(thisArg || target, myArgs.concat(p))\n\n          if (p && p instanceof Object && result && result instanceof Object) {\n            result = Object.assign(p, result)\n          }\n\n          return result\n        }, {})\n\n        if (target[patcher] && target[patcher] instanceof Function) {\n          results = target[patcher].call(thisArg || target, results)\n        }\n\n        return results\n      },\n    }\n  }\n}\n"]}