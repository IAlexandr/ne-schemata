{"version":3,"sources":["../../src/errors/WrappedResolverExecutionError.js"],"names":["isFn","o","test","Object","prototype","toString","call","pe","PrettyError","WrappedResolverExecutionError","BaseError","constructor","error","resolver","index","args","context","results","fn","order","dropLowest","name","wasBigArrowFunction","colors","depth","render","valueOf"],"mappings":";;;;;;;AAEA;;AACA;;AACA;;AACA;;;;;;AAIA,MAAMA,OAAOC,KAAK,aAAaC,IAAb,CAAkBC,OAAOC,SAAP,CAAiBC,QAAjB,CAA0BC,IAA1B,CAA+BL,CAA/B,CAAlB,CAAlB;AACA,MAAMM,KAAK,IAAIC,qBAAJ,EAAX;;AAEA;;;;;;;AAOO,MAAMC,6BAAN,SAA4CC,oBAA5C,CAAsD;;AAwC3D;;;;;;;;;;;;;;;;AAjBA;;;;;;;;AAfA;;;;;;AA8CAC,cACEC,KADF,EAEEC,QAFF,EAGEC,KAHF,EAIEC,IAJF,EAKEC,OALF,EAMEC,OANF,EAOE;AACA,UAAML,KAAN;;AAEA,SAAKC,QAAL,GAAgBA,QAAhB;AACA,SAAKC,KAAL,GAAaA,KAAb;AACA,SAAKC,IAAL,GAAYA,IAAZ;AACA,SAAKC,OAAL,GAAeA,OAAf;AACA,SAAKC,OAAL,GAAeA,OAAf;AACD;;AAED;;;;;;;;AAxCA;;;;;;;;;AAfA;;;;;;AAfA;;;;;AA4EAZ,aAAmB;AACjB,QAAIa,KACF,KAAKL,QAAL,IACA,KAAKA,QAAL,CAAcM,KADd,IAEA,KAAKN,QAAL,CAAcM,KAAd,CAAoB,KAAKL,KAAzB,CAHF;;AAMA,WAAOM,oBAAW;;cAER,KAAKN,KAAM,iCAAgCI,MAAMA,GAAGG,IAAK;;sDAG9D,KAAKC,mBAAL,GACG,qBADH,GAEG,sBAEL;;;QAGC,mBAAQ,KAAKP,IAAb,EAAmB,EAACQ,QAAQ,IAAT,EAAeC,OAAO,CAAtB,EAAnB,CAA6C;;;QAG7C,mBAAQ,KAAKR,OAAb,EAAsB,EAACO,QAAQ,IAAT,EAAeC,OAAO,CAAtB,EAAtB,CAAgD;;;QAGhD,mBAAQ,KAAKP,OAAb,EAAsB,EAACM,QAAQ,IAAT,EAAeC,OAAO,CAAtB,EAAtB,CAAgD;;;QAGhDjB,GAAGkB,MAAH,CAAU,KAAKb,KAAf,CAAsB;KArB1B;AAuBD;;AAED;;;;;AAKAc,YAAkB;AAChB,WAAO,KAAKrB,QAAL,EAAP;AACD;;AAED;;;;;;;;;;;AAWA,MAAIiB,mBAAJ,GAAmC;AACjC,UAAMT,WACJ,KAAKA,QAAL,IACA,KAAKA,QAAL,CAAcM,KADd,IAEA,KAAKN,QAAL,CAAcM,KAAd,CAAoB,KAAKL,KAAzB,CAHF;;AAMA,QAAID,YAAYb,KAAKa,QAAL,CAAhB,EAAgC;AAC9B,aAAO,OAAOA,SAAST,SAAhB,KAA8B,WAArC;AACD;;AAED,WAAO,KAAP;AACD;AA7I0D;;QAAhDK,6B,GAAAA,6B;kBAgJEA,6B","file":"WrappedResolverExecutionError.js","sourceRoot":"src","sourcesContent":["// @flow\n\nimport { inline, dropLowest } from 'ne-tag-fns'\nimport { BaseError } from '../BaseError'\nimport { inspect } from 'util'\nimport PrettyError from 'pretty-error'\n\nimport type { ExtendedResolver } from '../ExtendedResolver'\n\nconst isFn = o => /Function\\]/.test(Object.prototype.toString.call(o))\nconst pe = new PrettyError()\n\n/**\n * ExtendedResolvers wrap several functions including the original GraphQL\n * field resolver itself. If an exception is thrown by any of the internal\n * methods, this error can help resolve those problems.\n *\n * @class WrappedResolverExecutionError\n */\nexport class WrappedResolverExecutionError extends BaseError {\n  /**\n   * The `ExtendedResolver` object that caused the issue\n   *\n   * @type {ExtendedResolver}\n   */\n  resolver: ExtendedResolver\n\n  /**\n   * The index of the function that failed. This will help the programmer\n   * determine the function that caused the error.\n   *\n   * @type {number}\n   */\n  index: number\n\n  /**\n   * The arguments passed to the function in question that failed.\n   *\n   * @type {Array<mixed>}\n   */\n  args: Array<mixed>\n\n  /**\n   * The `this` value passed to the function as it was executed. Note that\n   * this value is irrelevant if the function passed was a big arrow function\n   *\n   * @type {mixed}\n   */\n  context: mixed\n\n  /**\n   * The `results` value before the internal resolver that failed was thrown.\n   * This does not include the results of the erroring function in question as\n   * no value was ever reached before the exception was thrown (in theory)\n   *\n   * @type {mixed}\n   */\n  results: mixed\n\n  /**\n   * Creates a new error instance of `WrappedResolverExecutionError`. The\n   * arguments resolver, index, args and context all help the programmer\n   * debug the issue in question should the error be thrown.\n   *\n   * @method constructor\n   *\n   * @param {Error|string} error the error thrown at the time of the problem\n   * @param {ExtendedResolver} resolver the `ExtendedResolver` instance\n   * @param {number} index the index of the wrapped resolver that threw up\n   * @param {Array<mixed>} args the arguments passed to the function at the time\n   * @param {mixed} context the `thisArg` set on the function call at the time\n   * @param {mixed} results the results up to the time of failure\n   */\n  constructor(\n    error: Error | string,\n    resolver: ExtendedResolver,\n    index: number,\n    args: Array<mixed>,\n    context: mixed,\n    results: mixed\n  ) {\n    super(error)\n\n    this.resolver = resolver\n    this.index = index\n    this.args = args\n    this.context = context\n    this.results = results\n  }\n\n  /**\n   * Description of the WrappedResolverExecutionError error and likely cause\n   * and fix.\n   *\n   * @return {string} a string denoting the purpose/cause of this error class\n   */\n  toString(): string {\n    let fn: Function = (\n      this.resolver && \n      this.resolver.order &&\n      this.resolver.order[this.index]\n    )\n\n    return dropLowest`\n      The ExtendedResolver execution failed. The resolver that failed was at\n      index ${this.index}. The function had a name of '${fn && fn.name}'.\n\n      Was the function likely a big arrow function? ${\n        (this.wasBigArrowFunction \n          ? '\\x1b[33mtrue\\x1b[0m'\n          : '\\x1b[31mfalse\\x1b[0m'\n        )\n      }\n\n      Arguments at the time were:\n      ${inspect(this.args, {colors: true, depth: 8})}\n\n      Context at the time was:\n      ${inspect(this.context, {colors: true, depth: 8})}\n\n      Results before the function was called\n      ${inspect(this.results, {colors: true, depth: 8})}\n\n      Original Stack Trace\n      ${pe.render(this.error)}\n    `\n  }\n\n  /**\n   * Modify the `valueOf()` function to mirror the `toString()` functionality\n   * \n   * @return {string} an identical string to `.toString()`\n   */\n  valueOf(): string {\n    return this.toString()\n  }\n\n  /**\n   * A programmatic attempt to determine if the function that failed was a\n   * big arrow function. This means the function was pre-bound and the\n   * `context` set at the time of execution would have been ignored.\n   *\n   * @function wasBigArrowFunction\n   *\n   * @return {boolean} true if the failed function resolver was a big arrow or\n   * pre-bound function; false if the `context` value should have been passed\n   * successfully to the execution context\n   */\n  get wasBigArrowFunction(): boolean {\n    const resolver = (\n      this.resolver && \n      this.resolver.order && \n      this.resolver.order[this.index]\n    )\n\n    if (resolver && isFn(resolver)) {\n      return typeof resolver.prototype === 'undefined'\n    }\n\n    return false\n  }\n}\n\nexport default WrappedResolverExecutionError\n"]}