{"version":3,"sources":["../../src/errors/WrappedResolverExecutionError.js"],"names":["isFn","o","test","Object","prototype","toString","call","WrappedResolverExecutionError","constructor","error","resolver","index","args","context","results","fn","order","name","wasBigArrowFunction","listing"],"mappings":";;;;;;;AAEA;;AACA;;AAIA,MAAMA,OAAOC,KAAK,aAAaC,IAAb,CAAkBC,OAAOC,SAAP,CAAiBC,QAAjB,CAA0BC,IAA1B,CAA+BL,CAA/B,CAAlB,CAAlB;;AAEA;;;;;;;AAOO,MAAMM,6BAAN,8BAAsD;;AAwC3D;;;;;;;;;;;;;;;;AAjBA;;;;;;;;AAfA;;;;;;AA8CAC,cACEC,KADF,EAEEC,QAFF,EAGEC,KAHF,EAIEC,IAJF,EAKEC,OALF,EAMEC,OANF,EAOE;AACA,UAAML,KAAN;;AAEA,SAAKC,QAAL,GAAgBA,QAAhB;AACA,SAAKC,KAAL,GAAaA,KAAb;AACA,SAAKC,IAAL,GAAYA,IAAZ;AACA,SAAKC,OAAL,GAAeA,OAAf;AACA,SAAKC,OAAL,GAAeA,OAAf;AACD;;AAED;;;;;;;;AAxCA;;;;;;;;;AAfA;;;;;;AAfA;;;;;AA4EAT,aAAmB;AACjB,QAAIU,KAAe,KAAKL,QAAL,IAAiB,KAAKA,QAAL,CAAcM,KAAd,CAAoB,KAAKL,KAAzB,CAApC;;AAEA,WAAO,oBAAW;;cAER,KAAKA,KAAM,iCAAgCI,GAAGE,IAAK;;sDAEX,KAAKC,mBAAoB;;;QAGvE,KAAKN,IAAK;;;QAGV,KAAKC,OAAQ;;;QAGb,KAAKC,OAAQ;KAbjB;AAeD;;AAED;;;;;;;;;;;AAWA,MAAII,mBAAJ,GAAmC;AACjC,UAAMR,WAAW,KAAKA,QAAL,IAAiB,KAAKA,QAAL,CAAcS,OAAd,CAAsB,KAAKR,KAA3B,CAAlC;;AAEA,QAAID,YAAYV,KAAKU,QAAL,CAAhB,EAAgC;AAC9B,aAAO,OAAOA,SAASN,SAAhB,KAA8B,WAArC;AACD;;AAED,WAAO,KAAP;AACD;AApH0D;;QAAhDG,6B,GAAAA,6B;kBAuHEA,6B","file":"WrappedResolverExecutionError.js","sourceRoot":"src","sourcesContent":["// @flow\n\nimport { inline, dropLowest } from 'ne-tag-fns'\nimport { BaseError } from '../BaseError'\n\nimport type { ExtendedResolver } from '../ExtendedResolver'\n\nconst isFn = o => /Function\\]/.test(Object.prototype.toString.call(o))\n\n/**\n * ExtendedResolvers wrap several functions including the original GraphQL\n * field resolver itself. If an exception is thrown by any of the internal\n * methods, this error can help resolve those problems.\n *\n * @class WrappedResolverExecutionError\n */\nexport class WrappedResolverExecutionError extends BaseError {\n  /**\n   * The `ExtendedResolver` object that caused the issue\n   *\n   * @type {ExtendedResolver}\n   */\n  resolver: ExtendedResolver\n\n  /**\n   * The index of the function that failed. This will help the programmer\n   * determine the function that caused the error.\n   *\n   * @type {number}\n   */\n  index: number\n\n  /**\n   * The arguments passed to the function in question that failed.\n   *\n   * @type {Array<mixed>}\n   */\n  args: Array<mixed>\n\n  /**\n   * The `this` value passed to the function as it was executed. Note that\n   * this value is irrelevant if the function passed was a big arrow function\n   *\n   * @type {mixed}\n   */\n  context: mixed\n\n  /**\n   * The `results` value before the internal resolver that failed was thrown.\n   * This does not include the results of the erroring function in question as\n   * no value was ever reached before the exception was thrown (in theory)\n   *\n   * @type {mixed}\n   */\n  results: mixed\n\n  /**\n   * Creates a new error instance of `WrappedResolverExecutionError`. The\n   * arguments resolver, index, args and context all help the programmer\n   * debug the issue in question should the error be thrown.\n   *\n   * @method constructor\n   *\n   * @param {Error|string} error the error thrown at the time of the problem\n   * @param {ExtendedResolver} resolver the `ExtendedResolver` instance\n   * @param {number} index the index of the wrapped resolver that threw up\n   * @param {Array<mixed>} args the arguments passed to the function at the time\n   * @param {mixed} context the `thisArg` set on the function call at the time\n   * @param {mixed} results the results up to the time of failure\n   */\n  constructor(\n    error: Error | string,\n    resolver: ExtendedResolver,\n    index: number,\n    args: Array<mixed>,\n    context: mixed,\n    results: mixed\n  ) {\n    super(error)\n\n    this.resolver = resolver\n    this.index = index\n    this.args = args\n    this.context = context\n    this.results = results\n  }\n\n  /**\n   * Description of the WrappedResolverExecutionError error and likely cause\n   * and fix.\n   *\n   * @return {string} a string denoting the purpose/cause of this error class\n   */\n  toString(): string {\n    let fn: Function = this.resolver && this.resolver.order[this.index]\n\n    return dropLowest`\n      The ExtendedResolver execution failed. The resolver that failed was at\n      index ${this.index}. The function had a name of '${fn.name}'.\n\n      Was the function likely a big arrow function? ${this.wasBigArrowFunction}\n\n      Arguments at the time were:\n      ${this.args}\n\n      Context at the time was:\n      ${this.context}\n\n      Results before the function was called\n      ${this.results}\n    `\n  }\n\n  /**\n   * A programmatic attempt to determine if the function that failed was a\n   * big arrow function. This means the function was pre-bound and the\n   * `context` set at the time of execution would have been ignored.\n   *\n   * @function wasBigArrowFunction\n   *\n   * @return {boolean} true if the failed function resolver was a big arrow or\n   * pre-bound function; false if the `context` value should have been passed\n   * successfully to the execution context\n   */\n  get wasBigArrowFunction(): boolean {\n    const resolver = this.resolver && this.resolver.listing[this.index]\n\n    if (resolver && isFn(resolver)) {\n      return typeof resolver.prototype === 'undefined'\n    }\n\n    return false\n  }\n}\n\nexport default WrappedResolverExecutionError\n"]}