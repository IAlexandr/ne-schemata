{"version":3,"sources":["../../src/errors/ResolverResultsPatcherError.js"],"names":["isFn","o","test","Object","prototype","toString","call","ResolverResultsPatcherError","constructor","error","patcher","context","results","name","wasBigArrowFunction"],"mappings":";;;;;;;AAEA;;AACA;;AAIA,MAAMA,OAAOC,KAAK,aAAaC,IAAb,CAAkBC,OAAOC,SAAP,CAAiBC,QAAjB,CAA0BC,IAA1B,CAA+BL,CAA/B,CAAlB,CAAlB;;AAEA;;;;;;;;;AASO,MAAMM,2BAAN,8BAAoD;;AAyBzD;;;;;;;;;;;;;;;AAjBA;;;;;;AA8BAC,cACEC,KADF,EAEEC,OAFF,EAGEC,OAHF,EAIEC,OAJF,EAKE;AACA,UAAMH,KAAN;;AAEA,SAAKC,OAAL,GAAeA,OAAf;AACA,SAAKC,OAAL,GAAeA,OAAf;AACA,SAAKC,OAAL,GAAeA,OAAf;AACD;;AAED;;;;;;;;AAnCA;;;;;;;;AAfA;;;;;AAwDAP,aAAmB;AACjB,WAAO,oBAAW;;;SAGb,KAAKK,OAAL,IAAgB,KAAKA,OAAL,CAAaG,IAA7B,IAAqC,IAAK;;;QAG3C,KAAKF,OAAQ;;;QAGb,KAAKC,OAAQ;;KATjB;AAYD;;AAED;;;;;;;;;;;AAWA,MAAIE,mBAAJ,GAAmC;AACjC,UAAMJ,UAAU,KAAKA,OAArB;;AAEA,QAAIA,WAAWV,KAAKU,OAAL,CAAf,EAA8B;AAC5B,aAAO,OAAOA,QAAQN,SAAf,KAA6B,WAApC;AACD;;AAED,WAAO,KAAP;AACD;AA3FwD;;QAA9CG,2B,GAAAA,2B;kBA8FEA,2B","file":"ResolverResultsPatcherError.js","sourceRoot":"src","sourcesContent":["// @flow\n\nimport { inline, dropLowest } from 'ne-tag-fns'\nimport { BaseError } from '../BaseError'\n\nimport type { ResolverResultsPatcher } from '../ExtendedResolver'\n\nconst isFn = o => /Function\\]/.test(Object.prototype.toString.call(o))\n\n/**\n * The `ResolverResultsPatcherError` can occur as the `ExtendedResolver` is\n * finishing and the final results are passed to a patcher function for final\n * inspection or modification. If an error is thrown at this time, the values\n * passed to the function are captured here for review by the programmer using\n * them\n *\n * @class ResolverResultsPatcherError\n */\nexport class ResolverResultsPatcherError extends BaseError {\n  /**\n   * The `ResolverResultsPatcher` function that failed.\n   *\n   * @type {Function}\n   */\n  patcher: ResolverResultsPatcher\n\n  /**\n   * The `this` value passed to the function as it was executed. Note that\n   * this value is irrelevant if the function passed was a big arrow function\n   *\n   * @type {mixed}\n   */\n  context: mixed\n\n  /**\n   * The `results` value before the internal patcher that failed was thrown.\n   * This does not include the results of the erroring function in question as\n   * no value was ever reached before the exception was thrown (in theory)\n   *\n   * @type {mixed}\n   */\n  results: mixed\n\n  /**\n   * Creates a new instance of `ResolverResultsPatcherError`.\n   *\n   * @constructor\n   *\n   * @param {string|Error} error the actual thrown error or error message\n   * @param {Function} patcher the function called during the time of the error\n   * @param {mixed} context the `this` arg applied to the call when the error\n   * occurred; use `resolverResultsPatcherError.wasBigArrowFunction` to check\n   * if the `this` arg would have had any results\n   * @param {mixed} results the final results from the `ExtendedResolver`\n   * execution that were passed to the patcher function\n   */\n  constructor(\n    error: Error | string,\n    patcher: ResolverResultsPatcher,\n    context: mixed,\n    results: mixed\n  ) {\n    super(error)\n\n    this.patcher = patcher\n    this.context = context\n    this.results = results\n  }\n\n  /**\n   * Description of the ResolverResultsPatcherError error and likely cause\n   * and fix.\n   *\n   * @return {string} a string denoting the purpose/cause of this error class\n   */\n  toString(): string {\n    return dropLowest`\n      The patcher function failed to execute against the results of the\n      'ExtendedResolver' execution. The patcher function had a name of\n      '${this.patcher && this.patcher.name || null}'.\n\n      The context of the patcher was:\n      ${this.context}\n\n      The results passed to the function were:\n      ${this.results}\n\n    `\n  }\n\n  /**\n   * A programmatic attempt to determine if the function that failed was a\n   * big arrow function. This means the function was pre-bound and the\n   * `context` set at the time of execution would have been ignored.\n   *\n   * @function wasBigArrowFunction\n   *\n   * @return {boolean} true if the failed function was a big arrow or\n   * pre-bound function; false if the `context` value should have been passed\n   * successfully to the execution context\n   */\n  get wasBigArrowFunction(): boolean {\n    const patcher = this.patcher\n\n    if (patcher && isFn(patcher)) {\n      return typeof patcher.prototype === 'undefined'\n    }\n\n    return false\n  }\n}\n\nexport default ResolverResultsPatcherError\n"]}