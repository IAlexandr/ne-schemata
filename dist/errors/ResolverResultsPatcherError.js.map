{"version":3,"sources":["../../src/errors/ResolverResultsPatcherError.js"],"names":["isFn","o","test","Object","prototype","toString","call","pe","PrettyError","ResolverResultsPatcherError","BaseError","constructor","error","patcher","context","results","dropLowest","name","colors","depth","render","valueOf","wasBigArrowFunction"],"mappings":";;;;;;;AAEA;;AACA;;AACA;;AACA;;;;;;AAIA,MAAMA,OAAOC,KAAK,aAAaC,IAAb,CAAkBC,OAAOC,SAAP,CAAiBC,QAAjB,CAA0BC,IAA1B,CAA+BL,CAA/B,CAAlB,CAAlB;AACA,MAAMM,KAAK,IAAIC,qBAAJ,EAAX;;AAEA;;;;;;;;;AASO,MAAMC,2BAAN,SAA0CC,oBAA1C,CAAoD;;AAyBzD;;;;;;;;;;;;;;;AAjBA;;;;;;AA8BAC,cACEC,KADF,EAEEC,OAFF,EAGEC,OAHF,EAIEC,OAJF,EAKE;AACA,UAAMH,KAAN;;AAEA,SAAKC,OAAL,GAAeA,OAAf;AACA,SAAKC,OAAL,GAAeA,OAAf;AACA,SAAKC,OAAL,GAAeA,OAAf;AACD;;AAED;;;;;;;;AAnCA;;;;;;;;AAfA;;;;;AAwDAV,aAAmB;AACjB,WAAOW,oBAAW;;;SAGb,KAAKH,OAAL,IAAgB,KAAKA,OAAL,CAAaI,IAA7B,IAAqC,IAAK;;;QAG3C,mBAAQ,KAAKH,OAAb,EAAsB,EAACI,QAAQ,IAAT,EAAeC,OAAO,CAAtB,EAAtB,CAAgD;;;QAGhD,mBAAQ,KAAKJ,OAAb,EAAsB,EAACG,QAAQ,IAAT,EAAeC,OAAO,CAAtB,EAAtB,CAAgD;;;QAGhDZ,GAAGa,MAAH,CAAU,KAAKR,KAAf,CAAsB;;KAZ1B;AAeD;;AAED;;;;;AAKAS,YAAkB;AAChB,WAAO,KAAKhB,QAAL,EAAP;AACD;;AAED;;;;;;;;;;;AAWA,MAAIiB,mBAAJ,GAAmC;AACjC,UAAMT,UAAU,KAAKA,OAArB;;AAEA,QAAIA,WAAWb,KAAKa,OAAL,CAAf,EAA8B;AAC5B,aAAO,OAAOA,QAAQT,SAAf,KAA6B,WAApC;AACD;;AAED,WAAO,KAAP;AACD;AAvGwD;;QAA9CK,2B,GAAAA,2B;kBA0GEA,2B","file":"ResolverResultsPatcherError.js","sourceRoot":"src","sourcesContent":["// @flow\n\nimport { inline, dropLowest } from 'ne-tag-fns'\nimport { BaseError } from '../BaseError'\nimport { inspect } from 'util'\nimport PrettyError from 'pretty-error'\n\nimport type { ResolverResultsPatcher } from '../ExtendedResolver'\n\nconst isFn = o => /Function\\]/.test(Object.prototype.toString.call(o))\nconst pe = new PrettyError()\n\n/**\n * The `ResolverResultsPatcherError` can occur as the `ExtendedResolver` is\n * finishing and the final results are passed to a patcher function for final\n * inspection or modification. If an error is thrown at this time, the values\n * passed to the function are captured here for review by the programmer using\n * them\n *\n * @class ResolverResultsPatcherError\n */\nexport class ResolverResultsPatcherError extends BaseError {\n  /**\n   * The `ResolverResultsPatcher` function that failed.\n   *\n   * @type {Function}\n   */\n  patcher: ResolverResultsPatcher\n\n  /**\n   * The `this` value passed to the function as it was executed. Note that\n   * this value is irrelevant if the function passed was a big arrow function\n   *\n   * @type {mixed}\n   */\n  context: mixed\n\n  /**\n   * The `results` value before the internal patcher that failed was thrown.\n   * This does not include the results of the erroring function in question as\n   * no value was ever reached before the exception was thrown (in theory)\n   *\n   * @type {mixed}\n   */\n  results: mixed\n\n  /**\n   * Creates a new instance of `ResolverResultsPatcherError`.\n   *\n   * @constructor\n   *\n   * @param {string|Error} error the actual thrown error or error message\n   * @param {Function} patcher the function called during the time of the error\n   * @param {mixed} context the `this` arg applied to the call when the error\n   * occurred; use `resolverResultsPatcherError.wasBigArrowFunction` to check\n   * if the `this` arg would have had any results\n   * @param {mixed} results the final results from the `ExtendedResolver`\n   * execution that were passed to the patcher function\n   */\n  constructor(\n    error: Error | string,\n    patcher: ResolverResultsPatcher,\n    context: mixed,\n    results: mixed\n  ) {\n    super(error)\n\n    this.patcher = patcher\n    this.context = context\n    this.results = results\n  }\n\n  /**\n   * Description of the ResolverResultsPatcherError error and likely cause\n   * and fix.\n   *\n   * @return {string} a string denoting the purpose/cause of this error class\n   */\n  toString(): string {\n    return dropLowest`\n      The patcher function failed to execute against the results of the\n      'ExtendedResolver' execution. The patcher function had a name of\n      '${this.patcher && this.patcher.name || null}'.\n\n      The context of the patcher was:\n      ${inspect(this.context, {colors: true, depth: 8})}\n\n      The results passed to the function were:\n      ${inspect(this.results, {colors: true, depth: 8})}\n\n      Original Stack Trace\n      ${pe.render(this.error)}\n\n    `\n  }\n\n  /**\n   * Modify the `valueOf()` function to mirror the `toString()` functionality\n   * \n   * @return {string} an identical string to `.toString()`\n   */\n  valueOf(): string {\n    return this.toString()\n  }\n\n  /**\n   * A programmatic attempt to determine if the function that failed was a\n   * big arrow function. This means the function was pre-bound and the\n   * `context` set at the time of execution would have been ignored.\n   *\n   * @function wasBigArrowFunction\n   *\n   * @return {boolean} true if the failed function was a big arrow or\n   * pre-bound function; false if the `context` value should have been passed\n   * successfully to the execution context\n   */\n  get wasBigArrowFunction(): boolean {\n    const patcher = this.patcher\n\n    if (patcher && isFn(patcher)) {\n      return typeof patcher.prototype === 'undefined'\n    }\n\n    return false\n  }\n}\n\nexport default ResolverResultsPatcherError\n"]}