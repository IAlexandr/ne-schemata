{"version":3,"sources":["../src/forEachOf.js"],"names":["ALL","TYPES","INTERFACES","ENUMS","UNIONS","SCALARS","ROOT_TYPES","INPUT_TYPES","HIDDEN","Masks","TypeMap","set","forEachOf","schema","fn","context","types","forEach","t","prototype","includes","get","constructor","name","typeMap","getTypeMap","typeName","type","hidden","startsWith","showHidden","directives","astNode","doIt","mask","getQueryType","getSubscriptionType","getMutationType","forEachField","_","_fields","fieldName","field","fieldDirectives","fieldArgs","args"],"mappings":"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","file":"forEachOf.js","sourceRoot":"src","sourcesContent":["// @flow\n\nimport {\n  getNamedType,\n  GraphQLObjectType,\n  GraphQLInterfaceType,\n  GraphQLInputObjectType,\n  GraphQLEnumType,\n  GraphQLUnionType,\n  GraphQLScalarType,\n  GraphQLType,\n  GraphQLSchema,\n} from 'graphql'\n\nexport type ForEachOfResolver = (\n  type: mixed,\n  typeName: string,\n  typeDirectives: Array<GraphQLDirective>,\n  schema: GraphQLSchema,\n  context: mixed\n) => void\n\nexport type ForEachFieldResolver = (\n  type: mixed,\n  typeName: string,\n  typeDirectives: Array<GraphQLDirective>,\n  field: mixed,\n  fieldName: string,\n  fieldArgs: Array<GraphQLArgument>,\n  fieldDirectives: Array<GraphQLDirective>,\n  schema: GraphQLSchema,\n  context: mixed\n) => void\n\n// Create constants for each of the types allowed, over which one might\n// iterate. These can be bitmasked to include multiple types; i.e. for both\n// type and enums, pass TYPES | ENUMS for the types parameter. It\n// defaults to simply types.\nconst ALL = 1\nconst TYPES = 2\nconst INTERFACES = 4\nconst ENUMS = 8\nconst UNIONS = 16\nconst SCALARS = 32\nconst ROOT_TYPES = 64\nconst INPUT_TYPES = 128\nconst HIDDEN = 256\nconst Masks = [\n  ALL, TYPES, INTERFACES, UNIONS, ENUMS, SCALARS,\n  ROOT_TYPES, INPUT_TYPES\n]\n\n// Create a mapping from the constant to the GraphQL type class.\nconst TypeMap: Map<number, GraphQLType> = new Map()\nTypeMap.set(TYPES, GraphQLObjectType)\nTypeMap.set(ROOT_TYPES, GraphQLObjectType)\nTypeMap.set(INTERFACES, GraphQLInterfaceType)\nTypeMap.set(INPUT_TYPES, GraphQLInputObjectType)\nTypeMap.set(ENUMS, GraphQLEnumType)\nTypeMap.set(UNIONS, GraphQLUnionType)\nTypeMap.set(SCALARS, GraphQLScalarType)\n\n/**\n * Iterates over the values contained in a Schema's typeMap. If a desired\n * value is encountered, the supplied callback will be invoked. The values are\n * the constants ALL, TYPES, INTERFACES, ENUMS, UNIONS and SCALARS. Optionally\n * HIDDEN is another value that can be bitmasked together for a varied result.\n * HIDDEN exposes the values in the schema typemap that begin with a double\n * underscore.\n *\n * The signature for the function callback is as follows:\n * (\n *   type: mixed,\n *   typeName: string,\n *   typeDirectives: Array<GraphQLDirective>\n *   schema: GraphQLSchema,\n *   context: mixed,\n * ) => void\n *\n * Where:\n *   `type`           - the object instance from within the `GraphQLSchema`\n *   `typeName`       - the name of the object; \"Query\" for type Query and\n *                      so on.\n *   `typeDirectives` - an array of directives applied to the object or an\n *                      empty array if there are none applied.\n *   `schema`         - an instance of `GraphQLSchema` over which to iterate\n *   `context`        - usually an object, and usually the same object,\n *                      passed to the call to `makeExecutableSchema()`\n *                      or `graphql()`\n *\n * @param {Function} fn a function with a signature defined above\n * @param {mixed} context usually an object but any mixed value the denotes\n * some shared context as is used with the schema during normal runtime.\n * @param {Number} types a bitmask of one or more of the constants defined\n * above. These can be OR'ed together and default to TYPES.\n * @return {GraphQLSchema} a new schema is generated from this SDL, iterated\n * over and returned.\n */\nfunction forEachOf(\n  schema: GraphQLSchema,\n  fn: ForEachOfResolver,\n  context: mixed,\n  types: number = ALL\n): GraphQLSchema {\n  [\n    GraphQLObjectType, GraphQLInterfaceType, GraphQLEnumType,\n    GraphQLUnionType, GraphQLScalarType\n  ].forEach(t => {\n    if (!t) return;\n\n    if (\n      !Object.getOwnPropertySymbols(t.prototype).includes(Symbol.toStringTag)\n    ) {\n      Object.defineProperties(t.prototype, {\n        [Symbol.toStringTag]: { get() { return this.constructor.name } }\n      })\n    }\n  })\n\n  const typeMap = schema.getTypeMap();\n\n  Object.keys(typeMap).forEach(typeName => {\n    const type = typeMap[typeName];\n    const hidden = getNamedType(type).name.startsWith('__')\n    const showHidden = (types & HIDDEN) === HIDDEN\n    const directives = type && type.astNode && type.astNode.directives || []\n    let doIt = (types & ALL) === ALL\n\n    Masks.forEach(mask => {\n      if (doIt) {\n        return\n      }\n      else if (\n        (mask & ROOT_TYPES) === ROOT_TYPES\n        &&\n        (\n          type === schema.getQueryType()\n          || type === schema.getSubscriptionType()\n          || type === schema.getMutationType()\n        )\n      ) {\n        doIt = true\n        return\n      }\n      else {\n        doIt =\n          ((types & mask) === mask) &&\n          type instanceof TypeMap.get(mask)\n      }\n    })\n\n    // Prevent hidden items from being shown unless asked for\n    doIt = doIt && (!hidden || (hidden && showHidden))\n\n    if (doIt)\n      fn(type, typeName, directives, schema, context)\n  });\n}\n\n/**\n * An extension of `forEachOf` that targets the fields of the types in the\n * schema's typeMap. This function provides more detail and allows greater\n * access to any associated `context` than the function of the same name\n * provided by the `graphql-tools` library.\n *\n * The signature for the callback function is as follows\n *\n * (\n *   type: mixed,\n *   typeName: string,\n *   typeDirectives: Array<GraphQLDirective>,\n *   field: mixed,\n *   fieldName: string,\n *   fieldArgs: Array<GraphQLArgument>,\n *   fieldDirectives: Array<GraphQLDirective>,\n *   schema: GraphQLSchema,\n *   context: mixed\n * ) => void\n *\n * Where\n *\n * Where:\n *   `type`           - the object instance from within the `GraphQLSchema`\n *   `typeName`       - the name of the object; \"Query\" for type Query and so on\n *   `typeDirectives` - an array of directives applied to the object or an empty\n *                      array if there are none applied.\n *   `field`          - the field in question from the type\n *   `fieldName`      - the name of the field as a string\n *   `fieldArgs`      - an array of arguments for the field in question\n *   `fieldDirectives`- an array of directives applied to the field or an empty\n *                      array should there be no applied directives\n *   `schema`         - an instance of `GraphQLSchema` over which to iterate\n *   `context`        - usually an object, and usually the same object, passed\n *                      to the call to `makeExecutableSchema()` or `graphql()`\n *\n * @param {GraphQLSchema} schema\n * @param {Function} fn a function with a signature defined above\n * @param {mixed} context usually an object but any mixed value the denotes\n * some shared context as is used with the schema during normal runtime.\n */\nfunction forEachField(\n  schema: GraphQLSchema,\n  fn: ForEachFieldResolver,\n  context: mixed,\n  types: number = ALL\n): GraphQLSchema {\n  forEachOf(\n    schema,\n    (type, typeName, _, context, directives) => {\n      if (!type._fields) {\n        return\n      }\n\n      Object.keys(type._fields).forEach(fieldName => {\n        let field = type._fields[fieldName]\n        let fieldDirectives = field.astNode && field.astNode.directives || []\n        let fieldArgs = field.args || []\n\n        fn(\n          type,\n          typeName,\n          directives,\n          field,\n          fieldName,\n          fieldArgs,\n          fieldDirectives,\n          schema,\n          context\n        )\n      })\n    },\n    context,\n    types\n  )\n}\n\nexport {\n  ALL,\n  TYPES,\n  INTERFACES,\n  ENUMS,\n  UNIONS,\n  SCALARS,\n  ROOT_TYPES,\n  INPUT_TYPES,\n  HIDDEN,\n\n  TypeMap,\n\n  forEachOf,\n  forEachField\n}\n\nexport default forEachOf\n"]}