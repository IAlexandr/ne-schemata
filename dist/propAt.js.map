{"version":3,"sources":["../src/propAt.js"],"names":["at","atNicely","object","path","setTo","playNice","includes","split","undefined","eval","reduce","p","c","error","console"],"mappings":";;;;;QAiDgBA,E,GAAAA,E;QAmDAC,Q,GAAAA,Q;;;AAlGhB;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA+CO,SAASD,EAAT,CACLE,MADK,EAELC,IAFK,EAGLC,KAHK,EAILC,WAAqB,KAJhB,EAKE;AACP,MAAI,OAAOF,IAAP,KAAgB,QAApB,EAA8B;AAC5B,QAAIA,KAAKG,QAAL,CAAc,GAAd,CAAJ,EAAwB;AACtBH,aAAOA,KAAKI,KAAL,CAAW,GAAX,CAAP;AACD,KAFD,MAGK;AACHJ,aAAO,CAACA,IAAD,CAAP;AACD;AACF;;AAED,MAAI;AACF,QAAIC,UAAUI,SAAd,EAAyB;AACvBC,WAAM,UAASN,KAAKO,MAAL,CAAY,CAACC,CAAD,EAAIC,CAAJ,KAAW,GAAED,CAAE,KAAIC,CAAE,IAAjC,EAAsC,EAAtC,CAA0C,WAAzD;AACD;;AAED,WAAOH,KAAM,UAASN,KAAKO,MAAL,CAAY,CAACC,CAAD,EAAIC,CAAJ,KAAW,GAAED,CAAE,KAAIC,CAAE,IAAjC,EAAsC,EAAtC,CAA0C,GAAzD,CAAP;AACD,GAND,CAOA,OAAOC,KAAP,EAAc;AACZ,QAAIR,QAAJ,EAAc;AACZ,aAAOG,SAAP;AACD;;AAEDM,YAAQD,KAAR,CAAe,0CAAf;AACAC,YAAQD,KAAR,CAAe,gBAAeV,KAAKO,MAAL,CAAY,CAACC,CAAD,EAAIC,CAAJ,KAAW,GAAED,CAAE,KAAIC,CAAE,IAAjC,EAAsC,EAAtC,CAA0C,EAAxE;;AAEA,UAAMC,KAAN;AACD;AACF;;AAED;;;;;;;;;;;;;;;;;AAiBO,SAASZ,QAAT,CACLC,MADK,EAELC,IAFK,EAGLC,KAHK,EAIE;AACP,SAAOJ,GAAGE,MAAH,EAAWC,IAAX,EAAiBC,KAAjB,EAAwB,IAAxB,CAAP;AACD;;AAED;;;;;;;;;;;;;;kBAceH,Q","file":"propAt.js","sourceRoot":"src","sourcesContent":["// @flow\n\n/**\n * This function takes an array of values that are used with `eval` to\n * dynamically, and programmatically, access the value of an object in a nested\n * fashion. It can take either a string with values separated by periods\n * (including array indices as numbers) or an array equivalent were\n * `.split('.')` to have been called on said string.\n *\n * Examples:\n * ```\n *   // Calling `at` with either set of arguments below results in the same\n *   // values.\n *   let object = { cats: [{ name: 'Sally' }, { name: 'Rose' }] }\n *\n *   at(object, 'cats.1.name') => Rose\n *   at(object, ['cats', 1, 'name']) => Rose\n *\n *   // Values can be altered using the same notation\n *   at(object, 'cats.1.name', 'Brie') => Brie\n *\n *   // Values cannot normally be accessed beyond existence. The following\n *   // will throw an error. A message to console.error will be written showing\n *   // the attempted path before the error is again rethrown\n *   at(object, 'I.do.not.exist') => ERROR\n *\n *   // However, if you want the function to play nice, `undefined` can be\n *   // returned instead of throwing an error if true is specified as the\n *   // fourth parameter\n *   at(object, 'I.do.not.exist', undefined, true) => undefined\n * ```\n *\n * @method at\n *\n * @param {Object} object an object that can be accessed using bracket notation\n * to access its inner property value. Anything extending object, including\n * arrays and functions, should work in this manner.\n * @param {string|Array<string>} path a period denoted path (numeric indicies\n * are allowed) or an array of individual strings. See above for more details\n * @param {mixed} setTo (optional) if this value is supplied, the path accessed\n * will be modified to this value before it is returned\n * @param {boolean} playNice (optional) by default if one tries to access a\n * path that fails somewhere in the middle and results in accessing a property\n * on an undefined or null value then an exception is thrown. Passing true here\n * will cause the function to simply return undefined.\n * @return {mixed} either the requested value or undefined as long as no\n * invalid access was requested. Otherwise an error is thrown if try to deeply\n * reach into a space where no value exists.\n */\nexport function at(\n  object: Object,\n  path: string | Array<string>,\n  setTo?: mixed,\n  playNice?: boolean = false\n): mixed {\n  if (typeof path === 'string') {\n    if (path.includes('.')) {\n      path = path.split('.')\n    }\n    else {\n      path = [path]\n    }\n  }\n\n  try {\n    if (setTo !== undefined) {\n      eval(`(object${path.reduce((p, c) => `${p}['${c}']`, '')} = setTo)`)\n    }\n\n    return eval(`(object${path.reduce((p, c) => `${p}['${c}']`, '')})`)\n  }\n  catch (error) {\n    if (playNice) {\n      return undefined\n    }\n\n    console.error(`[ERROR:at] Cannot reach into the beyond!`)\n    console.error(`Tried: object${path.reduce((p, c) => `${p}['${c}']`, '')}`)\n\n    throw error\n  }\n}\n\n/**\n * `atNicely()` is a shorthand version of calling `at()` but specifying `true`\n * for the argument `playNice`. This can make reads normally performed with\n * calls to `at()` where you want to prevent errors from being thrown with\n * invalid paths\n *\n * @method atNicely\n *\n * @param {Object} object an object that can be accessed using bracket notation\n * to access its inner property value. Anything extending object, including\n * arrays and functions, should work in this manner.\n * @param {string|Array<string>} path a period denoted path (numeric indicies\n * are allowed) or an array of individual strings. See above for more details\n * @param {mixed} setTo (optional) if this value is supplied, the path accessed\n * will be modified to this value before it is returned\n * @return {mixed} either the requested value or undefined\n */\nexport function atNicely(\n  object: Object,\n  path: string | Array<string>,\n  setTo?: mixed\n): mixed {\n  return at(object, path, setTo, true)\n}\n\n/**\n * Default export is atNicely; as long as you know what you want, this leaves\n * cleaner code in your repository. Simply add this to the top of your module\n * ```\n * const at = require('./propAt').default\n * // or\n * import at from './propAt'\n *\n * // of course if you prefer, you may still do the following\n * const at = require('./propAt').at;\n * // or\n * import { at } from './propAt'\n * ```\n */\nexport default atNicely\n"]}